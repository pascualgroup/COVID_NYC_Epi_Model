---
title: "SEIR Hyrbid Model with 1 Pre-Symptomatic Compartment: Pre-Symp and Asymp have same rate with Presymp occuring before Asymp/Symp split"
author: "Rahul Subramanian"
date: "April 12, 2020"
output: 
  html_document:
    toc: true
    toc_float: true
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


#Load Libraries

```{r load_lib}
rm(list = ls())
library(plyr)
library(tidyverse)
library(magrittr)
library(tibble)
library(stringi)
library(pomp)
library(xtable)
#library(panelPomp)
#library(foreach)
#library(iterators)
#library(doRNG)
#library(aakmisc) ## available at https://kingaa.github.io/
stopifnot(packageVersion("pomp")>="2.2")
#stopifnot(packageVersion("panelPomp")>="0.9.1")
#stopifnot(packageVersion("aakmisc")>="0.26.2")
options(
  stringsAsFactors=FALSE,
  keep.source=TRUE,
  encoding="UTF-8"
)
set.seed(407958184)
```

### Load essential libraries and plot themes
```{r}
source("load_libraries_essential.R")
source("rahul_theme.R")
library(zoo)
library(stringr)
```


We fit a modified SEIR model to case data from the 2019-nCoV epidemic in NYC using case data from () to ().

## Declare model name
```{r}
full_model_name = "NYC_Covid_Model_Hyrbid_Model_1_Pre-Symp_Compartment_Set_b_p_to_0"
model_name = "N_12"
rda_index = 0
rds_index = 0

```

## Compartment/Queue Cohort Numbers
```{r}
M = 5
V = 13
K = 14
```



```{r, echo = FALSE, include=FALSE}
source("Csnippet_nyc_coronavirus_model_N_12.R")
```

```{r, echo = FALSE, include=FALSE}

knitr::read_chunk('Csnippet_nyc_coronavirus_model_N_12.R')
```

# Model Summary
## Process Model

### Process Model Diagram
![Digram of process for (excluding queue) for simple model. ](../Figures/Model_Diagrams/Hybrid_Chained_Bifurcation_Model_Diagram.png)

### Process Model Description

The process model is an SEIR model, with compartments for pre-symptomatic,   symptomatic, and severe infections.

All individuals start out susceptible ($S$). They become infected with force of infection $\lambda(t)$ and move into the Exposed class ($E$)

We use chain of $M= 3$ compartments ($E_m$ where $m= 1:M$) to describe the Exposed class. Individuals leave each compartment at rate $\phi_E$. They spend an average of $\frac{1}{\phi_E}$ days in each compartment (exponentially distributed).

As individuals leave the exposed chain, they either  develop a symptomatic infection with probability $p_S$ or an asymptomatic infection with probability $1-p_S$.

Individuals who develop an asymptomatic infection move from the exposed chain into the Infected Asymptomatic compartment ($I_A$). In this compartment, individuals transmit with intensity $\beta_A$, where $\beta_A = b_a*\beta$. 

Individuals in $I_A$ recover at rate $\phi_S$ and move to the recovered asymptomatic compartment $R_A$, spending an average of $\frac{1}{phi_S}$ days in the asymptomatic infected compartment.   

We note that in this model asymptomatic infections do not have an explicit presymptomatic phase that is distinct from their asymptomatic phase.

Individuals who develop a symptomatic infection experience pre-symptomatic infection ($I_P$).

We use chain of $U= 1$ compartments ($I_{P}$) to describe the Infected Presymptomatic class class. Individuals leave each compartment at rate $\phi_U$. They spend an average of $\frac{1}{\phi_U}$ days in each compartment (exponentially distributed).

During each of these 1 compartments , individuals are able to (asymptomatically) transmit at rate $\beta_P$ where $\beta_P = b_p \beta (t)$.

After leaving the  presymptomatic compartment $I_{P}$, individuals move into the symptomatic infection compartment $I_S$. Individuals spent an average of 5 days (exponentially distributed) in the symptomatic infection compartment $I_S$ (they leave at rate $phi_S = 1/5$ ).

After existing $I_S$, they enter compartment $I_{S_2}$ with probability $(1- p_{\text{H_cond_S}})$ (at which point they enter the potentially detected queue Queue 2) or compartment   $I_H$ with probability $p_{\text{H_cond_S}}$ (at which point they enter the always detected queue Queue 1). Individuals in $I_{S_2}$ recover at rate $\gamma$, entering the compartment $R_F$. Hospitalized individuals recover at rate $h_V = \frac{1}{13}$ and move into compartment $R_H$.






## Testing Queue/PCR Testing/Measurement Model


### Queue Diagrams

![Queues 1 and 2 (Hospitalized patients)). ](../Figures/Age_Structured_Model_With_NYC_Queue_NYC_Queue_Schematic_Q_1_and_Q2.png)



![Queues 3 and 4 (Symptomatic patients)). ](../Figures/Age_Structured_Model_With_NYC_Queue_NYC_Queue_Schematic_Q_5_and_Q6.png)




### Description of Queue/Measurement model. 
We assume that there are three groups of people

i) People who will always be tested (once the testing queue has been established). This includes people who were hospitalized with COVID, as well as people who were not hospitalized with COVID but whose doctors' recommended that they get tested anyway for the purposes of treatment. For simplicity, we do not distinguish between those two groups in our model. These individuals enter Queue 1 ($Q_1$). These individuals are tested at the same time and with the same priority as non-COVID individuals who present in the emergency department of a New York City hospital with respiratory symptoms during the epidemic during week $w$.  ($G(w)$). These individuals enter Queue NC ($Q_{\text{NC}}$). Individuals who test positive for COVID are subsequently re-tested upon leaving the hospital, and again 24 hours after that. We assume that individuals from Queue 1 who tested positive are re-sampled 13 days after they entered Queue 1, and then again 1 more day later. The re-testing  is dealt with in Queue 2, which has highest priority after Queue 1 and Queue NC. 

ii) People who could potentially be detected if their were enough testing capacity. We assume that these individuals have symptoms of COVID or flu-like symptoms, and make contact with the health care system at the same time as individuals who are hospitalized/deemed critical cases. However, they are only tested if there is enough testing capacity. In our model, these individuals are added to Queue 3 when they enter the $I_{S_2}$ compartment. Queue 3 is precede in priority by Queues 1,NC, and 2.   Samples that test positive contribute to the reported case count that day. This queue has a loss rate given by ($\frac{1}{gamma}$), as we assume that individuals will not seek available COVID-testing after their symptoms have gone. If there is insufficient capacity to test individuals as they arrive in Queue 4, they immediately exit the queue. 
Individuals who test positive in Queue 3 are re-tested two weeks after entering Queue 3, and again 24 hours later. This is dealt with in Queue 4.  Samples that test positive do not contribute to the reported case count that day. Samples do not queue here-we assume that unless their is enough testing capacity, symptomatic people who recover are not sampled at the end of the quarantine period, and that the sampling performed on a given day is less than or equal to (not greater than) the surplus testing capacity ($L_4$) available for that category on that day. 



We assume that if an individual's sample in queue 1 or 3 is still in the queue at the time they would be expected to either leave the hospital (for Queue 1) or leave quarantine (Queue 3), then they will not be sampled again when they leave quarantine/hospital (i.e. their positive sample will not be entered into Queues 2 or 4).  They will however still be tested. 

We use the total number of PCR tests conducted each day across the five counties compromising New York City as measured by the New York State Health Department's COVID tracker as the daily testing capacity for the city. This capacity is fed into the model as a co-variate ($L(t)$).

We assume that there is additional negative-binomial distributed dispersion after the PCR testing with standard deviation $\sigma_{\text{M}}$. 

## State Variables

```{r statenames}

```
### Table of State Variables
```{r, results='asis', echo = FALSE}

table_1_df = data.frame(Term = c(" $S(t)$ ", "$E_m(t)$",
                                 "$I_{P_q}(t)$",
                                 " $I_{A}(t)$ ",
                                 " $I_{{S}_1}(t)$ ",
                                 " $I_{{S}_2}(t)$ ", " $I_{H}(t)$ ",
                                 " $R_A(t)$ ", " $R_F(t)$ ", " $R_H(t)$ ",
                                 " $C_{Q1}(t)$ ", " $C_{QNC}(t)$ ",
                                 " $C_{Q2}(t)$ ",
                                 " $C_{Q3}(t)$ ", " $C_{Q4}(t)$ ",
                                 " $Y_{Q1}(t)$ ", " $Y_{Q3}(t)$ ",
                                 " $Y_{sum}(t)$ "," $Y_{QNC}(t)$ ",
                                 " $Q_1(v,t)$ ",
                                 " $Q_{NC}(v,t)$ ",
                                 " Backlog_Queue_1(t) ",
                                 " Backlog_Queue_{NC}(t) ",
                                 " $Q_2(t)$ ",
                                 " $Q_3(k,t)$ ",
                                 " Backlog_Queue_3(t) ",
                                 " $Q_4(t)$ ",
                                 " $P_{Q1}(v,t)$ ",
                                 " $P_{Q3}(k,t)$ ",
                                 " First_re_test_Q1(t) ",
                                 " First_re_test_Q3(t) ",
                                 " Second_re_test_Q1(t) ",
                                 " Second_re_test_Q3(t) ",
                                 " total_samples_for_PCR_Testing_backlog_QNC(t) ",
                                 " total_samples_for_PCR_Testing_backlog_Q1(t) ",
                                 " total_samples_for_PCR_Testing_backlog_Q3(t) ",
                                 " total_samples_for_PCR_Testing_backlog_lag_1_Q1(t) ",
                                 " total_samples_for_PCR_Testing_backlog_lag_1_QNC(t) ",
                                 " total_samples_for_PCR_Testing_backlog_lag_1_Q3(t) ",
                                 " total_samples_for_PCR_Testing_backlog_lag_2_Q1(t) ",
                                 " total_samples_for_PCR_Testing_backlog_lag_2_QNC(t) ",
                                 " total_samples_for_PCR_Testing_backlog_lag_2_Q3(t) ",
                                 " total_samples_for_PCR_Testing_Q1(v,t) ",
                                 " total_samples_for_PCR_Testing_QNC(v,t) ",
                                 " total_samples_for_PCR_Testing_Q3(k,t) ",
                                 " total_samples_for_PCR_Testing_lag_1_Q1(v,t) ",
                                 " total_samples_for_PCR_Testing_lag_1_QNC(v,t) ",
                                 " total_samples_for_PCR_Testing_lag_1_Q3(k,t) ",
                                 " total_samples_for_PCR_Testing_lag_2_Q1(v,t) ",
                                 " total_samples_for_PCR_Testing_lag_2_QNC(v,t) ",
                                 " total_samples_for_PCR_Testing_lag_2_Q3(k,t) ",
                                 " neg_samples_Q1(t) ",
                                 " neg_samples_Q3(t) ",
                                 " total_neg_samples_all_queues(t) ",
                                 " $N(t)$ ",
                                 " L_advanced_2_days(t) ",
                                 " L_total_pos_advanced_2_days(t) ",
                                 " L_int(t) ",
                                 " L_1(t) ",
                                 " L_2(t) ",
                                 " L_3(t) ",
                                 " L_4(t) ",
                                 " Prop_Positive_Tests_Track(t) ",
                                 " diag_change_done "),
                        Definition = c("  Susceptible individuals ",
                                       "  Exposed individuals in compartment $m$ (m = 1:M)",
                                       "  Infected pre-symptomatic individuals ",
                                       "  Infected asymptomatic individuals in ",
                                       "  Infected symptomatic individuals who may or may not develop severe infection ",
                                       "  Infected symptomatic (non-severe) individuals  ",
                                       "  Individuals with severe  infections requiring hospitalizations ",
                                       
                                       "  Recovered asymptomatic individuals  ",
                                       "  Recovered  individuals who had a symptomatic (non-severe) infection  ",
                                       "  Recovered individuals who had a severe infection ",
                                       "  Daily cases entering Queue 1 ",
                                       "  Daily non-COVID respiratory cases entering Queue NC ",
                                       "  Daily cases entering Queue 2 ",
                                       "  Daily cases entering Queue 3 ",
                                       "  Daily cases entering Queue 4 ",
                                       "  Confirmed Cases Queue 1 ",
                                       "  Confirmed Cases Queue 3 ",
                                       "  Total Daily Confirmed Cases ",
                                       "  Confirmed Non-COVID Cases Queue NC ",
                                       "  Samples in Queue 1 at time t sampled at time v (v ranges from 1:V, where V = 8) ",
                                       "  Samples in Queue NC at time t sampled at time v (v ranges from 1:V, where V = 8) ",
                                       "  Samples in Queue 1 that will not be entered into Queue 2 (have already left hospital while still in Queue 1)",
                                       "  Samples in Queue NC that have already left hospital while still in Queue 1)",
                                       "  Samples in Queue 2",
                                       "  Samples in Queue 3 at time t sampled at time k (k ranges from 1:K, where K = 14) ",
                                        "  Samples in Queue 3 that will not be entered into Queue 4 (have already left quarantine while still in Queue 3)",
                                       "  Samples in Queue 4 ",
                                       "  Positive samples from queue 1 at time t first sampled at time v",
                                       "  Positive samples from queue 3 at time t first sampled at time k",
                                       "  Positive samples from queue 1 that were first re-sampled on day t  upon leaving the hospital",
                                       "  Positive samples from queue 3 that were first re-sampled on day t two weeks after the initial sampling ",
                                       "  Positive samples from queue 1 that were re-sampled a second time on day t  24 hours after the first re-sampling",
                                       "  Positive samples from queue 3 that were re-sampled a second time on day t  24 hours after the first re-sampling",
                                       "  Total Samples that were sent for PCR testing on day t from Queue 1 backlog ",
                                       "  Total Samples that were sent for PCR testing on day t from Queue NC backlog ",
                                        "  Total Samples that were sent for PCR testing on day t from Queue 3 backlog ",
                                       "  Total Samples that were sent for PCR testing on day t-1 from Queue 1 backlog ",
                                       "  Total Samples that were sent for PCR testing on day t-1 from Queue NC backlog ",
                                       "  Total Samples that were sent for PCR testing on day t-1 from Queue 3 backlog ",
                                       "  Total Samples that were sent for PCR testing on day t-2 from Queue 1 backlog ",
                                       "  Total Samples that were sent for PCR testing on day t-2 from Queue NC backlog ",
                                       "  Total Samples that were sent for PCR testing on day t-2 from Queue 3 backlog ",
                                       "  Total Samples first sampled on day v that were sent for PCR testing on day t from Queue 1 ",
                                       "  Total Samples first sampled on day v that were sent for PCR testing on day t from Queue NC ",
                                       "  Total Samples first sampled on day k that were sent for PCR testing on day t from Queue 3 ",
                                       "  Total Samples first sampled on day v that were sent for PCR testing on day t-1 from Queue 1 ",
                                       "  Total Samples first sampled on day v that were sent for PCR testing on day t-1 from Queue NC ",
                                       "  Total Samples first sampled on day k that were sent for PCR testing on day t-1 from Queue 3 ",
                                       "  Total Samples first sampled on day v that were sent for PCR testing on day t-2 from Queue 1 ",
                                        "  Total Samples first sampled on day v that were sent for PCR testing on day t-2 from Queue NC ",
                                       "  Total Samples first sampled on day v that were sent for PCR testing on day t-2 from Queue 3 ",
                                       "  Negative PCR Samples in Queue 1 tested on day t ",
                                       "  Negative PCR Samples in Queue 3 tested on day t ",
                                       "  Total negative samples (from all queues) tested on day t ",
                                       "  New York City Population  ",
                                       "  Total PCR testing capacity on day t +2  ",
                                       "  Estimated number of positive COVID cases (True Positive + False Negative) tested  on day t +2  ",
                                       "  PCR Testing Capacity Rounded to the Nearest Integer  ",
                                       "  Surplus PCR testing capacity used in/remaining after Queue 1 on day t +2  ",
                                       "  Surplus PCR testing capacity used in/remaining after Queue 2 on day t +2  ",
                                       "  Surplus PCR testing capacity used in/remaining after Queue 3 on day t +2  ",
                                       "  Surplus PCR testing capacity used in/remaining after Queue 4 on day t +2  ",
                                       "  Proportion of positive tests (positive tests/postie+negative tests simulated by model)  ",
                                       "  Diagnosis change has occurred "),
                        Type = c(" State Variable ", " State Variable", " State Variable ",
                                 " State Variable ", " State Variable ", " State Variable ",
                                 " State Variable ", " State Variable ",
                                 " State Variable ", " State Variable ",
                                 " Accumulator Variable ", " Accumulator Variable ",
                                 " Accumulator Variable ", " Accumulator Variable ",
                                 " Accumulator Variable ", " Accumulator Variable ",
                                 " Accumulator Variable ", " Accumulator Variable ", 
                                 " Accumulator Variable ", 
                                 " State Variable ", " State Variable ",
                                 " State Variable ", " State Variable ",
                                 " State Variable ",
                                 " State Variable ", " State Variable ",
                                 " State Variable ",
                                 " State Variable ", " State Variable ",
                                 " State Variable ",
                                 " State Variable ", " State Variable ",
                                 " State Variable ", " State Variable ",
                                 " State Variable ",
                                 " State Variable ", " State Variable ",
                                 " State Variable ", " State Variable ",
                                 " State Variable ", " State Variable ",
                                 " State Variable ", " State Variable ",
                                 " State Variable ", " State Variable ",
                                 " State Variable ", " State Variable ",
                                 " State Variable ",
                                 " State Variable ", " State Variable ",
                                 " State Variable ",
                                 " State Variable ", " State Variable ",
                                 " Accumulator Variable ", " State Variable ",
                                 " Co-variate ",
                                 " Co-variate ",
                                 " State Variable ", " State Variable ",
                                 " State Variable ",  " State Variable ",
                                 " State Variable ",
                                 " State Variable ",
                                 " Flag "))
colnames(table_1_df) = c(" Variable Term ", " Definition  of   Variable", " Variable  Type")
xtab<-xtable(table_1_df, caption=". State Variables and Co-variate.",
             label="State_Variable_Table", align = "c|c|c|c", autoformat = TRUE)

print(xtab,include.rownames = FALSE, type = "html",
       html.table.attributes = getOption("xtable.html.table.attributes",
                                    "border=3, cellpadding = 10, cellspacing = 10"))

```

## Start Date
We use a simulation start date of March 1st, but also assume that there was already community transmission at that point. 
Source for assumption that community transmission was perhaps already occurring by March 1st:
https://www.medrxiv.org/content/medrxiv/early/2020/04/16/2020.04.08.20056929.full.pdf

## Parameters
```{r paramnames}

```

### Table of Parameters
```{r, results='asis', echo=FALSE}

table_1_df = data.frame(Term = c(" $M$ "," $phi_U$ ", " $V$ "," $K$ ",
                                 " $\\phi_E$ ", " $\\phi_S$ ", 
                                 " $h_V$ ", 
                                 " p(S)", " p(H|S) ",
                                 " $\\gamma$ ",
                                 " quarantine_start_time ",
                                 "PCR_sens",
                                 " $b_{q}$ ", " $b_{a}$ ", " $b_{p}$ ",
                                " $R_{0}$ ", " $E_{0}$ ",
                                 " $I_{S_0}$ ", "N_0", "C_0",
                                " $\\sigma_{M}$ "),
                        Definition = c("  Number of Exposed Compartments ",
                                       "  Duration of Pre-Symptomatic Infection ",
                                       "  Average number of days spent in hospital for severe cases (Read in as $V_0$) ",
                                       "  Average number of days spent in quarantine after sampling of symptomatic non-severe cases (Read in as $K_0$)  ",
                                       "  Rate of leaving exposed each of $M$ exposed compartments ",
                                       "  Rate of onset of severe symptoms (1/time from symptom onset to onset of severe symptoms requiring hospitalization) ",
                                       "  Severe symptom recovery rate in non-critical patients who eventually develop severe symptoms (1/time spent with severe symptoms requiring hospitalization in non-ICU hospitalized patients) ",
                                       "  Probability that a new infection is symptomatic ",
                                       "  Probability that a new symptomatic infection will eventually become severe ",
                                       "  Recovery rate in individuals with flu-like symptoms (1/(duration of infection-time already symptomatic) ",
                                       "  Date stay at home order imposed ",
                                       "  Sensitivity of single PCR test ",
                                       "  Ratio of post-quarantine transmission rate to pre-quarantine transmission rate in all infectious compartments ",
                                       "  Ratio of transmission rate in asymptomatic infected individuals to transmission rate in symptomatic infected individuals independent of quarantine status ",
                                       "  Ratio of transmission rate in pre-symptomatic infected individuals to transmission rate in symptomatic infected individuals independent of quarantine status ",
                                       "  Pre-Quarantine reproductive number of virus ",
                                       "  Initial exposed individuals as of simulation start ",
                                       "  Pulse of initial zoonotic infections at simulation start on March 1, 2020  ",
                                       "  Initial population of NYC ",
                                       "  Initial number of daily hospitalizations ",
                                       "  Measurement noise standard deviation  "),
                        Value = c(" 5 "," 1.09 "," 8 ", " 14 ",
                                  " 1.09 ", " 1/5 ",
                                  " 1/13 ", 
                                  " 0.50-0.95 ", " NA ", 
                                 " NA ",
                                 " 2020-03-22 ",
                                   "90%",
                                 " .15 ", " NA ", " 0/NA ",
                                 " 2.5  (1.7-2.1)", " 10 ", " 0 ", 
                                 " 8*10^6", " 0 ", " 0.15 "),
                        Type = c(" Fix ", " Fix "," Fix ", " Fix ",
                                 " Fix ", " Fix ",
                                  " Fix ",
                                 " Fit ",
                                 " Fit ",
                                 " Fit ",
                                 " Fix ",
                                 " Fix ", " Fit (hard cutoff) ",
                                 " Fit ",
                                 " Fit ", 
                                 " Fit (or set to 0) ",
                                 " Fit ", " Fix ",
                                 " Fix ", " Fix ", "Fix"),
                        Source = c( "Mizuomoto/NA ","Mizuomoto/NA "," Imperial ", " NA ",
                                   " Mizuomoto ", " Imperial ",
                                  " Imperial ",
                                 " Imperial ",
                                 " Wu ", 
                                 " NA ",
                                 " NA ",
                                  " NA ",
                                 " NA ","  NA ",
                                 "  NA ",
                                 " Imperial (Wu Wuhan) ",
                                 " NA ", " Wu ",
                                 " NA ", " NA ",
                                 "NA"))
colnames(table_1_df) = c(" Variable Term ", " Definition  of   Variable", " Value ", " Type ", " Source ")
xtab<-xtable(table_1_df, caption=". Parameters. Alternate sources in parentheses.",
             label="Parameter_Variable_Table", align = "c|c|c|c|c|c", autoformat = TRUE)

print(xtab,include.rownames = FALSE, type = "html",
       html.table.attributes = getOption("xtable.html.table.attributes",
                                    "border=3, cellpadding = 10, cellspacing = 10"))

```

# ODE Equations

### Baseline Transmission Rate

\begin{equation}
\text{total_time_infected} = \frac{1}{\gamma} + \frac{1}{\phi_{\text{S}}};
\end{equation}

\begin{equation}
\beta_{\text{0}} = \frac{R_{\text{0}}} {\text{total_time_infected}}
\end{equation}

\begin{equation}
\beta_{\text{1}} = b_{\text{q}} \beta_{\text{0}}
\end{equation}

if t <=  social_distancing_start_time :

\begin{equation}
\beta(t) = \beta_{\text{0}}
\end{equation}

else if social_distancing_start_time < t <= quarantine_start_time:


\begin{equation}
m_q = \frac{\beta_{\text{1}} - \beta_{\text{0}}}{quarantine_start_time - social_distancing_start_time}
\end{equation}

\begin{equation}
\beta(t) = \beta_{\text{0}}+m_q*(t-social_distancing_start_time)
\end{equation}

else if t > quarantine_start_time:
\begin{equation}
\beta(t) = \beta_{\text{1}}
\end{equation}


### Transmission Rate in Pre-symptomatic Compartments

\begin{equation}
\beta_{\text{p}}(t) = b_{\text{p}}\beta(t)
\end{equation}

### Transmission Rate in Asymptomatic Compartments

\begin{equation}
\beta_{\text{a}}(t) = b_{\text{a}}\beta(t)
\end{equation}

### Force of Infection
Note that we use $\lambda_{\text{FOI}}(t) $ to refer to the force of infection in the equations, which corresponds to $\lambda(t)$ in the process model diagram.

\begin{equation}
\lambda_{\text{FOI}}(t)  = \frac{\beta(t)[( I_{S}(t))  + ( I_{F}(t))] + \beta_{\text{a}}(t)[I_A(t)] +  \beta_{\text{p}}(t)[I_P(t)]}{N}
\end{equation}

## Loss Rates


We assume all hospitalized individuals are sampled if the queue is operational, so:

\begin{equation}
\mu_{\text{1}} = 0
\end{equation}

The symptomatic queue, however, does have a loss rate.

\begin{equation}
\mu_{\text{2}} = \gamma
\end{equation}


### Process Model Compartment Equations
\begin{equation}
    \frac{dS}{dt} =  - (\lambda_{\text{FOI}}(t) )  S(t)
\end{equation}

For exposed compartment $E_m$ where $m = 1$:
\begin{equation}
    \frac{dE_1}{dt} =  (\lambda_{\text{FOI}}(t) )  S(t) -\phi_{\text{E}} E_1 (t)
\end{equation}

For exposed compartment $E_m$ where $ 1 < m <= M$:

\begin{equation}
    \frac{dE_m}{dt} =  \phi_{\text{E}} E_{m-1}(t)   -\phi_{\text{E}} E_m (t)
\end{equation}


\begin{equation}
    \frac{dI_{\text{P}}}{dt} =   \phi_{\text{E}} E_M(t) - \phi_{\text{U}}I_{\text{P}}(t)
\end{equation}

\begin{equation}
    \frac{dI_{\text{S}_1}}{dt} =  p_{\text{S}} \phi_{\text{U}}I_{\text{P}}(t) - \phi_{\text{S}}I_{\text{S}_1}(t)
\end{equation}

\begin{equation}
    \frac{dI_{\text{H}}}{dt} =  p_{\text{H_cond_S}}\phi_{\text{S}}I_{\text{S}_1}(t) -h_{\text{V}}I_{\text{H}}(t)
\end{equation}

\begin{equation}
    \frac{dI_{\text{S_2}}}{dt} =  (1-p_{\text{H_cond_S}})\phi_{\text{S}}I_{\text{S}_1}(t) -\gamma I_{\text{S}_2}(t)
\end{equation}

\begin{equation}
    \frac{dI_{\text{A}}}{dt} =  (1 - p_{\text{S}}) \phi_{\text{U}}I_{\text{P}}(t) - \phi_{\text{S}} I_{\text{A}}
\end{equation}

\begin{equation}
    \frac{dR_{\text{A}}}{dt} =  \phi_{\text{S}} I_{\text{A}}
\end{equation}

\begin{equation}
    \frac{dR_{\text{F}}}{dt} =  \gamma I_{\text{S}_2}(t)
\end{equation}

\begin{equation}
\frac{dR_{\text{H}}}{dt} =  h_{\text{V}}I_{\text{H}}(t)
\end{equation}

### Equations for model with demographic stochasticity
Rates in continuous time:
\begin{equation}
\mu_{SE_1} = \lambda_{\text{FOI}}(t)
\end{equation}
For $1<= m < M$
\begin{equation}
\mu_{E_{m} E_{m+1}} =  \phi_{\text{E}}
\end{equation}

\begin{equation}
\mu_{E_{\text{M}} I_{\text{P}}} = \phi_{\text{E}}
\end{equation}

\begin{equation}
\mu_{I_{\text{P}} I_{\text{A}}} = (1-p_{\text{S}}) \phi_{\text{U}}
\end{equation}

\begin{equation}
\mu_{I_{\text{M}} I_{\text{S}_1}} = p_{\text{S}} \phi_{\text{U}}
\end{equation}

\begin{equation}
\mu_{I_{\text{S}_1} I_{\text{H}}} = p_{\text{H_cond_S}}\phi_{\text{S}}
\end{equation}

\begin{equation}
\mu_{I_{\text{S}_1} I_{\text{S}_2}} = (1-p_{\text{H_cond_S}})\phi_{\text{S}}
\end{equation}

\begin{equation}
\mu_{I_{\text{F}} R_{\text{F}}} = \gamma
\end{equation}


\begin{equation}
\mu_{I_{\text{A}} R_{\text{A}}} = \phi_{\text{S}}
\end{equation}

\begin{equation}
\mu_{I_{\text{H}} R_{\text{H}}} = h_{\text{V}}
\end{equation}



## Discretizations


### Discretizations of transitions in susceptible,  asymptomatic infected, hospitalized infected, and flu-like infected individuals

\begin{equation}
  \Delta \tilde N_{S E_1} \sim  Binomial (\tilde S(t),  1 - e^{-\mu_{S E_1} \Delta t })
\end{equation}

For integer $m$ such that  $1 <= m < M$: 

\begin{equation}
  \Delta \tilde N_{E_{m} E_{m+1}} \sim  Binomial (\tilde E_{\text{m}}(t),  1 - e^{-\mu_{E_{m} E_{m + 1}} \Delta t })
\end{equation}

\begin{equation}
  \Delta \tilde N_{E_{\text{M}} I_{\text{P}}} \sim  Binomial (\tilde E_{\text{M}}(t),  1 - e^{-\mu_{E_{\text{M}} I_{\text{P}}} \Delta t })
\end{equation}


\begin{equation}
  \Delta \tilde N_{I_{\text{S_2}} R_{\text{F}}} \sim  Binomial (\tilde I_{\text{S_2}}(t),  1 - e^{-\mu_{I_{\text{S_2}} R_{\text{F}}} \Delta t })
\end{equation}

\begin{equation}
  \Delta \tilde N_{I_{\text{A}} R_{\text{A}}} \sim  Binomial (\tilde I_{\text{A}}(t),  1 - e^{-\mu_{I_{\text{A}} R_{\text{A}}} \Delta t })
\end{equation}


\begin{equation}
  \Delta \tilde N_{I_{\text{H}} R_{\text{H}}} \sim  Binomial (\tilde I_{\text{H}}(t),  1 - e^{-\mu_{I_{\text{H}} R_{\text{H}}} \Delta t })
\end{equation}

#### Eulermultinomial discretization of compartment flows from time $t$ to  time $t + \Delta t$

Several compartments (the $I_{\text{P}}$ and $I_{\text{S}_1}$ compartments in particular) have more than one exit at each time step (presymptomatic individuals can either develop symptomatic or asymptomatic infection, and symptomatic infected individuals either move to the hospital or develop flu-like symptoms). Instead of a binomial transition probability, we thus use the Euler multinomial distribution to model transition events using the function reulermultinom in the R package pomp as described by He and Ionides (D. He, E. L. Ionides, & A. A. King, Plug-and-play inference for disease dynamics: measles in large and small populations as a case study. J. R. Soc. Interface, 7:271–283, 2010. ).

We use the implemention of eulermultinomial transitions in https://raw.githubusercontent.com/kingaa/sbied/master/measles/measles.R as a guide, although we are not using environmental noise here.

We summarize briefly that function here. Given a population $X$, a time interval $\Delta t$, and a set of rates $r_1 ... r_k$, the number of individuals remaining in that class or moving to other classes is multinomially distributed:

\begin{equation}
(X-\sum_{i=1}^k (dx_i), dx_1, …, dx_k) \sim Multinomial(X;p_0,p_1,…,p_k)
\end{equation}

Each probability $p_j$ where $j= 1 ... k$ is calculated as follows:

\begin{equation}
p_j=(1-exp(-\sum_{i = 1}^k (r_i \Delta t))) \frac{r_j}{(\sum_{i= 1}^k (r_i))}
\end{equation}

For our model:

\begin{equation}
(\tilde I_{\text{P}}(t) - \Delta \tilde N_{I_{\text{P}} I_{\text{A}}} - \Delta \tilde N_{I_{\text{P}} I_{\text{S}_1}}, \Delta \tilde N_{I_{\text{P}} I_{\text{A}}}, \Delta \tilde N_{I_{\text{P}} I_{\text{S}_1}}) \sim  reulermultinomial (\tilde I_{\text{P}}(t),   \mu_{I_{\text{P}} I_{\text{A}}}, \mu_{I_{\text{P}} I_{\text{S}_1}}, \Delta t)
\end{equation}

\begin{equation}
(\tilde I_{\text{S}_1}(t) - \Delta \tilde N_{I_{\text{S}_1} I_{\text{S}_2}} - \Delta \tilde N_{I_{\text{S}_1} I_{\text{H}}}, \Delta \tilde N_{I_{\text{S}_1} I_{\text{S}_2}}, \Delta \tilde N_{I_{\text{S}_1} I_{\text{H}}}) \sim  reulermultinomial (\tilde I_{\text{S}_1}(t),   \mu_{I_{\text{S}_1} I_{\text{S}_2}}, \mu_{I_{\text{S}_1} I_{\text{H}}}, \Delta t)
\end{equation}

#### Compartment transitions


\begin{equation}
  \Delta \tilde S =  - \Delta \tilde N_{S E_{1}}
\end{equation}


\begin{equation}
  \Delta \tilde E_1 = \Delta \tilde N_{S E_1} - \Delta \tilde N_{E_1 E_{2}}
\end{equation}

For integer $m$ in $1 < m < M$:

\begin{equation}
  \Delta \tilde E_m = \Delta \tilde N_{E_{m-1} E_{m}} - \Delta \tilde N_{E_{m} E_{m+1}}
\end{equation}

\begin{equation}
  \Delta \tilde E_M = \Delta \tilde N_{E_{M-1} E_{M}} - N_{E_{M} I_{\text{P}}}
\end{equation}

\begin{equation}
  \Delta \tilde I_{\text{P}} = \Delta N_{E_{M} I_{\text{P}}} - \Delta \tilde N_{I_{\text{P}} I_{\text{S_1}}} - \Delta \tilde N_{I_{\text{P}} I_{\text{A}}}
\end{equation}

\begin{equation}
  \Delta \tilde I_{\text{S}_1} =  \Delta \tilde N_{I_{\text{P}} I_{\text{S_1}}} - \Delta \tilde N_{I_{\text{S}_1} I_{\text{S}_2}} - \Delta \tilde N_{I_{\text{S}_1} I_{\text{H}}}
\end{equation}

\begin{equation}
  \Delta \tilde I_{\text{S}_2} =  \Delta \tilde N_{I_{\text{S}_1} I_{\text{S}_2}} - \Delta \tilde N_{I_{\text{S}_2} R_{\text{F}}}
\end{equation}

\begin{equation}
  \Delta \tilde I_{\text{H}} =  \Delta \tilde N_{I_{\text{S}} I_{\text{H}}} - \Delta \tilde N_{I_{\text{H}} R_{\text{H}}}
\end{equation}


\begin{equation}
  \Delta \tilde I_{\text{A}} =  \Delta \tilde N_{I_{\text{P}} I_{\text{A}}} - \Delta \tilde N_{I_{\text{A}} R_{\text{A}}}
\end{equation}

\begin{equation}
  \Delta \tilde R_{\text{A}} =  \Delta \tilde N_{I_{\text{A}} R_{\text{A}}}
\end{equation}

\begin{equation}
  \Delta \tilde R_{\text{F}} =  \Delta \tilde N_{I_{\text{S}_2} R_{\text{F}}}
\end{equation}

\begin{equation}
  \Delta \tilde R_{\text{H}} =  \Delta \tilde N_{I_{\text{H}} R_{\text{H}}}
\end{equation}

\begin{equation}
  \Delta \tilde C_{\text{Q1}} = \Delta \tilde N_{I_{\text{S}_1} I_{\text{H}}}
\end{equation}

\begin{equation}
  \Delta \tilde C_{\text{QNC}} = G(w,y)
\end{equation}

\begin{equation}
  \Delta \tilde C_{\text{Q3}} = \Delta \tilde N_{I_{\text{S}_1} I_{\text{S}_2}}
\end{equation}




### Non-Flu Case Equations
Let $G(w,y)$ be the number of non-COVID respiratory syndrome cases presenting in the ED of hosptials in NYC in week $w$ of year $y$.

\begin{equation}
G(w,y) = g_0 + g_{\text{F}} F(w,y) + \beta_{\text{w}^3}w^3 + \beta_{\text{w}^2}w^2 + \beta_{\text{w}^1}w + \beta_{\text{w}^0} + \epsilon 
\end{equation}


where $F(w,y)$ is the number of confirmed flu cases in NYC, and:

\begin{equation}
\epsilon \sim rnorm(0,\sigma_{\epsilon})
\end{equation}


We multiply $G(w,y)$ by the probabilty that an individual who shows up to the emergency deparmtnet with respiratory symptoms is severe enough to merit testing for COVID-19. Since we do not know this esimate, we use the ratio  of indiviudals aged 65 or older who were hosptialized for flu (279,384) to the number of indivduasl aged 65 or older who had a medical visit for flu during the 2018-2019 flu season (1,721,007). This value was found here in "Table 1: Estimated influenza disease burden, by age group — United States, 2018-2019 influenza season":
https://www.cdc.gov/flu/about/burden/2018-2019.html

The value we use for this scaling is 0.162.

\begin{equation}
G(w,y) = 0.162 g_0 + g_{\text{F}} F(w,y) + \beta_{\text{w}^3}w^3 + \beta_{\text{w}^2}w^2 + \beta_{\text{w}^1}w + \beta_{\text{w}^0} + \epsilon 
\end{equation}

# Load data and covariates for model
### Define start date
```{r}
true_start_date = as.Date("2020-03-01")
t0 = 0
start_of_year = as.Date("2020-01-01")
first_saturday_in_year = as.Date("2020-01-04")
```

### Load COVID testing data
```{r}
NYC_full_testing_data = read.csv("../Generated_Data/NYC_full_testing_data.csv")
head(NYC_full_testing_data)
Observed_data = NYC_full_testing_data %>%
  mutate(times = as.numeric(as.Date(Date) - true_start_date)) %>%
  select(Y = New_Positives, times,
         obs_prop_positive = Prop_Pos)

Observed_data = Observed_data %>%
  filter(times < 90)
head(Observed_data)
write.csv(Observed_data,
          file = paste0("../Generated_Data/observed_data_", model_name, ".csv"),
          row.names = FALSE)



 
```

### Load in testing data covariates
```{r}
 testing_data = NYC_full_testing_data %>%
   select(L = Total_Number_of_Tests_Performed, Date)

orig_testing_df = testing_data %>%
    mutate(times = as.numeric(as.Date(Date) - true_start_date)) %>%
  dplyr::select(times,L_orig = L)



   
 testing_data = testing_data %>%
   mutate(Adj_Date = as.Date(Date) -2) %>%
   mutate(times = as.numeric(Adj_Date - true_start_date)) %>%
   mutate(Week = (ceiling(as.numeric(Adj_Date - first_saturday_in_year)/7)) + 1,
          Year = year(Adj_Date)) %>%
   dplyr::select(times,L_advanced_2_days = L, Week, Year)
 
 testing_data = join(testing_data, orig_testing_df)

 # Assign 0 to start date orig testing
 testing_data$L_orig[1] = 0
 testing_data$L_orig[2] = 0
 
```


### Load in Flu data
Load in 

```{r}
NYC_region_confirmed_flucases_NY_state_2020 = read.csv(
  file = "../Generated_Data/NYC_region_confirmed_flucases_NY_state_2020.csv")

NYC_flu_data = NYC_region_confirmed_flucases_NY_state_2020 %>%
  dplyr::select(Week = Week, Year = Year, F_w_y = Confirmed_Flu_Cases)

```

Adjust-assume that 0 cases were reported in later weeks (when surveillance was halted).
```{r}
flu_data_missing_weeks = data.frame(Week = seq(from = max(NYC_flu_data$Week) +1,
                                                to = max(testing_data$Week) +1),
                                    Year = 2020,
                                    F_w_y = 0)
NYC_flu_data_adj = rbind(NYC_flu_data,
                         flu_data_missing_weeks)

```

## Assemble covariate data frame
```{r}
covariate_df = join(testing_data,
                    NYC_flu_data_adj,
                    by = c("Week", "Year"))

head(covariate_df)
write.csv(covariate_df,
          file = paste0("../Generated_Data/covariate_data_", model_name, ".csv"),
          row.names = FALSE)
```

### Create covariate table
```{r covar}
# ---- covar ----
covar=covariate_table(
  time=covariate_df$times,
  L_advanced_2_days=covariate_df$L_advanced_2_days,
  L_orig = covariate_df$L_orig,
  F_w_y = covariate_df$F_w_y,
  w = covariate_df$Week,
  y = covariate_df$Year,
  times="time"
)
```

```{r}

fitted_NC_model_params = read.csv(
          file = "../Generated_Data/fitted_NC_model_params.csv")

g_F = fitted_NC_model_params$g_F/7 
g_0 = fitted_NC_model_params$g_0/7 

beta_w_3 = fitted_NC_model_params$Beta_w_3/7

beta_w_2 = fitted_NC_model_params$Beta_w_2/7
beta_w_1 = fitted_NC_model_params$Beta_w_1/7
beta_w_0 = fitted_NC_model_params$Beta_w_0/7
sigma_epsilon = fitted_NC_model_params$sigma_epsilon/7
g_F
g_0
beta_w_3
beta_w_2
beta_w_1
beta_w_0
sigma_epsilon

fitted_NC_model_params = data.frame(g_F = g_F, g_0 =g_0, beta_w_2 = beta_w_2,
                                    beta_w_1 = beta_w_1,
                                    beta_w_0 = beta_w_0,
                                    sigma_epsilon = sigma_epsilon)


```
 

 

# Motivating Literature and Justification of Compartment Numbers
We follow the results of Mizuomoto et al (Eurosurveilance 2020) from the Diamond Princess Cruise-ship outbreak.

https://www.eurosurveillance.org/content/10.2807/1560-7917.ES.2020.25.10.2000180#html_fulltext


In their model, they assume that individuals experience an incubation period between the time of infection and the onset of symptoms which is given by a Weibull distribution with mean 6.4 days and standard deviation of 2.3 days (they cite Backer et al for justification).




They assume that some proportion $p$ of those infections never become symptomatic (these are the asymptomatic infections).

We will build on their model here. We will use a Gamma distribution to approximate the weibull. This gamma distribution will be approximated using a chain of exponentially distributed compartments. 

A key question that is important for model structure is whether individuals can transmit during the period when they are asymptomatic. Some models focus on pre-symptomatic transmission, assuming that are all individuals  who are infected with COVID initially have a period of pre-symptomatic transmission. Some individuals never go on to develop symptoms. 

In these models, this pre-symptomatic transmission can be modeled by allowing individuals to transmit at a reduced rate during the later stages of the incubation period essentially partitioning what Backer et al consider the incubation period into two compartments: a latent period where no transmission occurs and a pre-symptomatic transmission period where transmission can occur.

Other models view asymptomatic transmission as a bifurcation-that is, some individuals are able to transmit asymptomatically while others develop symptoms.

We combine both approaches in our model. 

We assume following Backer et al that the time between infection and the onset of symptoms follows a gamma distribution with mean 6.5 days and variance 2.6 days. This is approximated using a chain of 6 compartments with an exponentially distributed average time of 13/12 days spent in each compartment. However,  we then assume that during the first 3 compartments, no infected individuals can transmit (these are the Exposed Compartments $E_m$). For the fraction $p_S$ of individuals leaving the last exposed compartment who will develop symptoms, we treat the remaining 3 compartments  as the pre-symptomatic transmission period $I_{P_q}$.

Asymptomatic individuals (fraction $1-p_S$ of individuals leaving the last exposed compartment) instead start transmitting asymptomatically for an average of 5 days ($\phi_S = 1/5$). We assume here that asymptomatic individuals transmit for the same amount of time as the duration between the onset of symptoms and the time of sampling in symptomatic individuals. 

More info on asymptomatic transmission:
https://wwwnc.cdc.gov/eid/article/26/7/20-1595_article
 
 Nishiura et al obtain a different estimate of the incubation period-namely an incubation period of 5.0 days and a serial interval of 4 days, which would suggest that (in our model) inidivduals spend about 4 days in the exposed class and 1 day in the pre-symptomatic class.
https://www-sciencedirect-com.proxy.uchicago.edu/science/article/pii/S1201971220301193


In their paper, median serial interval of the best-fit Weibull distribution model was estimated at 4.6 days (95% CI: 3.5, 5.9) with a mean and SD of 4.8 days (95% CrI: 3.8, 6.1) and 2.3 days (95% CrI: 1.6, 3.5), 

Lognormal:
. "The median serial interval was estimated at 4.0 days (95% credible interval [CrI]: 3.1, 4.9) while the mean and standard deviation (SD) of the serial interval were estimated at 4.7 days (95% CrI: 3.7, 6.0) and 2.9 days (95% CrI: 1.9, 4.9), respectively. Without truncation, the model using the lognormal distribution was also the best-fit model (WAIC = 128.0) with the median serial interval estimated at 3.9 days (95% CrI: 3.1, 4.8)."






We use Lauer et al here:
https://www.acpjournals.org/doi/10.7326/M20-0504#t4-M200504


### Determining number of total compartments V

Let us then parameter the distribution assuming that we know $\mu_V$ and $V$ (the number of Exposed compartments). 

Writing the $\Gamma$ distribution in the form of shape $V$ and rate $\lambda_V$ we have:

\begin{equation}
 \Gamma(V, \lambda_V) \sim \sum_{m = 1}^V exp(\lambda_V)
\end{equation}

In the case of Lauer et al, $V = 5.807$, and $\lambda_V = 1/ 0.948$ or $\lambda_V = 1.054852$

Now re-writing the $\Gamma$ distribution in terms of mean and variance we have:

\begin{equation}
 \Gamma(\frac{V}{\lambda_V}, \frac{V}{\lambda_V^2}) \sim \sum_{m = 1}^V exp(\lambda_V)
\end{equation}

Solve for $\lambda_V$:

\begin{equation}
\mu_E = \frac{V}{\lambda_V}
\end{equation}

\begin{equation}
\lambda_V  = \frac{V}{\mu_E}
\end{equation}

Plugging in, we obtain:

\begin{equation}
\mu_E = \frac{5.807}{1.054852}
\end{equation}

\begin{equation}
\mu_E = 5.505038
\end{equation}



Solve for the variance of the resulting $Gamma$ distributed duration of infection:

\begin{equation}
\sigma^2_E = \frac{V}{\lambda_V^2}
\end{equation}

\begin{equation}
\sigma^2_E = \frac{V}{(\frac{V}{\mu_E})^2}
\end{equation}

\begin{equation}
\sigma^2_E = \frac{V}{\frac{V^2}{\mu_E^2}}
\end{equation}

\begin{equation}
\sigma^2_E = \frac{\mu_E^2 V}{V^2}
\end{equation}

\begin{equation}
\sigma^2_E = \frac{\mu_E^2}{V}
\end{equation}

Plugging in 
\begin{equation}
\sigma^2_E = \frac{5.505038^2}{5.807}
\end{equation}

\begin{equation}
\sigma^2_E = 5.218778
\end{equation}

\begin{equation}
\sigma_E = 2.284464
\end{equation}



Note that for a given mean, increasing the number of compartments decreases the variance.

We will use $V=6$, corresponding to 6 compartments, but set $\lambda_V $ to obtain the observed mean of  5.505038 days. 

 \begin{equation}
\lambda_V  = \frac{V}{\mu_E}
\end{equation}

\begin{equation}
\lambda_V  = \frac{6}{5.505038}
\end{equation}


\begin{equation}
\lambda_V  = 1.09
\end{equation}

The actual standard deviation of the gamma distribution is 
\begin{equation}
\sigma^2_E = \frac{\mu_E^2}{V}
\end{equation}

\begin{equation}
\sigma^2_E = \frac{5.505038^2}{6}
\end{equation}

\begin{equation}
\sigma^2_E = 5.050907
\end{equation}

\begin{equation}
\sigma_E = 2.25
\end{equation}

Our approximation of the incubation period is equivalent to a gamma distribution with mean 5.5 days and standard deviation 2.25, compared to a gamma distribution with mean 5.5 and standard deviation 2.28 from Lauer et al. 

For ease of notation, we will use $\phi_E$ to refer to $\lambda_V$ to avoid confusion with the force of infection. 

We are using $V= 6$ compartments with $\phi_E = 1.09$, which means that each individual spends about $0.92$ days in each compartment (around 1 day) although of course this is an approximation. 


### Estimating the number of  compartments with pre-symptomatic transmission
A model fit to COVID day in Hong Kong estimated the length of the pre-symptomatic transmission period  to be 3.49 days, although with a wide posterior (Yuan et al)  (Posterior distribution 0.48-5.80). 
Source (https://doi.org/10.1101/2020.05.03.20089482)

In terms of clinical data, a study of a retirement home in the state of Washington found evidence of pre-symptomatic transmission.

Source:

Kimball A, Hatfield KM, Arons M, et al. Asymptomatic and Presymptomatic SARS-CoV-2 Infections in Residents of a Long-Term Care Skilled Nursing Facility — King County, Washington, March 2020. MMWR Morb Mortal Wkly Rep 2020;69:377–381. DOI: http://dx.doi.org/10.15585/mmwr.mm6913e1


Patients were sampled twice. Of 13 patients who were asymptomatic during the first testing, 10 became symptomatic within 1 week. Asymptomatic patients had low C_t values, suggesting potential for transmission even though they were asymptomatic.  

A second study from Singapore looking at travelers from China found indications of asymptomatic transmission.

Source:
Wei WE, Li Z, Chiew CJ, Yong SE, Toh MP, Lee VJ. Presymptomatic Transmission of SARS-CoV-2 — Singapore, January 23–March 16, 2020. MMWR Morb Mortal Wkly Rep 2020;69:411–415. DOI: http://dx.doi.org/10.15585/mmwr.mm6914e1

Last study (cluster in Zhoushan)-evidence of asymptomatic transmission, not necessarily pre-symptomatic. 

Source:
Tong Z, Tang A, Li K, Li P, Wang H, Yi J, et al. Potential Presymptomatic Transmission of SARS-CoV-2, Zhejiang Province, China, 2020. Emerg Infect Dis. 2020;26(5):1052-1054. https://dx.doi.org/10.3201/eid2605.200198

### Our model's treatment of the pre-symptomatic period
The pre-symptomatic transmission chain $I_{P}$ has 1 compartments ($U=1$). The average duration that they spend in those compartments will be around 0.92 days in line with Nishiura et al https://www-sciencedirect-com.proxy.uchicago.edu/science/article/pii/S1201971220301193
. The time spent across the $I_P$ compartment will be exponentially disrtributed with mean $0.92$ days. Thus, in terms of the total incubation period of 5 compartments, 4 will be represented as Exposed compartments and 1 as an Infected Presymptomatic Compartment. 
```{r}
low_025 = qgamma(p = 0.025, shape = 3, rate= 12/13)
upper_975 = qgamma(p = 0.975, shape = 3, rate= 12/13)
low_025
upper_975

```


```{r}

nishiura_median_serial_interval = 3.9
dist_comp = data.frame(lauer_gamma_dist = rgamma(n = 1000, shape = 5.807,
                          scale = 0.948))
p = ggplot(data = dist_comp,
           aes(x = lauer_gamma_dist)) +
  geom_density()
p

backer_gamma_mean = 6.5
backer_gamma_sd = 2.6

backer_gamma_shape =backer_gamma_mean^2/backer_gamma_sd^2
backer_gamma_rate = backer_gamma_shape/backer_gamma_mean

dist_comp$backer_gamma_dist = rgamma(n = 1000, shape = backer_gamma_shape,
                                     rate = backer_gamma_rate)

dist_comp_melt = melt(dist_comp)

p = ggplot(data = dist_comp_melt,
           aes(x = value, color = variable)) +
  geom_density() + geom_vline(xintercept = median(dist_comp$backer_gamma_dist), color = 'blue', show.legend = TRUE, name = "backer_median") + geom_vline(xintercept = median(dist_comp$lauer_gamma_dist), color = 'red', show.legend = TRUE, name = "lauer_median") 
  
p

lauer_approx_comp = dist_comp %>%
  dplyr::select(lauer_gamma_dist)


lauer_approx_comp$total_time_in_E_and_I_P_chain = rgamma(n = 1000, shape = 6,
                                     rate = 1.09)

lauer_approx_comp_melt = melt(lauer_approx_comp)
p = ggplot(data = lauer_approx_comp_melt,
           aes(x = value, color = variable)) +
  geom_density() +
  geom_vline(xintercept = median(lauer_approx_comp$total_time_in_E_and_I_P_chain), color = 'blue', show.legend = TRUE, name = "total_time_in_E_and_I_P_median") + geom_vline(xintercept = median(lauer_approx_comp$lauer_gamma_dist), color = 'red', show.legend = TRUE, name = "lauer_median") 
  
p

model_chain_comp_df = lauer_approx_comp %>%
  dplyr::select(total_time_in_E_and_I_P_chain)
model_chain_comp_df$total_time_in_E_chain = rgamma(n = 1000, shape = 5,
                                     rate = 1.09)

model_comp_melt = melt(model_chain_comp_df)


p = ggplot(data = model_comp_melt,
           aes(x = value, color = variable)) +
  geom_density() +
  geom_vline(xintercept = median(model_chain_comp_df$total_time_in_E_and_I_P_chain), color = 'red', show.legend = TRUE, name = "total_time_in_E_and_I_P_median") + geom_vline(xintercept = median(model_chain_comp_df$total_time_in_E_chain), color = 'blue', show.legend = TRUE, name = "time_in_E_chain") + geom_vline(xintercept = nishiura_median_serial_interval, color = 'darkgreen', show.legend = TRUE, name = "nishiura_median_serial_interval")
p


median(dist_comp$lauer_gamma_dist)
median(dist_comp$backer_gamma_dist)


gamma_vs_exp_comp = model_chain_comp_df %>%
  dplyr::select(total_time_in_E_chain)

gamma_vs_exp_comp$exp_approx = rexp(n = 1000,rate = 1/(5*(1/1.09)))
gamma_vs_exp_comp_melt = melt(gamma_vs_exp_comp)
p = ggplot(data = gamma_vs_exp_comp_melt,
           aes(x = value, color = variable)) +
  geom_density() +
  geom_vline(xintercept = median(gamma_vs_exp_comp$exp_approx), color = 'blue', show.legend = TRUE, name = "total_time_in_E_median") + geom_vline(xintercept = median(gamma_vs_exp_comp$total_time_in_E_chain), color = 'red', show.legend = TRUE, name = "E_approx_median") 
p

```




# Capacity Calculations
We have the line
\begin{equation}
L_{\text{int}} = \text{nearbyint}(L)
\end{equation}
The variable $L_{\text{int}}$ is used later in the code instead of $L$.
This line of code is where we will decide which covariate to feed in as the testing capacity.

Note that we advance the testing capacity by 2 days from the observed value, since the testing capacity on day $t$ will correspond to the number of tests conducted on day $t+2$. 

\begin{equation}
L_{\text{int}} = \text{nearbyint}(L_{\text{total_pos_advnaced_2_days}})
\end{equation}

## Queue 1 
### Initial states

\begin{equation}
\text{neg_samples}_{Q1}(t) = 0
\end{equation}


### Add new cases to Q1
\begin{equation}
 Q_{1_1}(t) = Q_{1_1}(t) + C_{Q1}(t)
\end{equation}

### Add new cases to Q_NC
\begin{equation}
 Q_{NC_1}(t) = Q_{NC_1}(t) + C_{QNC}(t)
\end{equation}


### Determine number of samples that will be tested from the backlog of Queue 1

First, deal with backlog
Calculate total backlog for Q1 and QNC
\begin{equation}
\text{total_samples_for_PCR_Testing_backlog_always_test} = \\text{Backlog_Queue_1}(t), \text{Backlog_Queue_{\text{NC}}}(t)
\end{equation}

If Backlog is greater than testing capacity (i.e. $\text{total_samples_for_PCR_Testing_backlog_always_test} > L_{\text{int}}(t)$:


 
\begin{equation}
\text{total_samples_for_PCR_Testing_backlog}_{text{Q1}} \sim hypergeom(\text{Backlog_Queue_1}(t), \text{Backlog_Queue_{\text{NC}}}(t),
L_{\text{int}}(t))
\end{equation}


\begin{equation}
\text{total_samples_for_PCR_Testing_backlog}_{text{QNC}} = L_{\text{int}}(t)) -  \text{total_samples_for_PCR_Testing_backlog}_{text{Q1}}
\end{equation}


\begin{equation}
\text{Backlog_Queue_1}(t) = \text{Backlog_Queue_1}(t) - \text{total_samples_for_PCR_Testing_backlog}_{text{Q1}}
\end{equation}

\begin{equation}
\text{Backlog_Queue_NC}(t) = \text{Backlog_Queue_NC}(t) - \text{total_samples_for_PCR_Testing_backlog}_{text{QNC}}
\end{equation}


\begin{equation}
L_1(t) = 0
\end{equation}



Else (if the testing capcity is greater than the backlog):

\begin{equation}
\text{total_samples_for_PCR_Testing_backlog}_{\text{Q1}} = \text{Backlog_Queue_1}(t)
\end{equation}

\begin{equation}
\text{total_samples_for_PCR_Testing_backlog}_{\text{QNC}} = \text{Backlog_Queue_NC}(t)
\end{equation}




\begin{equation}
L_1(t) = L_{\text{int}}(t) - \text{total_samples_for_PCR_Testing_backlog}_{\text{Q1}} - 
\text{total_samples_for_PCR_Testing_backlog}_{\text{QNC}}
\end{equation}

\begin{equation}
\text{Backlog_Queue_1}(t) = 0
\end{equation}

\begin{equation}
\text{Backlog_Queue_NC}(t) = 0
\end{equation}

### Simulate PCR for backlogged cases in Q1

\begin{equation}
Y_{Q1_{\text{backlog}}}(t) =  \sim Binomial(\text{total_samples_for_PCR_Testing_backlog_lag_2}_{\text{Q1}}, \text{PCR_sens})
\end{equation}

\begin{equation}
Y_{QNC_{\text{backlog}}}(t) =  \text{total_samples_for_PCR_Testing_backlog_lag_2}_{\text{QNC}}
\end{equation}


\begin{equation}
\text{neg_samples_Q1}_{Q1}(t) = \text{neg_samples}_{Q1}(t) + \text{total_samples_for_PCR_Testing_backlog_lag_2}_{\text{Q1}} - Y_{Q1}(t)
\end{equation}

### Update PCR testing compartments for Q1 backlog

\begin{equation}
\text{total_samples_for_PCR_Testing_backlog_lag_2}_{\text{Q1}} =
\text{total_samples_for_PCR_Testing_backlog_lag_1}_{\text{Q1}}
\end{equation}

\begin{equation}
\text{total_samples_for_PCR_Testing_backlog_lag_2}_{\text{QNC}} =
\text{total_samples_for_PCR_Testing_backlog_lag_1}_{\text{QNC}}
\end{equation}


\begin{equation}
\text{total_samples_for_PCR_Testing_backlog_lag_1}_{\text{Q1}} =
\text{total_samples_for_PCR_Testing_backlog}_{\text{Q1}}
\end{equation}


\begin{equation}
\text{total_samples_for_PCR_Testing_backlog_lag_1}_{\text{QNC}} =
\text{total_samples_for_PCR_Testing_backlog}_{\text{QNC}}
\end{equation}

### Determine number of samples that will be tested from each sampling cohort of Queue 1

 Loop through each cohort in Queue 1 $Q_{1_v}$ (and Queue NC $Q_{NC_v}$)
 starting with the oldest ($Q_{1_V}$/$Q_{NC_V}$) and ending with the most recent
 $Q_{1_1}$/$Q_{NC_1}$.
 
 If L_1 is smaller than cohort
(i.e. $ L_1(t) < (Q_{1_v}(t) + Q_{NC_v}(t))$  :
 

\begin{equation}
\text{total_samples_for_PCR_Testing}_{\text{Q1}_v}(t) \sim hypergeom(Q_{1_v}(t), Q_{NC_v}(t),
 L_1(t))
\end{equation}

\begin{equation}
\text{total_samples_for_PCR_Testing}_{\text{QNC}_v}(t) = L_1(t) -  \text{total_samples_for_PCR_Testing}_{\text{Q1}_v}(t)
\end{equation}


\begin{equation}
Q_{1_m}(t) = Q_{1_v}(t) - \text{total_samples_for_PCR_Testing}_{\text{Q1}_v}(t)
\end{equation}

\begin{equation}
Q_{NC_m}(t) = Q_{NC_v}(t) - \text{total_samples_for_PCR_Testing}_{\text{QNC}_v}(t)
\end{equation}


\begin{equation}
 L_1(t) = 0
\end{equation}

 Else

\begin{equation}
\text{total_samples_for_PCR_Testing}_{\text{Q1}_v}(t) =   Q_{1_v}(t)
\end{equation}

\begin{equation}
\text{total_samples_for_PCR_Testing}_{\text{QNC}_v}(t) =   Q_{NC_v}(t)
\end{equation}

\begin{equation}
Q_{1_v}(t) = 0
\end{equation}

\begin{equation}
Q_{NC_v}(t) = 0
\end{equation}

\begin{equation}
 L_1(t) =  L_1(t) - \text{total_samples_for_PCR_Testing}_{\text{Q1}_v}(t) - \text{total_samples_for_PCR_Testing}_{\text{QNC}_v}(t)
\end{equation}

### Simulate PCR Testing on each sampling cohort in Q1
Loop over all cohorts $v$ from $1:V$

\begin{equation}
Y_{Q1_{v}}(t) =  \sim Binomial(\text{total_samples_for_PCR_Testing_lag_2}_{\text{Q1}_v}(t), \text{PCR_sens})
\end{equation}

\begin{equation}
Y_{QNC_{v}}(t) =  (\text{total_samples_for_PCR_Testing_lag_2}_{\text{QNC}_v}(t)
\end{equation}


\begin{equation}
\text{neg_samples_Q1}_{Q1}(t) = \text{neg_samples_Q1}_{Q1}(t) + \text{total_samples_for_PCR_Testing_lag_2}_{\text{Q1}_v}(t) - Y_{Q1_{v}}(t) 
\end{equation}

### Update lags for total samples for PCR testing for Q1
\begin{equation}
\text{total_samples_for_PCR_Testing_lag_2}_{\text{Q1}_v}(t) =  \text{total_samples_for_PCR_Testing_lag_1}_{\text{Q1}_v}(t)
\end{equation}

\begin{equation}
\text{total_samples_for_PCR_Testing_lag_2}_{\text{QNC}_v}(t) =  \text{total_samples_for_PCR_Testing_lag_1}_{\text{QNC}_v}(t)
\end{equation}



\begin{equation}
\text{total_samples_for_PCR_Testing_lag_1}_{\text{Q1}_v}(t) =  \text{total_samples_for_PCR_Testing}_{\text{Q1}_v}(t)
\end{equation}

\begin{equation}
\text{total_samples_for_PCR_Testing_lag_1}_{\text{QNC}_v}(t) =  \text{total_samples_for_PCR_Testing}_{\text{QNC}_v}(t)
\end{equation}


### Update positive case matrix ($P_{\text{Q1}}$)
For all daily sampling cohorts $v$ within the last 14 days:

\begin{equation}
P_{\text{Q1}_v}(t) = P_{\text{Q1}_v}(t) + Y_{Q1_{v}}(t) 
\end{equation}

### Re-testing (Add lagged positive samples from Queue 1 into Queue 2)
The state variable $\text{First_re_test}_{\text{Q1}}(t)$ are samples that were first re-sampled during the previous day. They now need to be re-sampled a second time.

\begin{equation}
\text{Second_re_test}_{\text{Q1}}(t) = \text{First_re_test}_{\text{Q1}}(t) 
\end{equation}

\begin{equation}
C_{Q2}(t) = \text{Second_re_test}_{\text{Q1}}(t)
\end{equation}

Let $V$ be the oldest cohort stored ($V = 13$).
This cohort will have their first re-sampling conducted. 




\begin{equation}
\text{First_re_test}_{\text{Q1}}(t) = P_{\text{Q1}_V}(t) 
\end{equation}

\begin{equation}
C_{Q2}(t) = C_{Q2}(t) + \text{First_re_test}_{\text{Q1}}(t)
\end{equation}

### Increment Q1 Sampling Cohorts

For $v$ in $2:V$:

\begin{equation}
P_{\text{Q1}_{\text{old}_{v}}} = P_{\text{Q1}_v}(t)
\end{equation}

\begin{equation}
P_{\text{Q1}_v}(t) = P_{\text{Q1}_{\text{old}_{v-1}}}
\end{equation}

For the case when $v=1$:

\begin{equation}
P_{\text{Q1}_1}(t) = 0
\end{equation}

For integer $v$ in $1:V$:

\begin{equation}
Q_{1_{\text{old}_v}} = Q_{1_v}(t)
\end{equation}

\begin{equation}
Q_{NC_{\text{old}_v}} = Q_{NC_v}(t)
\end{equation}


For the case where $v = V$

\begin{equation}
\text{Backlog_Queue_1}(t) = \text{Backlog_Queue_1}(t) + Q_{1_{\text{old}_V}}
\end{equation}

\begin{equation}
\text{Backlog_Queue_NC}(t) = \text{Backlog_Queue_NC}(t) + Q_{NC_{\text{old}_V}}
\end{equation}


For integer $v$ in $v >1$ and $v <= V$:

\begin{equation}
 Q_{1_v}(t) = Q_{1_{\text{old}_{v-1}}} 
\end{equation}

\begin{equation}
 Q_{NC_v}(t) = Q_{NC_{\text{old}_{v-1}}} 
\end{equation}


For the case when $v=1$:

\begin{equation}
 Q_{1_1}(t) = 0
\end{equation}

\begin{equation}
 Q_{NC_1}(t) = 0
\end{equation}



## Queue 2

### Add new cases to queue

\begin{equation}
 Q_{2}(t) = Q_{2}(t) + C_{Q2}(t)
\end{equation}

### Determine number of samples that will be tested from Queue 2

Recall that $L_2$ is the testing capacity available at the end of Queue 2.

\begin{equation}
L_2(t) = L_1(t)
\end{equation}

If $Q_{2}(t) > L_2(t)$:

 
\begin{equation}
\text{total_samples_for_PCR_Testing}_{\text{Q2}}(t) =   L_2(t)
\end{equation}

\begin{equation}
Q_{2}(t) = Q_{2}(t) - L_2(t)
\end{equation}

\begin{equation}
 L_2(t) = 0
\end{equation}

 Else:

\begin{equation}
\text{total_samples_for_PCR_Testing}_{\text{Q2}}(t) =   Q_{2}(t)
\end{equation}

\begin{equation}
Q_{2}(t) = 0
\end{equation}

\begin{equation}
 L_2(t) =  L_2(t) - Q_{2}(t)
\end{equation}

Recall that we do not keep track of the results of the PCR testing in Queue 2, as it will not impact the count of reported cases. We are also not worried about lags here. 



## Queue 3 
### Initial states

\begin{equation}
\text{neg_samples}_{Q3}(t) = 0
\end{equation}

\begin{equation}
L_3(t) = L_2(t)
\end{equation}

### Take into account loss rate due to recovery
Here in Queue 3 (unlike in Queue 1) we do take into account the probability that an individual has already recovered before their samples can be tested. Biologically, of course, we assume that individuals are only sampled once testing capacity permits. We ignore the lag between sampling time and testing capacity in determining that threshold point.

For eaach cohort $k$:

\begin{equation}
\text{Q_3_loss}_k = \sim \text{Binomial}(Q_{3_k}(t), 1 - e^{-\mu_3*dt})
\end{equation}

\begin{equation}
Q_{3_k}(t) = Q_{3_k}(t) - \text{Q_3_loss}_k 
\end{equation}


### Add new cases to Q3
\begin{equation}
 Q_{3_1}(t) = Q_{3_1}(t) + C_{Q3}(t)
\end{equation}


### Determine number of samples that will be tested from the backlog of Queue 3

First, deal with backlog

If Backlog is greater than testing capacity:
 
\begin{equation}
\text{total_samples_for_PCR_Testing_backlog}_{text{Q3}} = L_3(t)
\end{equation}

\begin{equation}
\text{Backlog_Queue_3}(t) = \text{Backlog_Queue_3}(t) - L_3(t)
\end{equation}

\begin{equation}
L_3(t) = 0
\end{equation}



Else (if the testing capcity is greater than the backlog):

\begin{equation}
\text{total_samples_for_PCR_Testing_backlog}_{text{Q3}} = \text{Backlog_Queue_3}(t)
\end{equation}



\begin{equation}
L_3(t) = L_3(t) - \text{total_samples_for_PCR_Testing_backlog}_{text{Q5}}
\end{equation}

\begin{equation}
\text{Backlog_Queue_3}(t) = 0
\end{equation}

### Simulate PCR for backlogged cases in Q3

\begin{equation}
Y_{Q3_{\text{backlog}}}(t) =  \sim Binomial(\text{total_samples_for_PCR_Testing_backlog_lag_2}_{text{Q3}}, \text{PCR_sens})
\end{equation}

\begin{equation}
\text{neg_samples}_{Q3}(t) = \text{neg_samples}_{Q3}(t) + \text{total_samples_for_PCR_Testing_backlog_lag_2}_{text{Q3}} - Y_{Q3}(t)
\end{equation}

### Update PCR testing compartments for Q3 backlog

\begin{equation}
\text{total_samples_for_PCR_Testing_backlog_lag_2}_{text{Q3}} =
\text{total_samples_for_PCR_Testing_backlog_lag_1}_{text{Q3}}
\end{equation}

\begin{equation}
\text{total_samples_for_PCR_Testing_backlog_lag_1}_{text{Q3}} =
\text{total_samples_for_PCR_Testing_backlog}_{text{Q3}}
\end{equation}

### Determine number of samples that will be tested from each sampling cohort of Queue 3

 Loop through each cohort in Queue 3 $Q_{3_k}$ 
 starting with the oldest ($Q_{3_K}$) and ending with the most recent
 $Q_{3_1}$.
 
 If L_3 is smaller than cohort
(i.e. $ L_3(t) < Q_{3_k}(t)$  :
 
\begin{equation}
\text{total_samples_for_PCR_Testing}_{\text{Q3}_k}(t) =   L_3(t)
\end{equation}

\begin{equation}
Q_{3_k}(t) = Q_{3_k}(t) - L_3(t)
\end{equation}

\begin{equation}
 L_3(t) = 0
\end{equation}

 Else

\begin{equation}
\text{total_samples_for_PCR_Testing}_{\text{Q3}_k}(t) =   Q_{3_k}(t)
\end{equation}

\begin{equation}
Q_{3_k}(t) = 0
\end{equation}

\begin{equation}
 L_3(t) =  L_3(t) - \text{total_samples_for_PCR_Testing}_{\text{Q3}_k}(t)
\end{equation}

### Simulate PCR Testing on each sampling cohort in Q3
Loop over all cohorts $k$ from $1:K$

\begin{equation}
Y_{Q3_{k}}(t) =  \sim Binomial(\text{total_samples_for_PCR_Testing_lag_2}_{\text{Q3}_k}(t), \text{PCR_sens})
\end{equation}


\begin{equation}
\text{neg_samples}_{Q3}(t) = \text{neg_samples}_{Q3}(t) + \text{total_samples_for_PCR_Testing_lag_2}_{\text{Q3}_k}(t) - Y_{Q3_{k}}(t) 
\end{equation}

### Update lags for total samples for PCR testing for Q3
\begin{equation}
\text{total_samples_for_PCR_Testing_lag_2}_{\text{Q3}_k}(t) =  \text{total_samples_for_PCR_Testing_lag_1}_{\text{Q3}_k}(t)
\end{equation}

\begin{equation}
\text{total_samples_for_PCR_Testing_lag_1}_{\text{Q3}_k}(t) =  \text{total_samples_for_PCR_Testing}_{\text{Q3}_k}(t)
\end{equation}

### Update positive case matrix ($P_{\text{Q3}}$)
For all daily sampling cohorts $k$ within the last 14 days:

\begin{equation}
P_{\text{Q3}_k}(t) = P_{\text{Q3}_k}(t) + Y_{Q3_{k}}(t) 
\end{equation}

### Re-testing (Add lagged positive samples from Queue 3 into Queue 4)
The state variable $\text{First_re_test}_{\text{Q3}}(t)$ are samples that we first re-sampled during the previous day. They now need to be re-sampled a second time.

\begin{equation}
\text{Second_re_test}_{\text{Q3}}(t) = \text{First_re_test}_{\text{Q3}}(t) 
\end{equation}

\begin{equation}
C_{Q4}(t) = \text{Second_re_test}_{\text{Q3}}(t)
\end{equation}

Let $K$ be the oldest cohort stored ($K = 14$). This cohort will have their first re-sampling conducted. 

\begin{equation}
\text{First_re_test}_{\text{Q3}}(t) = P_{\text{Q3}_K}(t) 
\end{equation}

\begin{equation}
C_{Q4}(t) = C_{Q4}(t) + \text{First_re_test}_{\text{Q3}}(t)
\end{equation}

### Increment Q3 Sampling Cohorts

For $k$ in $2:K$:

\begin{equation}
P_{\text{Q3}_{\text{old}_{k}}} = P_{\text{Q3}_k}(t)
\end{equation}

\begin{equation}
P_{\text{Q3}_k}(t) = P_{\text{Q3}_{\text{old}_{k-1}}}
\end{equation}

For the case when $k=1$:

\begin{equation}
P_{\text{Q3}_1}(t) = 0
\end{equation}

For integer $k$ in $1:K$:

\begin{equation}
Q_{3_{\text{old}_k}} = Q_{3_k}(t)
\end{equation}

For the case where $k = K$

\begin{equation}
\text{Backlog_Queue_3}(t) = \text{Backlog_Queue_3}(t) + Q_{3_{\text{old}_K}}
\end{equation}

For integer $k$ in $k >1$ and $k <= K$:

\begin{equation}
 Q_{3_k}(t) = Q_{3_{\text{old}_{k-1}}} 
\end{equation}

For the case when $k=1$:

\begin{equation}
 Q_{3_1}(t) = 0
\end{equation}






## Queue 4

<!-- ### Deal with loss in Queue 4 due to recovery -->
<!-- Unlike Queue 2, we assume that inidivudals tested in Queue 3 who recover before their is sufficient testing capacity will not be re-tested. -->

<!-- Revised -->

### Add new cases to queue

\begin{equation}
 Q_{4}(t) = Q_{4}(t) + C_{Q4}(t)
\end{equation}

### Determine number of samples that will be tested from Queue 4

Recall that $L_4$ is the testing capacity available at the end of Queue 4.

\begin{equation}
L_4(t) = L_3(t)
\end{equation}

If $Q_{4}(t) > L_4(t)$:

 
\begin{equation}
\text{total_samples_for_PCR_Testing}_{\text{Q4}}(t) =   L_4(t)
\end{equation}

\begin{equation}
Q_{4}(t) = Q_{4}(t) - L_4(t)
\end{equation}

\begin{equation}
 L_4(t) = 0
\end{equation}

 Else:

\begin{equation}
\text{total_samples_for_PCR_Testing}_{\text{Q4}}(t) =   Q_{4}(t)
\end{equation}

\begin{equation}
Q_{4}(t) = 0
\end{equation}

\begin{equation}
 L_4(t) =  L_4(t) - \text{total_samples_for_PCR_Testing}_{\text{Q4}}(t)
\end{equation}

Recall that we do not keep track of the results of the PCR testing in Queue 4, as it will not impact the count of reported cases. We are also not worried about lags here, and we assume that all samples that enter Queue 4 are eventually tested (no addition loss rates). 

### Total neg tests (all queues)
\begin{equation}
 \text{total_neg_samples_all_queues}(t) = \text{total_samples_for_PCR_Testing}_{\text{Q4}}(t) + \text{total_samples_for_PCR_Testing}_{\text{Q2}}(t) + \text{neg_samples_Q1}_{Q1}(t) +
 \text{neg_samples_Q3}_{Q3}(t) + Y_{QNC_{\text{backlog}}}(t) + \sum_{v=1}^V Y_{QNC_{v}}(t)
\end{equation}



# Build Model
## POMP Csnippet

### Process model
```{r rproc}

```

## Initialization Csnippet
```{r init}

```

### Parameter Transforms
```{r par_trans}

```


### Measurement Model
```{r rmeas}

```

```{r dmeas}

```

# Simulate from reasonable parameters

### Definte reasonable parameters
```{r}
##Initial param guesses



phi_E = 1.09
phi_U = phi_E
phi_S = 1/5

h_V = 1/13

p_S = 0.15
p_H_cond_S = 0.30

gamma = 1/3

true_quarantine_start_time= as.Date("2020-03-23")
true_social_distancing_start_time = as.Date("2020-03-19")
converted_quarantine_start_time = true_quarantine_start_time - true_start_date
converted_quarantine_start_time
quarantine_start_time = as.numeric(converted_quarantine_start_time)

converted_social_distancing_start_time = true_social_distancing_start_time - true_start_date
converted_social_distancing_start_time
social_distancing_start_time = as.numeric(converted_social_distancing_start_time)


PCR_sens = 0.90


b_a = 1

R_0 = 10.25
b_q = .08

b_p = 0;

E_0 = 15200
z_0 = 15200
N_0 = 8.0e6
C_0 = 0

sigma_M = 0.25

G_w_y_scaling = 0.162
param_vec = c(M_0 = M,
              V_0 = V,
              K_0 = K,
              phi_E = phi_E,
              phi_U = phi_U,
              phi_S = phi_S,
              h_V = h_V,
              p_S = p_S,
              p_H_cond_S = p_H_cond_S,
              gamma = gamma,
              quarantine_start_time = quarantine_start_time,
              social_distancing_start_time = social_distancing_start_time,
              PCR_sens = PCR_sens,
              b_q = b_q,
              b_a = b_a,
              b_p = b_p,
              R_0 = R_0,
              E_0 = E_0,
              z_0 = z_0,
              N_0 = N_0,
              C_0 = C_0,
              sigma_M = sigma_M,
              beta_w_3 = beta_w_3,
              beta_w_2 = beta_w_2,
              beta_w_1 = beta_w_1,
              beta_w_0 = beta_w_0,
              g_0 = g_0,
              g_F = g_F,
              sigma_epsilon = sigma_epsilon,
              G_w_y_scaling = G_w_y_scaling)
param_vec


```

### Call simulate
```{r}
sim_data = simulate(nsim = 100,
                    seed = 23456,
                    times = Observed_data$times,
                    t0 = t0,
                    rprocess = pomp::euler(rproc,delta.t = 1),
                    params = param_vec,
                    paramnames = paramnames,
                    statenames = statenames,
                    obsnames = obsnames,
                    accumvars = acumvarnames,
                    rinit = init,
                    rmeas = rmeas,
                    covar = covar,
                    format = "data.frame",
                    obs = FALSE)
#head(sim_data)
```

### Plot from simulated data
```{r}
sim_data_median_Y = aggregate(Y ~ time, sim_data, median)
sim_data_quant = aggregate(Y ~ time, sim_data, quantile, probs = c(0.025, 0.975))
sim_data_quant$Y = as.data.frame(sim_data_quant$Y)
colnames(sim_data_quant$Y) = c("Q2.5", "Q97.5")



comp_data = data.frame(time = sim_data_median_Y$time,
                       sim_data_median = sim_data_median_Y$Y,
                      sim_data_low_Q = sim_data_quant$Y$Q2.5,
                      sim_data_high_Q = sim_data_quant$Y$Q97.5,
                       true_data = Observed_data$Y)

comp_data_melt = melt(comp_data, id.vars = c("time", "sim_data_low_Q",
                                             "sim_data_high_Q"))




p = ggplot(data = comp_data_melt) +
  geom_ribbon(aes(x = time, ymin = sim_data_low_Q,
                  ymax = sim_data_high_Q), fill = "grey70") +
  geom_line(aes(x = time, y = value, color = variable)) +
  geom_point(aes(x = time, y = value, color = variable)) +
  rahul_theme +
  theme_white_background +
    geom_vline(xintercept = quarantine_start_time, color = 'blue') +
   geom_vline(xintercept = social_distancing_start_time, color = 'orange') +
  median_legend_lab +
   xlab("Days since March 1 2020")+
  ylab("Observed Daily Cases")
p
figure_name = paste0("../Figures/Local_Simulation_Tests/", model_name, "_test_sim_from_inital_params.png")
png(figure_name)
print(p)
dev.off()

```

```{r}
p = ggplot(data = comp_data_melt) +
  geom_ribbon(aes(x = time, ymin = log(sim_data_low_Q),
                  ymax = log(sim_data_high_Q)), fill = "grey70") +
  geom_line(aes(x = time, y = log(value), color = variable)) +
  geom_point(aes(x = time, y = log(value), color = variable)) +
  rahul_theme +
  theme_white_background +
    geom_vline(xintercept = quarantine_start_time, color = 'blue') +
  geom_vline(xintercept = social_distancing_start_time, color = 'orange') +
  median_legend_lab +
   xlab("Days since March 1 2020")+
  ylab("Observed Daily Cases")
p
```
### S over N
```{r}
sim_data$S_over_N = sim_data$S/sim_data$N

sim_data_S_over_N_median = aggregate(S_over_N ~ time, sim_data, median)
sim_data_S_over_N_quant = aggregate(S_over_N ~ time, sim_data, quantile, probs = c(0.025, 0.975))
sim_data_S_over_N_quant$S_over_N = as.data.frame(sim_data_S_over_N_quant$S_over_N)
colnames(sim_data_S_over_N_quant$S_over_N) = c("Q2.5", "Q97.5")


comp_data = data.frame(time = sim_data_S_over_N_median$time,
                       sim_data_median = sim_data_S_over_N_median$S_over_N,
                      sim_data_low_Q = sim_data_S_over_N_quant$S_over_N$Q2.5,
                      sim_data_high_Q = sim_data_S_over_N_quant$S_over_N$Q97.5)

comp_data_melt = melt(comp_data, id.vars = c("time", "sim_data_low_Q",
                                             "sim_data_high_Q"))




p = ggplot(data = comp_data_melt) +
  geom_ribbon(aes(x = time, ymin = sim_data_low_Q,
                  ymax = sim_data_high_Q), fill = "grey70") +
  geom_line(aes(x = time, y = value, color = variable)) +
  geom_point(aes(x = time, y = value, color = variable), size  = 3) +
  rahul_theme +
  theme_white_background +
  median_legend_lab + rahul_man_figure_theme +
   xlab("Days since March 1, 2020")+
  ylab("S over N")
p
png("../Figures/MIF_local_test_results/N_12_Model_sim_test_params_S_over_N.png")
print(p)
dev.off()
```


###Diagnostic Plotting
```{r}
  state_var_list = colnames(sim_data)
  combined_sim_var_df = data.frame(matrix(nrow = 0, ncol = 5))
  colnames(combined_sim_var_df) = c("time", "median", "low_Q", "high_Q",
                                    "var")
  for(var_index in seq(from = 3, to = length(state_var_list))){

    single_var = state_var_list[var_index]
    #print(single_var)
    single_var_data = dplyr::select(sim_data,
                                    time,
                                    .id,
                                    target_var = single_var)

    single_var_df = single_var_data %>%
      group_by(time)%>%
      summarize(median = median(target_var),
                low_Q = quantile(target_var, 0.025),
                high_Q = quantile(target_var, 0.975)) %>%
      as.data.frame() %>%
      mutate(var = single_var)

    combined_sim_var_df = rbind(combined_sim_var_df, single_var_df)
  }

  epi_comp_list = c("S", "E_1","I_P","I_S_1", "I_S_2", "I_A", "I_H", "R_A", "R_F", "R_H", "A_T", "beta")

S_Comp_only = combined_sim_var_df %>%
  filter(var %in% epi_comp_list)
p = ggplot(data = S_Comp_only) +
  geom_ribbon(aes(x = time, ymin = low_Q,
                  ymax = high_Q), fill = "grey70") +
  geom_line(aes(x = time, y = median, color = 'red')) +
  geom_point(aes(x = time, y = median, color = 'red')) +
  rahul_theme +
  theme_white_background +
  median_legend_lab +
   xlab("Days since March 1, 2020")+
  ylab("State variable value") +
    geom_vline(xintercept = quarantine_start_time, color = 'blue') +
  facet_wrap(~var, scales = "free_y") +
    geom_vline(xintercept = social_distancing_start_time, color = 'orange') +
  theme(legend.position = "none")
p

  Accum_and_pop_var_list = c("C_Q1", "C_Q2","C_QNC",
                             "C_Q3","C_Q4",
                             "Y_sum", "N", "G_w_y")
  Accum_and_pop_var_only = combined_sim_var_df %>%
  filter(var %in% Accum_and_pop_var_list)
  p = ggplot(data = Accum_and_pop_var_only) +
  geom_ribbon(aes(x = time, ymin = low_Q,
                  ymax = high_Q), fill = "grey70") +
  geom_line(aes(x = time, y = median, color = 'red')) +
  geom_point(aes(x = time, y = median, color = 'red')) +
  rahul_theme +
  theme_white_background +
  median_legend_lab +
   xlab("Days since March 1, 2020")+
  ylab("State variable value") +
    geom_vline(xintercept = quarantine_start_time, color = 'blue') +
    geom_vline(xintercept = social_distancing_start_time, color = 'orange') +
  facet_wrap(~var, scales = "free_y") +
  theme(legend.position = "none")
p

  Queue_comp_list = c("Backlog_Queue_1",  "Backlog_Queue_NC", "Q_2","Backlog_Queue_3", "Q_4",
                      "neg_samples_Q1", "neg_samples_Q3", "total_neg_samples_all_queues", "L_int")


Queue_Comp_only = combined_sim_var_df %>%
  filter(var %in% Queue_comp_list)
p = ggplot(data = Queue_Comp_only) +
  geom_ribbon(aes(x = time, ymin = low_Q,
                  ymax = high_Q), fill = "grey70") +
  geom_line(aes(x = time, y = median, color = 'red')) +
  geom_point(aes(x = time, y = median, color = 'red')) +
    geom_vline(xintercept = quarantine_start_time, color = 'blue') +
  geom_vline(xintercept = social_distancing_start_time, color = 'orange') +
  rahul_theme +
  theme_white_background +
  median_legend_lab +
   xlab("Days since March 1, 2020")+
  ylab("State variable value") +
  facet_wrap(~var, scales = "free_y") +
  theme(legend.position = "none")
p

flag_list = c( "Neg_State_Value_Detected",
               "NAN_State_Value_Detected",
               "Error_Printing_Complete")
flag_only = combined_sim_var_df %>%
  filter(var %in% flag_list)

p = ggplot(data = flag_only) +
  geom_ribbon(aes(x = time, ymin = low_Q,
                  ymax = high_Q), fill = "grey70") +
  geom_line(aes(x = time, y = median, color = 'red')) +
  geom_point(aes(x = time, y = median, color = 'red')) +
    geom_vline(xintercept = quarantine_start_time, color = 'blue') +
  geom_vline(xintercept = social_distancing_start_time, color = 'orange') +
  rahul_theme +
  theme_white_background +
  median_legend_lab +
   xlab("Days since March 1, 2020")+
  ylab("State variable value") +
  facet_wrap(~var, scales = "free_y") +
  theme(legend.position = "none")
p

backlog_var_list = c( "Backlog_Queue_1",
               "total_samples_for_PCR_Testing_backlog_Q1",
               "total_samples_for_PCR_Testing_backlog_lag_1_Q1",
               "total_samples_for_PCR_Testing_backlog_lag_2_Q1",
               "Backlog_Queue_NC",
               "total_samples_for_PCR_Testing_backlog_QNC",
               "total_samples_for_PCR_Testing_backlog_lag_1_QNC",
               "total_samples_for_PCR_Testing_backlog_lag_2_QNC",
               "Backlog_Queue_3",
               "total_samples_for_PCR_Testing_backlog_Q3",
               "total_samples_for_PCR_Testing_backlog_lag_1_Q3",
               "total_samples_for_PCR_Testing_backlog_lag_2_Q3")
backlog_var_only = combined_sim_var_df %>%
  filter(var %in% backlog_var_list)

p = ggplot(data = backlog_var_only) +
  geom_ribbon(aes(x = time, ymin = low_Q,
                  ymax = high_Q), fill = "grey70") +
  geom_line(aes(x = time, y = median, color = 'red')) +
  geom_point(aes(x = time, y = median, color = 'red')) +
    geom_vline(xintercept = quarantine_start_time, color = 'blue') +
  geom_vline(xintercept = social_distancing_start_time, color = 'orange') +
  rahul_theme +
  theme_white_background +
  median_legend_lab +
   xlab("Backlog Variables Only -Days since March 1, 2020")+
  ylab("State variable value") +
  facet_wrap(~var, scales = "free_y") +
  theme(legend.position = "none")
p

queues_2_and_4_var_list = c("C_Q2","Q_2",
               "total_samples_for_PCR_Testing_Q2",
               "C_Q4", "Q_4",
               "total_samples_for_PCR_Testing_Q4",
               "Y_Q5", "neg_samples_Q5", "L_4")
queues_2_and_4_var_only = combined_sim_var_df %>%
  filter(var %in% queues_2_and_4_var_list)

p = ggplot(data = queues_2_and_4_var_only) +
  geom_ribbon(aes(x = time, ymin = low_Q,
                  ymax = high_Q), fill = "grey70") +
  geom_line(aes(x = time, y = median, color = 'red')) +
  geom_point(aes(x = time, y = median, color = 'red')) +
    geom_vline(xintercept = quarantine_start_time, color = 'blue') +
  rahul_theme +
  theme_white_background +
  median_legend_lab +
   xlab("Queues 2 and 4 Variables Only -Days since March 1, 2020")+
  ylab("State variable value") +
  facet_wrap(~var, scales = "free_y") +
  theme(legend.position = "none")
p

```
### Hospitalization Comparison with Syndrome Surveliance
```{r}
obs_resp_synd_df_raw = read.csv(
     file = "../Generated_Data/simulated_non_COVID_data.csv")
#head(obs_resp_synd_df_raw)
```



## Array diagnostic testing

## Exposed state compartments
```{r}
exposed_list = sprintf("E_%d",1:M)
exposed_only = combined_sim_var_df %>%
  filter(var %in% exposed_list)

p = ggplot(data = exposed_only) +
  geom_ribbon(aes(x = time, ymin = low_Q,
                  ymax = high_Q), fill = "grey70") +
  geom_line(aes(x = time, y = median, color = 'red')) +
  geom_point(aes(x = time, y = median, color = 'red')) +
    geom_vline(xintercept = quarantine_start_time, color = 'blue') +
   geom_vline(xintercept = social_distancing_start_time, color = 'orange') +
  rahul_theme +
  theme_white_background +
  median_legend_lab +
   xlab("Days since March 1, 2020")+
  ylab("State variable value") +
  facet_wrap(~var, scales = "free_y") +
  theme(legend.position = "none")
p
```

### Queue 1 Testing
Queue 1 Compartments

###
```{r}
variables_to_loop_through = c("Q_1_","P_Q1_",
                            "total_samples_for_PCR_Testing_Q1_",
                            "total_samples_for_PCR_Testing_lag_1_Q1_",
                            "total_samples_for_PCR_Testing_lag_2_Q1_",
                            "Y_Q1_",
                            "Q_NC_",
                            "total_samples_for_PCR_Testing_QNC_",
                            "total_samples_for_PCR_Testing_lag_1_QNC_",
                            "total_samples_for_PCR_Testing_lag_2_QNC_",
                            "Y_QNC_",
                            "Q_3_",
                            "P_Q3_",
                            "total_samples_for_PCR_Testing_Q3_",
                            "total_samples_for_PCR_Testing_lag_1_Q3_",
                            "total_samples_for_PCR_Testing_lag_2_Q3_",
                            "Y_Q3_")
Array_size_list = c(rep(V, 11), rep(K,6))

plot_array_var = function(array_var, Array_size){
single_var_array_list = sprintf(paste0(array_var,"%d"),1:Array_size)
array_vars_only = combined_sim_var_df %>%
  filter(var %in% single_var_array_list)

p = ggplot(data = array_vars_only) +
  geom_ribbon(aes(x = time, ymin = low_Q,
                  ymax = high_Q), fill = "grey70") +
  geom_line(aes(x = time, y = median, color = 'red')) +
  geom_point(aes(x = time, y = median, color = 'red')) +
    geom_vline(xintercept = quarantine_start_time, color = 'blue') +
   geom_vline(xintercept = social_distancing_start_time, color = 'orange') +
  rahul_theme +
  theme_white_background +
  median_legend_lab +
   xlab(paste0(array_var,"-","Days since March 1, 2020"))+
  ylab("State variable value") +
  facet_wrap(~var, scales = "free_y") +
  theme(legend.position = "none")
print(p)
}

for(array_var_index in seq(1:length(variables_to_loop_through))){
  plot_array_var(array_var = variables_to_loop_through[array_var_index],
               Array_size = Array_size_list[array_var_index])
}

```

### Queue 1 Passage Check
```{r}
total_cases_entering_Q1 = sim_data %>%
  dplyr::select(time,.id,C_Q1, Y_sum, neg_samples_Q1, Q_1_2,
                Q_1_3, Q_1_13,
                total_samples_for_PCR_Testing_Q1_1,
                total_samples_for_PCR_Testing_Q1_2,
                total_samples_for_PCR_Testing_Q1_3,
                total_samples_for_PCR_Testing_Q1_4,
                total_samples_for_PCR_Testing_Q1_5,
                total_samples_for_PCR_Testing_Q1_6,
                total_samples_for_PCR_Testing_Q1_7,
                total_samples_for_PCR_Testing_Q1_8,
                total_samples_for_PCR_Testing_Q1_9,
                total_samples_for_PCR_Testing_Q1_10,
                total_samples_for_PCR_Testing_Q1_11,
                total_samples_for_PCR_Testing_Q1_12,
                total_samples_for_PCR_Testing_Q1_13,
                total_samples_for_PCR_Testing_backlog_Q1) %>%
  group_by(.id) %>%
  summarize(total_cases_entering_Q1 = sum(C_Q1),
            total_cases_tested_in_first_cohort = sum(total_samples_for_PCR_Testing_Q1_1),
            total_cases_with_at_least_two_cohorts = sum(Q_1_2),
            total_cases_tested_in_second_cohort = sum(total_samples_for_PCR_Testing_Q1_2),
            total_cases_with_at_least_three_cohorts = sum(Q_1_3),
            total_cases_tested_in_3_cohort = sum(total_samples_for_PCR_Testing_Q1_3),
            total_cases_tested_in_4_cohort = sum(total_samples_for_PCR_Testing_Q1_4),
            total_cases_tested_in_5_cohort = sum(total_samples_for_PCR_Testing_Q1_5),
            total_cases_tested_in_6_cohort = sum(total_samples_for_PCR_Testing_Q1_6),
            total_cases_tested_in_7_cohort = sum(total_samples_for_PCR_Testing_Q1_7),
            total_cases_tested_in_8_cohort = sum(total_samples_for_PCR_Testing_Q1_8),
            total_cases_tested_in_9_cohort = sum(total_samples_for_PCR_Testing_Q1_9),
            total_cases_tested_in_10_cohort = sum(total_samples_for_PCR_Testing_Q1_10),
            total_cases_tested_in_11_cohort = sum(total_samples_for_PCR_Testing_Q1_11),
            total_cases_tested_in_12_cohort = sum(total_samples_for_PCR_Testing_Q1_12),
            total_cases_tested_in_13_cohort = sum(total_samples_for_PCR_Testing_Q1_13),
            total_cases_tested_from_backlog = sum(total_samples_for_PCR_Testing_backlog_Q1),
            total_cases_with_at_least_thirteen_cohorts = sum(Q_1_13),
            true_positives_from_Q1 = sum(Y_sum),
            false_negatives_from_Q1 = sum(neg_samples_Q1)) %>%
  as.data.frame() %>%
  mutate(total_cases_leaving_Q1 = true_positives_from_Q1 +
           false_negatives_from_Q1,
         total_cases_in_queue_after_one_cohort = total_cases_tested_in_first_cohort +
           total_cases_with_at_least_two_cohorts,
         total_cases_in_queue_after_two_cohorts = total_cases_tested_in_first_cohort +
           total_cases_tested_in_second_cohort +total_cases_with_at_least_three_cohorts,
         total_cases_in_queue_after_12_cohorts =total_cases_tested_in_first_cohort +
           total_cases_tested_in_second_cohort +
           total_cases_tested_in_3_cohort +
           total_cases_tested_in_4_cohort +
           total_cases_tested_in_5_cohort +
           total_cases_tested_in_6_cohort +
           total_cases_tested_in_7_cohort +
           total_cases_tested_in_8_cohort +
           total_cases_tested_in_9_cohort +
           total_cases_tested_in_10_cohort +
           total_cases_tested_in_11_cohort +
           total_cases_tested_in_12_cohort +
           total_cases_with_at_least_thirteen_cohorts,
         total_cases_tested_in_queue_including_from_backlog =
           total_cases_tested_in_first_cohort +
           total_cases_tested_in_second_cohort +
           total_cases_tested_in_3_cohort +
           total_cases_tested_in_4_cohort +
           total_cases_tested_in_5_cohort +
           total_cases_tested_in_6_cohort +
           total_cases_tested_in_7_cohort +
           total_cases_tested_in_8_cohort +
           total_cases_tested_in_9_cohort +
           total_cases_tested_in_10_cohort +
           total_cases_tested_in_11_cohort +
           total_cases_tested_in_12_cohort +
           total_cases_tested_in_13_cohort +
           total_cases_tested_from_backlog) %>%
  mutate(overall_queue_gap = total_cases_entering_Q1-total_cases_leaving_Q1,
         gap_after_first_cohort = total_cases_entering_Q1 - total_cases_in_queue_after_one_cohort,
         gap_after_second_cohort = total_cases_entering_Q1 - total_cases_in_queue_after_two_cohorts,
         gap_after_12_cohorts = total_cases_entering_Q1 - total_cases_in_queue_after_12_cohorts,
         gap_after_all_compartments = total_cases_entering_Q1 - total_cases_tested_in_queue_including_from_backlog)

#total_cases_entering_Q1

```


```{r}
total_cases_entering_Q1 = sim_data %>%
  dplyr::select(time,.id,C_Q1, Y_sum, neg_samples_Q1, Q_1_2,
                Q_1_3, Q_1_13,
                total_samples_for_PCR_Testing_lag_2_Q1_1,
                total_samples_for_PCR_Testing_lag_2_Q1_2,
                total_samples_for_PCR_Testing_lag_2_Q1_3,
                total_samples_for_PCR_Testing_lag_2_Q1_4,
                total_samples_for_PCR_Testing_lag_2_Q1_5,
                total_samples_for_PCR_Testing_lag_2_Q1_6,
                total_samples_for_PCR_Testing_lag_2_Q1_7,
                total_samples_for_PCR_Testing_lag_2_Q1_8,
                total_samples_for_PCR_Testing_lag_2_Q1_9,
                total_samples_for_PCR_Testing_lag_2_Q1_10,
                total_samples_for_PCR_Testing_lag_2_Q1_11,
                total_samples_for_PCR_Testing_lag_2_Q1_12,
                total_samples_for_PCR_Testing_lag_2_Q1_13,
                total_samples_for_PCR_Testing_backlog_lag_2_Q1) %>%
  group_by(.id) %>%
  summarize(total_cases_entering_Q1 = sum(C_Q1),
            total_cases_tested_in_first_cohort = sum(total_samples_for_PCR_Testing_lag_2_Q1_1),
            total_cases_with_at_least_two_cohorts = sum(Q_1_2),
            total_cases_tested_in_second_cohort = sum(total_samples_for_PCR_Testing_lag_2_Q1_2),
            total_cases_with_at_least_three_cohorts = sum(Q_1_3),
            total_cases_tested_in_3_cohort = sum(total_samples_for_PCR_Testing_lag_2_Q1_3),
            total_cases_tested_in_4_cohort = sum(total_samples_for_PCR_Testing_lag_2_Q1_4),
            total_cases_tested_in_5_cohort = sum(total_samples_for_PCR_Testing_lag_2_Q1_5),
            total_cases_tested_in_6_cohort = sum(total_samples_for_PCR_Testing_lag_2_Q1_6),
            total_cases_tested_in_7_cohort = sum(total_samples_for_PCR_Testing_lag_2_Q1_7),
            total_cases_tested_in_8_cohort = sum(total_samples_for_PCR_Testing_lag_2_Q1_8),
            total_cases_tested_in_9_cohort = sum(total_samples_for_PCR_Testing_lag_2_Q1_9),
            total_cases_tested_in_10_cohort = sum(total_samples_for_PCR_Testing_lag_2_Q1_10),
            total_cases_tested_in_11_cohort = sum(total_samples_for_PCR_Testing_lag_2_Q1_11),
            total_cases_tested_in_12_cohort = sum(total_samples_for_PCR_Testing_lag_2_Q1_12),
            total_cases_tested_in_13_cohort = sum(total_samples_for_PCR_Testing_lag_2_Q1_13),
            total_cases_tested_from_backlog = sum(total_samples_for_PCR_Testing_backlog_lag_2_Q1),
            total_cases_with_at_least_thirteen_cohorts = sum(Q_1_13),
            true_positives_from_Q1 = sum(Y_sum),
            false_negatives_from_Q1 = sum(neg_samples_Q1)) %>%
  as.data.frame() %>%
  mutate(total_cases_leaving_Q1 = true_positives_from_Q1 +
           false_negatives_from_Q1,
         total_cases_in_queue_after_one_cohort = total_cases_tested_in_first_cohort +
           total_cases_with_at_least_two_cohorts,
         total_cases_in_queue_after_two_cohorts = total_cases_tested_in_first_cohort +
           total_cases_tested_in_second_cohort +total_cases_with_at_least_three_cohorts,
         total_cases_in_queue_after_12_cohorts =total_cases_tested_in_first_cohort +
           total_cases_tested_in_second_cohort +
           total_cases_tested_in_3_cohort +
           total_cases_tested_in_4_cohort +
           total_cases_tested_in_5_cohort +
           total_cases_tested_in_6_cohort +
           total_cases_tested_in_7_cohort +
           total_cases_tested_in_8_cohort +
           total_cases_tested_in_9_cohort +
           total_cases_tested_in_10_cohort +
           total_cases_tested_in_11_cohort +
           total_cases_tested_in_12_cohort +
           total_cases_with_at_least_thirteen_cohorts,
         total_cases_tested_in_queue_including_from_backlog =
           total_cases_tested_in_first_cohort +
           total_cases_tested_in_second_cohort +
           total_cases_tested_in_3_cohort +
           total_cases_tested_in_4_cohort +
           total_cases_tested_in_5_cohort +
           total_cases_tested_in_6_cohort +
           total_cases_tested_in_7_cohort +
           total_cases_tested_in_8_cohort +
           total_cases_tested_in_9_cohort +
           total_cases_tested_in_10_cohort +
           total_cases_tested_in_11_cohort +
           total_cases_tested_in_12_cohort +
           total_cases_tested_in_13_cohort +
           total_cases_tested_from_backlog) %>%
  mutate(overall_queue_gap = total_cases_entering_Q1-total_cases_leaving_Q1,
         gap_after_first_cohort = total_cases_entering_Q1 - total_cases_in_queue_after_one_cohort,
         gap_after_second_cohort = total_cases_entering_Q1 - total_cases_in_queue_after_two_cohorts,
         gap_after_12_cohorts = total_cases_entering_Q1 - total_cases_in_queue_after_12_cohorts,
         gap_after_all_compartments = total_cases_entering_Q1 - total_cases_tested_in_queue_including_from_backlog)

#total_cases_entering_Q1

```

Check end of first sim run
```{r}
sim_data_first_run_only = sim_data %>%
  filter(.id == 1)
#head(sim_data_first_run_only)
sim_data_first_run_only$total_samples_for_PCR_Testing_lag_1_Q1_1[nrow(sim_data_first_run_only)]
sim_data_first_run_only$total_samples_for_PCR_Testing_Q1_1[nrow(sim_data_first_run_only)]
sim_data_first_run_only$total_samples_for_PCR_Testing_lag_2_Q1_1[nrow(sim_data_first_run_only)]
sim_data_waiting_for_testing_at_end = sim_data %>%
  dplyr::select(time, .id, total_samples_for_PCR_Testing_lag_1_Q1_1,
                total_samples_for_PCR_Testing_lag_2_Q1_1) %>%
  filter(time == max(sim_data$time)) %>%
  mutate(total_waiting_for_testing = total_samples_for_PCR_Testing_lag_1_Q1_1 +
           total_samples_for_PCR_Testing_lag_2_Q1_1) %>%
  dplyr::select(.id, total_waiting_for_testing)
total_cases_entering_Q1_with_adj = join(total_cases_entering_Q1,
                                        sim_data_waiting_for_testing_at_end)
total_cases_entering_Q1_with_adj_summary_df = total_cases_entering_Q1_with_adj %>%
  mutate(gap_adjusted_for_waiting = overall_queue_gap - total_waiting_for_testing) %>%
  dplyr::select(.id, total_cases_entering_Q1, true_positives_from_Q1, false_negatives_from_Q1,
                overall_queue_gap, total_waiting_for_testing, gap_adjusted_for_waiting)
#total_cases_entering_Q1_with_adj_summary_df
sum(total_cases_entering_Q1_with_adj_summary_df$gap_adjusted_for_waiting)

```

### Updated test
```{r}
sim_data_first_run_only = sim_data %>%
  filter(.id == 1)
total_postive_cases_leaving_Q1 = sum(sim_data_first_run_only$Y_Q1_1 +
  sim_data_first_run_only$Y_Q1_2 +
  sim_data_first_run_only$Y_Q1_3 +
  sim_data_first_run_only$Y_Q1_4 +
  sim_data_first_run_only$Y_Q1_5 +
  sim_data_first_run_only$Y_Q1_6 +
  sim_data_first_run_only$Y_Q1_7 +
  sim_data_first_run_only$Y_Q1_8 +
  sim_data_first_run_only$Y_Q1_9 +
  sim_data_first_run_only$Y_Q1_10 +
  sim_data_first_run_only$Y_Q1_11 +
  sim_data_first_run_only$Y_Q1_12 +
  sim_data_first_run_only$Y_Q1_13 +
    sim_data_first_run_only$Y_Q1_backlog)

total_cases_entering_Q1_first_run_only = sum(sim_data_first_run_only$C_Q1)
gap = total_cases_entering_Q1_first_run_only - sum(sim_data_first_run_only$neg_samples_Q1) - total_postive_cases_leaving_Q1

gap
waiting_to_be_tested = sim_data_first_run_only$total_samples_for_PCR_Testing_Q1_1[nrow(sim_data_first_run_only)] + sim_data_first_run_only$total_samples_for_PCR_Testing_Q1_2[nrow(sim_data_first_run_only)] +sim_data_first_run_only$total_samples_for_PCR_Testing_lag_1_Q1_1[nrow(sim_data_first_run_only)]

gap_taking_into_account_waiting = gap - waiting_to_be_tested
gap_taking_into_account_waiting

```
### Queue 2 Diagnostic Test
```{r}
gap_check_Q2 = sim_data %>%
  dplyr::select(time, .id, total_samples_for_PCR_Testing_Q2, C_Q2) %>%
  group_by(.id) %>%
  summarize(total_samples_entering_Q2 = sum(C_Q2),
            total_samples_exiting_Q2 =
              sum(total_samples_for_PCR_Testing_Q2)) %>%
  as.data.frame() %>%
  mutate(Q2_gap = total_samples_entering_Q2 - total_samples_exiting_Q2)

#gap_check_Q2
sum(gap_check_Q2$Q2_gap)
```

### Queue 3 Diagnostic Tests
<!-- Gap check (use in absence of loss rate) -->
<!-- ```{r} -->


<!-- gap_check_Q3 = sim_data %>% -->
<!--   dplyr::select(time, .id, Y_Q3_1, -->
<!--                 Y_Q3_2, -->
<!--                 Y_Q3_3, -->
<!--                 Y_Q3_4, -->
<!--                 Y_Q3_5, -->
<!--                 Y_Q3_6, -->
<!--                 Y_Q3_7, -->
<!--                 Y_Q3_8, -->
<!--                 Y_Q3_9, -->
<!--                 Y_Q3_10, -->
<!--                 Y_Q3_11, -->
<!--                 Y_Q3_12, -->
<!--                 Y_Q3_13, -->
<!--                 Y_Q3_14, -->
<!--                 C_Q3, neg_samples_Q3, -->
<!--                 total_samples_for_PCR_Testing_Q3_1, -->
<!--                 total_samples_for_PCR_Testing_Q3_2, -->
<!--                 total_samples_for_PCR_Testing_Q3_3, -->
<!--                 total_samples_for_PCR_Testing_Q3_4, -->
<!--                 total_samples_for_PCR_Testing_Q3_5, -->
<!--                 total_samples_for_PCR_Testing_Q3_6, -->
<!--                 total_samples_for_PCR_Testing_Q3_7, -->
<!--                 total_samples_for_PCR_Testing_Q3_8, -->
<!--                 total_samples_for_PCR_Testing_Q3_9, -->
<!--                 total_samples_for_PCR_Testing_Q3_10, -->
<!--                 total_samples_for_PCR_Testing_Q3_11, -->
<!--                 total_samples_for_PCR_Testing_Q3_12, -->
<!--                 total_samples_for_PCR_Testing_Q3_13, -->
<!--                 total_samples_for_PCR_Testing_Q3_14, -->
<!--                 total_samples_for_PCR_Testing_backlog_Q3, -->
<!--                 total_samples_for_PCR_Testing_lag_1_Q3_1, -->
<!--                 total_samples_for_PCR_Testing_lag_2_Q3_1, -->
<!--                 Q_3_14, -->
<!--                 Backlog_Queue_3, -->
<!--                  Y_Q3_backlog, -->
<!--                 Q_3_2) %>% -->
<!--   group_by(.id) %>% -->
<!--   summarize(total_samples_entering_Q3 = sum(C_Q3), -->
<!--             Y_Q3_1_sum = sum(Y_Q3_1), -->
<!--             total_samples_for_PCR_Testing_Q3_1_sum = sum(total_samples_for_PCR_Testing_Q3_1), -->
<!--             total_samples_for_PCR_Testing_Q3_2_sum = sum(total_samples_for_PCR_Testing_Q3_2), -->
<!--             total_samples_for_PCR_Testing_Q3_3_sum = sum(total_samples_for_PCR_Testing_Q3_3), -->
<!--             total_samples_for_PCR_Testing_Q3_4_sum = sum(total_samples_for_PCR_Testing_Q3_4), -->
<!--             total_samples_for_PCR_Testing_Q3_5_sum = sum(total_samples_for_PCR_Testing_Q3_5), -->
<!--             total_samples_for_PCR_Testing_Q3_6_sum = sum(total_samples_for_PCR_Testing_Q3_6), -->
<!--             total_samples_for_PCR_Testing_Q3_7_sum = sum(total_samples_for_PCR_Testing_Q3_7), -->
<!--             total_samples_for_PCR_Testing_Q3_8_sum = sum(total_samples_for_PCR_Testing_Q3_8), -->
<!--             total_samples_for_PCR_Testing_Q3_9_sum = sum(total_samples_for_PCR_Testing_Q3_9), -->
<!--             total_samples_for_PCR_Testing_Q3_10_sum = sum(total_samples_for_PCR_Testing_Q3_10), -->
<!--             total_samples_for_PCR_Testing_Q3_11_sum = sum(total_samples_for_PCR_Testing_Q3_11), -->
<!--             total_samples_for_PCR_Testing_Q3_12_sum = sum(total_samples_for_PCR_Testing_Q3_12), -->
<!--             total_samples_for_PCR_Testing_Q3_13_sum = sum(total_samples_for_PCR_Testing_Q3_13), -->
<!--             total_samples_for_PCR_Testing_Q3_14_sum = sum(total_samples_for_PCR_Testing_Q3_14), -->
<!--             total_samples_for_PCR_Testing_backlog_Q3_sum = sum(total_samples_for_PCR_Testing_backlog_Q3), -->
<!--             Q_3_2_sum = sum(Q_3_2), -->
<!--             Q_3_14_sum = sum(Q_3_14), -->
<!--             Backlog_Queue_3_sum = sum(Backlog_Queue_3), -->
<!--             Y_Q3_2_sum = sum(Y_Q3_2), -->
<!--             Y_Q3_3_sum = sum(Y_Q3_3), -->
<!--             Y_Q3_4_sum = sum(Y_Q3_4), -->
<!--             Y_Q3_5_sum = sum(Y_Q3_5), -->
<!--             Y_Q3_6_sum = sum(Y_Q3_6), -->
<!--             Y_Q3_7_sum = sum(Y_Q3_7), -->
<!--             Y_Q3_8_sum = sum(Y_Q3_8), -->
<!--             Y_Q3_9_sum = sum(Y_Q3_9), -->
<!--             Y_Q3_10_sum = sum(Y_Q3_10), -->
<!--             Y_Q3_11_sum = sum(Y_Q3_11), -->
<!--             Y_Q3_12_sum = sum(Y_Q3_12), -->
<!--             Y_Q3_13_sum = sum(Y_Q3_13), -->
<!--             Y_Q3_14_sum = sum(Y_Q3_14), -->
<!--             Y_Q3_backlog_sum = sum(Y_Q3_backlog), -->
<!--             neg_samples_Q3_sum = sum(neg_samples_Q3), -->
<!--             total_samples_for_PCR_Testing_lag_1_Q3_1_sum = sum(total_samples_for_PCR_Testing_lag_1_Q3_1), -->
<!--             total_samples_for_PCR_Testing_lag_2_Q3_1_sum = sum(total_samples_for_PCR_Testing_lag_2_Q3_1) -->
<!--             ) %>% -->
<!--   as.data.frame() %>% -->
<!--   mutate(total_true_positive_cases_exiting_Q3 = Y_Q3_1_sum + Y_Q3_2_sum + Y_Q3_3_sum + -->
<!--            Y_Q3_4_sum + Y_Q3_5_sum + Y_Q3_6_sum + Y_Q3_7_sum + Y_Q3_8_sum + -->
<!--            Y_Q3_9_sum + Y_Q3_10_sum + Y_Q3_11_sum + Y_Q3_12_sum + -->
<!--            + Y_Q3_13_sum + Y_Q3_14_sum + Y_Q3_backlog_sum, -->
<!--          total_false_negative_cases_exiting_Q3 = neg_samples_Q3_sum, -->
<!--          total_cases_in_queue_after_one_cohort = total_samples_for_PCR_Testing_Q3_1_sum + -->
<!--            Q_3_2_sum, -->
<!--          total_cases_in_queue_after_all_cohorts = -->
<!--            total_samples_for_PCR_Testing_Q3_1_sum + -->
<!--            total_samples_for_PCR_Testing_Q3_2_sum + -->
<!--            total_samples_for_PCR_Testing_Q3_3_sum + -->
<!--            total_samples_for_PCR_Testing_Q3_4_sum + -->
<!--            total_samples_for_PCR_Testing_Q3_5_sum + -->
<!--            total_samples_for_PCR_Testing_Q3_6_sum + -->
<!--            total_samples_for_PCR_Testing_Q3_7_sum + -->
<!--            total_samples_for_PCR_Testing_Q3_8_sum + -->
<!--            total_samples_for_PCR_Testing_Q3_9_sum + -->
<!--            total_samples_for_PCR_Testing_Q3_10_sum + -->
<!--            total_samples_for_PCR_Testing_Q3_11_sum + -->
<!--            total_samples_for_PCR_Testing_Q3_12_sum + -->
<!--            total_samples_for_PCR_Testing_Q3_13_sum + -->
<!--            total_samples_for_PCR_Testing_Q3_14_sum + -->
<!--            total_samples_for_PCR_Testing_backlog_Q3_sum, -->
<!--          Q3_gap = total_samples_entering_Q3 -  total_true_positive_cases_exiting_Q3   - total_false_negative_cases_exiting_Q3, -->
<!--          Q_3_gap_after_first_cohort = total_samples_entering_Q3 -total_cases_in_queue_after_one_cohort, -->
<!--          Q_3_gap_after_all_cohorts = total_samples_entering_Q3 - total_cases_in_queue_after_all_cohorts) %>% -->
<!--   dplyr::select(.id, total_true_positive_cases_exiting_Q3, -->
<!--                 total_false_negative_cases_exiting_Q3,  -->
<!--                 total_false_negative_cases_exiting_Q3, -->
<!--                 total_cases_in_queue_after_one_cohort, -->
<!--                 Q3_gap, -->
<!--                 Q_3_gap_after_first_cohort, -->
<!--                 Q_3_gap_after_all_cohorts) -->
<!-- sim_data_waiting_for_testing_at_end = sim_data %>%  -->
<!--   dplyr::select(time, .id, total_samples_for_PCR_Testing_lag_1_Q3_1, -->
<!--                 total_samples_for_PCR_Testing_lag_2_Q3_1, -->
<!--                 total_samples_for_PCR_Testing_lag_1_Q3_2, -->
<!--                 total_samples_for_PCR_Testing_lag_2_Q3_2, -->
<!--                 Q_3_2, -->
<!--                 Q_3_3, -->
<!--                 Q_3_4) %>% -->
<!--   filter(time == max(sim_data$time)) %>% -->
<!--   mutate(total_waiting_for_testing = total_samples_for_PCR_Testing_lag_1_Q3_1 + -->
<!--            total_samples_for_PCR_Testing_lag_2_Q3_1) %>% -->
<!--   dplyr::select(.id, total_waiting_for_testing) -->

<!-- gap_check_Q3 = join(gap_check_Q3, -->
<!--                     sim_data_waiting_for_testing_at_end) -->
<!-- gap_check_Q3 = gap_check_Q3 %>% -->
<!--   mutate(Q3_adjusted_gap = Q3_gap - total_waiting_for_testing) -->
<!-- sum(gap_check_Q3$Q3_adjusted_gap) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- single_run_end_of_sim_values = sim_data %>% -->
<!--   filter(.id ==1) %>% -->
<!--   filter(time == 89) -->
<!-- single_run_end_of_sim_values -->

<!-- ``` -->

### Queue 4 Diagnostic Test
```{r}
gap_check_Q4 = sim_data %>%
  dplyr::select(time, .id, total_samples_for_PCR_Testing_Q4, C_Q4) %>%
  group_by(.id) %>%
  summarize(total_samples_entering_Q4 = sum(C_Q4),
            total_samples_exiting_Q4 =
              sum(total_samples_for_PCR_Testing_Q4)) %>%
  as.data.frame() %>%
  mutate(Q4_gap = total_samples_entering_Q4 - total_samples_exiting_Q4)

#gap_check_Q4
sum(gap_check_Q4$Q4_gap)
```

## Filter a simulation
```{r}
single_sim_df= filter(sim_data, .id == 1)
pfilter_sim_data = dplyr::select(single_sim_df, time = time, Y = Y,
                                  obs_prop_positive = obs_prop_positive)
p = ggplot(data = pfilter_sim_data,(aes(x = time, y = Y))) + geom_point() + geom_line() + rahul_theme + xlab("Days since March 1, 2020")
p

p = ggplot(data = pfilter_sim_data,(aes(x = time, y = obs_prop_positive))) + geom_point() + geom_line() + rahul_theme + xlab("Days since March 1, 2020")
p
```

```{r}
ptm <- proc.time()
pfilter_sim_output = pfilter(data = pfilter_sim_data,
                             seed = 12345,
                    times = pfilter_sim_data$time,
                    t0 = t0,
                    rprocess = pomp::euler(rproc,delta.t = 1),
                    params = param_vec,
                    paramnames = paramnames,
                    statenames = statenames,
                    obsnames = obsnames,
                    dmeas = dmeas,
                    accumvars = acumvarnames,
                    rinit = init,
                    rmeas = rmeas,
                    partrans = par_trans,
                    covar = covar,
                    format = "data.frame",
                    Np = 1000)
proc.time() - ptm
plot(pfilter_sim_output)
logLik(pfilter_sim_output)
eff.sample.size(pfilter_sim_output)
cond.logLik(pfilter_sim_output)
```

## Pfilter real data with 1 particle
```{r}
ptm <- proc.time()
pfilter_real_output= pfilter(data = Observed_data,
                             seed = 12345,
                    times = Observed_data$times,
                    t0 = t0,
                    rprocess = pomp::euler(rproc,delta.t = 1),
                    params = param_vec,
                    paramnames = paramnames,
                    statenames = statenames,
                    obsnames = obsnames,
                    dmeas = dmeas,
                    accumvars = acumvarnames,
                    rinit = init,
                    rmeas = rmeas,
                    partrans = par_trans,
                    covar = covar,
                    format = "data.frame",
                    Np = 1)
proc.time() - ptm
#plot(pfilter_real_output)
logLik(pfilter_real_output)
eff.sample.size(pfilter_real_output)
cond.logLik(pfilter_real_output)
```

##  Pfilter real data with 1000 particles
```{r}
ptm <- proc.time()
pfilter_real_output = pfilter(data = Observed_data,
                             seed = 12345,
                    times = Observed_data$times,
                    t0 = t0,
                    rprocess = pomp::euler(rproc,delta.t = 1),
                    params = param_vec,
                    paramnames = paramnames,
                    statenames = statenames,
                    obsnames = obsnames,
                    dmeas = dmeas,
                    accumvars = acumvarnames,
                    rinit = init,
                    rmeas = rmeas,
                    covar = covar,
                    partrans = par_trans,
                    format = "data.frame",
                    Np = 1000,
                    save.state = TRUE,
                    filter.mean = TRUE,
                    pred.mean = TRUE,
                    pred.var = TRUE)
proc.time() - ptm
#plot(pfilter_real_output)
logLik(pfilter_real_output)
eff.sample.size(pfilter_real_output)
cond.logLik(pfilter_real_output)
```

##  Pfilter real data with 1000 particles
```{r}
ptm <- proc.time()
pfilter_real_output = pfilter(data = Observed_data,
                             seed = 12345,
                    times = Observed_data$times,
                    t0 = t0,
                    rprocess = pomp::euler(rproc,delta.t = 1),
                    params = param_vec,
                    paramnames = paramnames,
                    statenames = statenames,
                    obsnames = obsnames,
                    dmeas = dmeas,
                    accumvars = acumvarnames,
                    rinit = init,
                    rmeas = rmeas,
                    covar = covar,
                    partrans = par_trans,
                    format = "data.frame",
                    Np = 1000,
                    save.state = TRUE,
                    filter.mean = TRUE,
                    pred.mean = TRUE,
                    pred.var = TRUE)
proc.time() - ptm
#plot(pfilter_real_output)
logLik(pfilter_real_output)
eff.sample.size(pfilter_real_output)
cond.logLik(pfilter_real_output)
```

### Analysis
```{r}
filter_mean_mat = pfilter_real_output@filter.mean
filter_mean_df = filter_mean_mat%>%
  t() %>%
  as.data.frame()
#head(filter_mean_df)
filter_mean_df$times = filter_mean_mat %>%
  colnames() %>% as.numeric()
Y_sum_filter_mean = filter_mean_df %>%
  dplyr::select(times, Y_sum)



pred_var_df = pfilter_real_output@pred.var %>%
  t() %>%
  as.data.frame()
pred_var_df$times = filter_mean_mat %>%
  colnames() %>% as.numeric()

Y_sum_pred_var = pred_var_df %>%
  dplyr::select(times, Y_sum_var = Y_sum)

Y_sum_filter_mean_vs_obs = join(Y_sum_filter_mean, Observed_data)
Y_sum_filter_mean_vs_obs = join(Y_sum_filter_mean_vs_obs, Y_sum_pred_var)


size= (1/sigma_M/sigma_M)



Y_sum_filter_mean_vs_obs$Neg_binom_lik = dnbinom(Y_sum_filter_mean_vs_obs$Y, mu = Y_sum_filter_mean_vs_obs$Y_sum, size = size,
                                                log = TRUE)

plot_data = Y_sum_filter_mean_vs_obs %>%
  dplyr::select(times, Y_sum_filter_mean = Y_sum, Y) %>%
  melt(id.vars = "times")

p = ggplot(data = plot_data, aes(x = times, y = log(value), color = variable)) + geom_point() +
  geom_line() + rahul_theme
p
```

# MIF to simulated data (Validation)
## No truncation
```{r}
mif_sim_data = pfilter_sim_data
mif_sim_file_name = paste0("../Generated_Data/MIF_local_test_results/mif_sim_test_data_", model_name, "_COVID_NYC.RData")
save(mif_sim_data,
     file = mif_sim_file_name)
```

##Plot simulated trajectory to be used for fitting
```{r}

p = ggplot(data = mif_sim_data,(aes(x = time, y = Y))) + geom_point() + geom_line() + rahul_theme + xlab("Days since March 1, 2020")
p


```

## Load parallelization libraries
```{r, eval= FALSE}
library(foreach)
library(doParallel)
registerDoParallel()
```


## Run pfilter repeatedly (test paralell structure)
```{r}
library(doRNG)
registerDoRNG(123456)
ptm <- proc.time()
rds_index = rds_index + 1
rds_file_name = paste0("Stew_Files/", model_name, "_", "rds_", rds_index, ".rds")
bake(file = rds_file_name,{
  foreach(i=1:10, .packages = 'pomp',
          .export = c("rproc", "rmeas", "dmeas", "init", "paramnames", "statenames", "obsnames",
                      "param_vec", "par_trans", "acumvarnames")
  ) %dopar% {
            pfilter(data = mif_sim_data,
                    times = mif_sim_data$time,
                    t0 = t0,
                    rprocess = pomp::euler(rproc,delta.t = 1),
                    params = param_vec,
                    paramnames = paramnames,
                    statenames = statenames,
                    obsnames = obsnames,
                    dmeas = dmeas,
                    accumvars = acumvarnames,
                    rinit = init,
                    rmeas = rmeas,
                    partrans = par_trans,
                    format = "data.frame",
                    covar = covar,
                    Np = 1000)
          }
}) ->pfilter_sim_par_output
proc.time() - ptm

(L_pfilter_sim_par_output <- logmeanexp(sapply(pfilter_sim_par_output, logLik), se = TRUE))


```


## Store results of pfilter run in likelihood csv file
```{r, eval = FALSE}
results <- as.data.frame(as.list(c(coef(pfilter_sim_par_output[[1]]), logLik = L_pfilter_sim_par_output[1],
                                        loglik = L_pfilter_sim_par_output[2])))
results
result_output_file = paste0("covid_NYC_", model_name, "_sim_data_fit_params.csv")
write.csv(results, file = result_output_file, row.names = FALSE)
```

## MIF Debug Test
One mif run, one particle

```{r, eval = FALSE}
test_1_mif = mif2(
              data = mif_sim_data,
              times = mif_sim_data$time,
              t0 = t0,
              seed = 12345,
              rprocess = pomp::euler(rproc,delta.t = 1),
              params = param_vec,
              paramnames = paramnames,
              statenames = statenames,
              obsnames = obsnames,
              dmeas = dmeas,
              accumvars = acumvarnames,
              rinit = init,
              rmeas = rmeas,
              partrans = par_trans,
              start = param_vec,
              covar = covar,
              Np = 1,
              Nmif = 1,
              tol = 0,
              cooling.fraction.50 = 0.5,
              rw.sd = rw.sd(phi_E = 0,
                            phi_U = 0,
                            phi_S = 0,
                            h_V = 0,
                            p_S = 0.02,
                            p_H_cond_S = 0.02,
                            gamma = 0.02,
                            social_distancing_start_time = 0,
                            quarantine_start_time = 0,
                            z_0 = ivp(0),
                            E_0 = ivp(0.02),
                            N_0 = ivp(0),
                            C_0 = ivp(0),
                            PCR_sens = 0,
                            b_q = 0.02,
                            b_a = 0.02,
                            b_p = 0,
                            R_0 = 0.02,
                            sigma_M = 0.02,
                            beta_w_3 = 0,
                            beta_w_2 = 0,
                            beta_w_1 = 0,
                            beta_w_0 = 0,
                            g_0 = 0,
                            g_F = 0,
                            sigma_epsilon = 0,
                            G_w_y_scaling = 0))
```

```{r}
rds_index = rds_index + 1
mif_50_rds_file_name = paste0("Stew_Files/", model_name, "_", "rds_", rds_index, ".rds")
bake(file = mif_50_rds_file_name,{
mif2(data = mif_sim_data,
              times = mif_sim_data$time,
              t0 = t0,
              seed = 12345,
              rprocess = pomp::euler(rproc,delta.t = 1),
              params = param_vec,
              paramnames = paramnames,
              statenames = statenames,
              obsnames = obsnames,
              dmeas = dmeas,
              accumvars = acumvarnames,
              rinit = init,
              rmeas = rmeas,
              partrans = par_trans,
              start = param_vec,
              covar = covar,
              Np = 2000,
              Nmif = 50,
              tol = 0,
              cooling.fraction.50 = 0.5,
              rw.sd = rw.sd(phi_E = 0,
                            phi_U = 0,
                            b_p = 0,
                            phi_S = 0,
                            h_V = 0,
                            p_S = 0.02,
                            p_H_cond_S = 0.02,
                            gamma = 0.02,
                            social_distancing_start_time = 0,
                            quarantine_start_time = 0,
                            z_0 = ivp(0),
                            E_0 = ivp(0.02),
                            N_0 = ivp(0),
                            C_0 = ivp(0),
                            PCR_sens = 0,
                            b_q = 0.02,
                            b_a = 0.02,
                            R_0 = 0.02,
                            sigma_M = 0.02,
                            beta_w_3 = 0,
                            beta_w_2 = 0,
                            beta_w_1 = 0,
                            beta_w_0 = 0,
                            g_0 = 0,
                            g_F = 0,
                            sigma_epsilon = 0,
                            G_w_y_scaling = 0)

            )}) ->test_mif
test_mif@eff.sample.size

```

## Local MIF Search (Validation)


```{r, echo = TRUE}
ptm = proc.time()
registerDoRNG(123456)
rds_index = rds_index + 1
parallel_mif_50_run_rds_file_name = paste0("Stew_Files/", model_name, "_", "rds_", rds_index, ".rds")
bake(file = parallel_mif_50_run_rds_file_name,{
  foreach(i=1:5,
          .packages = 'pomp',
          .combine = c,
          .export = c("rproc", "rmeas", "dmeas", "mif_sim_data", "init", "paramnames", "statenames", "obsnames",
                      "param_vec","par_trans", "acumvarnames")
          ) %dopar%
          {
            mif2(
              data = mif_sim_data,
              times = mif_sim_data$time,
              t0 = t0,
              rprocess = pomp::euler(rproc,delta.t = 1),
              params = param_vec,
              paramnames = paramnames,
              statenames = statenames,
              obsnames = obsnames,
              dmeas = dmeas,
              accumvars = acumvarnames,
              rinit = init,
              rmeas = rmeas,
              partrans = par_trans,
              start = param_vec,
              covar = covar,
              Np = 2000,
              Nmif = 50,
              cooling.fraction.50 = 0.5,
              rw.sd = rw.sd(phi_E = 0,
                            phi_U = 0,
                            b_p = 0,
                            phi_S = 0,
                            h_V = 0,
                            p_S = 0.02,
                            p_H_cond_S = 0.02,
                            gamma = 0.02,
                            social_distancing_start_time = 0,
                            quarantine_start_time = 0,
                            z_0 = ivp(0),
                            E_0 = ivp(0.02),
                            N_0 = ivp(0),
                            C_0 = ivp(0),
                            PCR_sens = 0,
                            b_q = 0.02,
                            b_a = 0.02,
                            R_0 = 0.02,
                            sigma_M = 0.02,
                            beta_w_3 = 0,
                            beta_w_2 = 0,
                            beta_w_1 = 0,
                            beta_w_0 = 0,
                            g_0 = 0,
                            g_F = 0,
                            sigma_epsilon = 0,
                            G_w_y_scaling = 0)
              )
          }
}) -> mifs_sim_data_local

mif_sim_local_output_file = paste0("../Generated_Data/MIF_local_test_results/", model_name, "_validation_5_mif_iterations_output.RData")
save(mifs_sim_data_local, file = mif_sim_local_output_file)
p = ggplot(data = melt(conv.rec(mifs_sim_data_local)),
           aes(x = iteration, y = value, group = L1, color = factor(L1))) +
  geom_line()+
  guides(color=FALSE)+
  facet_wrap(~variable, scales="free_y") + theme_bw()
p
mif_par_sim_fit_50_plot_file = paste0("../Figures/MIF_local_test_results/", model_name,
                                      "_test_mif_convergence_dem_stoch_plot_5_runs_50_iterations_from_sim_data_truth.png")
png(mif_par_sim_fit_50_plot_file)
print(p)
dev.off()

param_list = list()
pfilter_end_mean_list = vector(length = length(mifs_sim_data_local))
pfilter_end_se_list = vector(length = length(mifs_sim_data_local))
for(run_index in seq(1:length(mifs_sim_data_local))){
  print(run_index)
  single_mif_run_output = mifs_sim_data_local[[run_index]]
  param_list[[run_index]] = single_mif_run_output@params
  mif_test_end_par = param_list[[run_index]]


  #Get Final Pfilter Likelihood
registerDoRNG(123456)
ptm <- proc.time()
rds_index = rds_index + 1
bake(file = paste0("Stew_Files/", model_name, "_", "rds_", rds_index, ".rds"),{
  foreach(i=1:10, .packages = 'pomp',
          .export = c("rproc", "rmeas", "dmeas", "mif_sim_data", "init", "paramnames", "statenames", "obsnames",
                      "mif_test_end_par", "par_trans", "acumvarnames")
  ) %dopar% {
            pfilter(data = mif_sim_data,
                    times = mif_sim_data$time,
                    t0 = t0,
                    rprocess = pomp::euler(rproc,delta.t = 1),
                    params = mif_test_end_par,
                    paramnames = paramnames,
                    statenames = statenames,
                    obsnames = obsnames,
                    dmeas = dmeas,
                    accumvars = acumvarnames,
                    rinit = init,
                    rmeas = rmeas,
                    covar = covar,
                    partrans = par_trans,
                    format = "data.frame",
                    Np = 1000)
          }
}) ->pfilter_sim_at_mif_end
proc.time() - ptm
pfilter_sim_at_mif_end <- logmeanexp(sapply(pfilter_sim_at_mif_end, logLik), se = TRUE)
pfilter_end_mean_list[run_index] = pfilter_sim_at_mif_end[[1]]
pfilter_end_se_list[run_index] = pfilter_sim_at_mif_end[[2]]

}
#Get Pfilter Likelihood at Start
#registerDoRNG(123456)
ptm <- proc.time()
rds_index = rds_index + 1
pf_start_mif_sim_test_rds_file_name = paste0("Stew_Files/", model_name, "_", "rds_", rds_index, ".rds")
bake(file = pf_start_mif_sim_test_rds_file_name,{
  foreach(i=1:10, .packages = 'pomp',
          .export = c("rproc", "rmeas", "dmeas", "mif_sim_data", "init", "paramnames", "statenames", "obsnames",
                      "param_vec", "par_trans", "acumvarnames")
  ) %dopar% {
            pfilter(data = mif_sim_data,
                    times = mif_sim_data$time,
                    t0 = t0,
                    rprocess = pomp::euler(rproc,delta.t = 1),
                    params = param_vec,
                    paramnames = paramnames,
                    statenames = statenames,
                    obsnames = obsnames,
                    dmeas = dmeas,
                    accumvars = acumvarnames,
                    rinit = init,
                    rmeas = rmeas,
                    covar = covar,
                    partrans = par_trans,
                    format = "data.frame",
                    Np = 1000)
          }
}) ->pfilter_sim_at_mif_start
proc.time() - ptm

L_pfilter_sim_at_mif_start <- logmeanexp(sapply(pfilter_sim_at_mif_start, logLik), se = TRUE)
L_pfilter_sim_at_mif_start
true_sim_mean = L_pfilter_sim_at_mif_start[[1]]
true_sim_se = L_pfilter_sim_at_mif_start[[2]]

pfilter_5_mif_data_analysis_value_storage = list(end_mean = pfilter_end_mean_list, end_se  = pfilter_end_se_list, start_mean = true_sim_mean,
                                              start_se = true_sim_se)
pfilter_5_mif_storage_file_name = paste0("../Generated_Data/MIF_local_test_results/", model_name,
                                         "_validation_5_mif_iterations_pfitler_likelihood_ranges.RData")
save(pfilter_5_mif_data_analysis_value_storage,
     file = pfilter_5_mif_storage_file_name)
plot_data = data.frame(iterations = seq(1:length(mifs_sim_data_local)), pfilter_end_mean = pfilter_end_mean_list,
                       pfilter_end_se = pfilter_end_se_list)


p = ggplot(data = plot_data, aes(x = iterations, y = pfilter_end_mean)) +
  geom_errorbar(aes(ymin = pfilter_end_mean - pfilter_end_se,
                    ymax = pfilter_end_mean + pfilter_end_se)) + geom_hline(yintercept = true_sim_mean,
                                                                            color = 'red')+
  geom_hline(yintercept = true_sim_mean - true_sim_se, color = 'blue') +
  geom_hline(yintercept = true_sim_mean + true_sim_se, color = 'blue')
p
mif_5_run_plot_file_name = paste0("../Figures/MIF_local_test_results/", model_name,
                              "_validation_plot_pfilter_ranges_for_5_mif_runs_of_50_iterations_blue_and_red_lines_are_pfilter_start_ranges.png")
png(mif_5_run_plot_file_name)
print(p)
dev.off()


mifs_sim_data_local[[5]]@params
proc.time() - ptm

p = ggplot(data = melt(conv.rec(test_mif)),
           aes(x = iteration, y = value, group = variable, color = factor(variable))) +
  geom_line()+
  guides(color=FALSE)+
  facet_wrap(~variable, scales="free_y") + theme_bw()
p

test_mif_local_sim_results_plot_file_name = paste0("../Figures/MIF_local_test_results/", model_name,
                                                   "_test_mif_local_run_from_sim_data_true_parameters.png")
png(test_mif_local_sim_results_plot_file_name)
print(p)
dev.off()
```


## Get Final Pfilter Likelihood
```{r, echo = TRUE}
registerDoRNG(123456)
ptm <- proc.time()
rds_index = rds_index + 1
pfilter_local_mif_test_end_rds_file_name = paste0("Stew_Files/", model_name, "_", "rds_", rds_index, ".rds")
bake(file = pfilter_local_mif_test_end_rds_file_name,{
  foreach(i=1:10, .packages = 'pomp',
          .export = c("rproc", "rmeas", "dmeas", "mif_sim_data", "init", "paramnames", "statenames", "obsnames",
                      "mif_test_end_par", "par_trans", "acumvarnames")
  ) %dopar% {
            pfilter(data = mif_sim_data,
                    times = mif_sim_data$time,
                    t0 = t0,
                    rprocess = pomp::euler(rproc,delta.t =1),
                    params = mif_test_end_par,
                    paramnames = paramnames,
                    statenames = statenames,
                    obsnames = obsnames,
                    dmeas = dmeas,
                    accumvars = acumvarnames,
                    rinit = init,
                    rmeas = rmeas,
                    partrans = par_trans,
                    covar = covar,
                    tol = 0,
                    format = "data.frame",
                    Np = 1000)
          }
}) ->pfilter_sim_at_mif_end
proc.time() - ptm

(L_pfilter_sim_at_mif_end <- logmeanexp(sapply(pfilter_sim_at_mif_end, logLik), se = TRUE))
```


## Plot MIF results

```{r, echo = FALSE, eval= FALSE}
p = ggplot(data = melt(conv.rec(mifs_sim_data_local)),
           aes(x = iteration, y = value, group = variable, color = factor(variable))) +
  geom_line()+
  guides(color=FALSE)+
  facet_wrap(~variable, scales="free_y") + theme_bw()
p


##Pfilter at end
ptm <- proc.time()
pfilter_mif_sim_end_test = pfilter(data = mif_sim_data,
                             seed = 12345,
                    times = mif_sim_data$time,
                    t0 = t0,
                    rprocess = pomp::euler(rproc,delta.t = 1),
                    params = mif_test_end_par,
                    paramnames = paramnames,
                    statenames = statenames,
                    obsnames = obsnames,
                    dmeas = dmeas,
                    accumvars = acumvarnames,
                    rinit = init,
                    rmeas = rmeas,
                    covar = covar,
                    partrans = par_trans,
                    format = "data.frame",
                    tol = 0,
                    Np = 1000)
proc.time() - ptm

pfilter_true_sim_test = pfilter(data = mif_sim_data,
                             seed = 12345,
                    times = mif_sim_data$time,
                    t0 = t0,
                    rprocess = pomp::euler(rproc,delta.t = 1),
                    params = param_vec,
                    paramnames = paramnames,
                    statenames = statenames,
                    obsnames = obsnames,
                    dmeas = dmeas,
                    accumvars = acumvarnames,
                    rinit = init,
                    rmeas = rmeas,
                    covar = covar,
                    partrans = par_trans,
                    format = "data.frame",
                    tol = 0,
                    Np = 1000)
logLik(pfilter_mif_sim_end_test)
plot(pfilter_mif_sim_end_test)

logLik(pfilter_true_sim_test)
plot(pfilter_true_sim_test)


```

## Really long single MIF run
One mif run, 2000 particles, 100 iterations
```{r, echo=TRUE}
ptm = proc.time()
rds_index = rds_index + 1
mif_100_iteration_run_rds_file_name = paste0("Stew_Files/", model_name, "_", "rds_", rds_index, ".rds")
bake(file = mif_100_iteration_run_rds_file_name,{
mif2(
              data = mif_sim_data,
              times = mif_sim_data$time,
              t0 = t0,
              seed = 12345,
              rprocess = pomp::euler(rproc,delta.t = 1),
              params = param_vec,
              paramnames = paramnames,
              statenames = statenames,
              obsnames = obsnames,
              dmeas = dmeas,
              accumvars = acumvarnames,
              rinit = init,
              rmeas = rmeas,
              covar = covar,
              partrans = par_trans,
              tol = 0,
              start = param_vec,
              Np = 2000,
              Nmif = 100,
              cooling.fraction.50 = 0.5,
              rw.sd = rw.sd(phi_E = 0,
                            phi_U = 0,
                            b_p = 0,
                            phi_S = 0,
                            h_V = 0,
                            p_S = 0.02,
                            p_H_cond_S = 0.02,
                            gamma = 0.02,
                            social_distancing_start_time = 0,
                            quarantine_start_time = 0,
                            z_0 = ivp(0),
                            E_0 = ivp(0.02),
                            N_0 = ivp(0),
                            C_0 = ivp(0),
                            PCR_sens = 0,
                            b_q = 0.02,
                            b_a = 0.02,
                            R_0 = 0.02,
                            sigma_M = 0.02,
                            beta_w_3 = 0,
                            beta_w_2 = 0,
                            beta_w_1 = 0,
                            beta_w_0 = 0,
                            g_0 = 0,
                            g_F = 0,
                            sigma_epsilon = 0,
                            G_w_y_scaling = 0)
              )
            }) -> long_mif_output
proc.time() - ptm
long_mif_output@eff.sample.size

a = melt(conv.rec(long_mif_output))
p = ggplot(data = melt(conv.rec(long_mif_output)),
           aes(x = iteration, y = value, group = variable, color = factor(variable))) +
  geom_line()+
  guides(color=FALSE)+
  facet_wrap(~variable, scales="free_y") + theme_bw()
p
mif_100_run_plot_file_name = paste0("../Figures/MIF_local_test_results/",
                                    model_name,
                                    "_test_mif_convergence_dem_stoch_plot_1_run_100_iterations_from_sim_data_truth.png")
png(mif_100_run_plot_file_name)
print(p)
dev.off()

#Test pfilter likelihood at end of this simulation
mif_long_test_end_par = long_mif_output@params
registerDoRNG(123456)
ptm <- proc.time()
rds_index = rds_index + 1
pfilter_mif_sim_100_iteration_end_rds_file_name = paste0("Stew_Files/", model_name, "_", "rds_", rds_index, ".rds")
bake(file = pfilter_mif_sim_100_iteration_end_rds_file_name,{
  foreach(i=1:10, .packages = 'pomp',
          .export = c("rproc", "rmeas", "dmeas", "mif_sim_data", "init", "paramnames", "statenames", "obsnames",
                      "mif_long_test_end_par", "par_trans", "acumvarnames")
  ) %dopar% {
            pfilter(data = mif_sim_data,
                    times = mif_sim_data$time,
                    t0 = t0,
                    rprocess = pomp::euler(rproc,delta.t = 1),
                    params = mif_long_test_end_par,
                    paramnames = paramnames,
                    statenames = statenames,
                    obsnames = obsnames,
                    dmeas = dmeas,
                    accumvars = acumvarnames,
                    rinit = init,
                    tol = 0,
                    rmeas = rmeas,
                    covar = covar,
                    partrans = par_trans,
                    format = "data.frame",
                    Np = 1000)
          }
}) ->pfilter_sim_at_long_mif_end
proc.time() - ptm

(L_pfilter_sim_at_long_mif_end <- logmeanexp(sapply(pfilter_sim_at_long_mif_end, logLik), se = TRUE))
L_pfilter_sim_at_long_mif_end

Pfilter_LL_Mif_sim_100_runs_end_output_file_name  = paste0("../Generated_Data/MIF_local_test_results/", model_name,
                                                           "_validation_pfilter_ranges_100_iteration_single_MIF_run.RData")
save(L_pfilter_sim_at_long_mif_end,
     file = Pfilter_LL_Mif_sim_100_runs_end_output_file_name)
#-619.84317442    0.02631345
# This is not higher than the  true sim mean of    -619.86722850 (se 0.03028052 ), so did a longer run.
```


## 2nd really long single MIF run
One mif run, 2000 particles, 200 iterations
```{r, echo=TRUE}
ptm = proc.time()
rds_index = rds_index + 1
mif_sim_250_run_output_rds_file_name = paste0("Stew_Files/", model_name, "_", "rds_", rds_index, ".rds")
bake(file = mif_sim_250_run_output_rds_file_name,{
 mif2(
              data = mif_sim_data,
              times = mif_sim_data$time,
              t0 = t0,
              seed = 23456,
              rprocess = pomp::euler(rproc,delta.t = 1),
              params = param_vec,
              paramnames = paramnames,
              statenames = statenames,
              obsnames = obsnames,
              dmeas = dmeas,
              accumvars = acumvarnames,
              rinit = init,
              rmeas = rmeas,
              covar = covar,
              partrans = par_trans,
              start = param_vec,
              Np = 2000,
              tol = 0,
              Nmif = 250,
              cooling.fraction.50 = 0.5,
              rw.sd = rw.sd(phi_E = 0,
                            phi_U = 0,
                            b_p = 0,
                            phi_S = 0,
                            h_V = 0,
                            p_S = 0.02,
                            p_H_cond_S = 0.02,
                            gamma = 0.02,
                            social_distancing_start_time = 0,
                            quarantine_start_time = 0,
                            z_0 = ivp(0),
                            E_0 = ivp(0.02),
                            N_0 = ivp(0),
                            C_0 = ivp(0),
                            PCR_sens = 0,
                            b_q = 0.02,
                            b_a = 0.02,
                            R_0 = 0.02,
                            sigma_M = 0.02,
                            beta_w_3 = 0,
                            beta_w_2 = 0,
                            beta_w_1 = 0,
                            beta_w_0 = 0,
                            g_0 = 0,
                            g_F = 0,
                            sigma_epsilon = 0,
                            G_w_y_scaling = 0)
            ) }) -> long_mif_output_2
proc.time() - ptm
long_mif_output_2@eff.sample.size

a = melt(conv.rec(long_mif_output_2))
p = ggplot(data = melt(conv.rec(long_mif_output_2)),
           aes(x = iteration, y = value, group = variable, color = factor(variable))) +
  geom_line()+
  guides(color=FALSE)+
  facet_wrap(~variable, scales="free_y") + theme_bw()
p

MIF_sim_250_run_output_plot_file_name = paste0("../Figures/MIF_local_test_results/",
                                               model_name, "_test_mif_convergence_dem_stoch_plot_1_run_200_iterations_from_sim_data_truth.png")
png(MIF_sim_250_run_output_plot_file_name)
print(p)
dev.off()

#Test pfilter likelihood at end of this simulation
mif_long_test_end_par_2 = long_mif_output_2@params
registerDoRNG(234567)
ptm <- proc.time()
rds_index = rds_index + 1
pfilter_long_mif_sim_250_iterations_end_output_rds_file = paste0("Stew_Files/", model_name, "_", "rds_", rds_index, ".rds")
bake(file = pfilter_long_mif_sim_250_iterations_end_output_rds_file,{
  foreach(i=1:10, .packages = 'pomp',
          .export = c("rproc", "rmeas", "dmeas", "mif_sim_data", "init", "paramnames", "statenames", "obsnames", "covar",
                      "mif_long_test_end_par_2", "par_trans", "acumvarnames")
  ) %dopar% {
            pfilter(data = mif_sim_data,
                    times = mif_sim_data$time,
                    t0 = t0,
                    rprocess = pomp::euler(rproc,delta.t = 1),
                    params = mif_long_test_end_par_2,
                    paramnames = paramnames,
                    statenames = statenames,
                    obsnames = obsnames,
                    dmeas = dmeas,
                    accumvars = acumvarnames,
                    rinit = init,
                    tol = 0,
                    rmeas = rmeas,
                    covar = covar,
                    partrans = par_trans,
                    format = "data.frame",
                    Np = 1000)
          }
}) ->pfilter_sim_at_long_mif_end_2
proc.time() - ptm

(L_pfilter_sim_at_long_mif_end_2 <- logmeanexp(sapply(pfilter_sim_at_long_mif_end_2, logLik), se = TRUE))

pfilter_long_mif_sim_250_iterations_end_LL_file_name = paste0("../Generated_Data/MIF_local_test_results/", model_name, "_validation_pfilter_ranges_200_iteration_single_MIF_run.RData")
save(L_pfilter_sim_at_long_mif_end_2,
     file = pfilter_long_mif_sim_250_iterations_end_LL_file_name)
#-618.83279774  0.01847462
# This is higher than true sim mean of  -619.86722850 (se 0.03028052), so it seems to have worked (at least, this is enough to move on to a grid search using Midway).
```


# Analyze MIF Run 1
### Combine output
## Combine Midway output susbsets
Once all of the 250 array jobs submitted to Midway f have finished running on the cluster, the output from each of those 250 jobs is combined into one data frame  with combinations and likelihoods for a particular profile. For ease of computation, we only include the top 100LL of parameter combinations within each array job.

### Code for combining
```{r}

  # ---- combine_grid_search_output ----


# Header ------------------------------------------------------------------
## Name: combine_grid_search_output
## Author: Rahul Subramanian
## Description: Combine MIF real grid search output data into one big data frame

  combine_grid_search_output = function(model_name){


ptm = proc.time()


#args = commandArgs(trailingOnly=TRUE)



###Load parameter list
pd = read.csv(
  file = paste0(
    "../Generated_Data/Profile_Combination_Lists/",
    model_name,
    "_Model/",
    model_name,
    "_param_grid.csv"
  ),
  header = TRUE
)


mif_sim_combined_output_df = data.frame(
  matrix(nrow = 0, ncol = ncol(pd) + 7)
)
colnames(mif_sim_combined_output_df) = c(colnames(pd), "LL")

colnames(mif_sim_combined_output_df) = c(colnames(pd),"msg", "iter_num", "param_index", "loglik", "nfail", "trace_num",  "loglist.se")
midway_max_jobs = 500
jobs_done_so_far = 500
mif_sim_combined_output_with_traces_df = mif_sim_combined_output_df
for(param_index in seq(1:jobs_done_so_far)){
	if(param_index %% 10 == 0){
	  print(param_index)
	}


  input_file_name = paste("../Generated_Data/Profiles/",
                          model_name,
                          "_Model/",
                          "Grid_Search_MIF_run_1/",
                          model_name,
                          "_Grid_Search_MIF_run_1_subset_",
                          param_index,
                          ".RData",
                          sep = ""
                          )
  if(file.exists(input_file_name) == TRUE){
    load(file = input_file_name)
    mif_output_df_single_subset = res
  }else{
    group_size = nrow(pd)/midway_max_jobs
    start_index = (param_index-1)*group_size + 1
    end_index = param_index*group_size
    Num_mif_runs_per_start = 10
    param_data_subset_act = pd[start_index:end_index,]
    param_data_subset = param_data_subset_act[rep(seq_len(nrow(param_data_subset_act)), each = Num_mif_runs_per_start),]
    #param_data_subset$seed = NA;

    param_data_subset$msg = NA
    param_data_subset$iter_num = NA
    param_data_subset$param_index = NA
    param_data_subset$nfail = NA
    param_data_subset$trace_num = NA
    param_data_subset$loglik = NA
    param_data_subset$loglist.se = NA
    mif_output_df_single_subset = param_data_subset

  }

  #head(mif_output_df_single_subset)
  local_MLE = max(mif_output_df_single_subset$loglik, na.rm = TRUE)
  subset_traces = mif_output_df_single_subset %>%
    filter(iter_num == 3)
  subset_data_no_traces =mif_output_df_single_subset %>%
    filter(msg != "first_trace") %>%
    filter(msg != "second_trace")
  mif_sim_combined_output_with_traces_df =
    rbind(mif_sim_combined_output_with_traces_df,subset_traces)
  mif_sim_combined_output_df = rbind(mif_sim_combined_output_df, subset_data_no_traces)
}

output_file_name = paste0("../Generated_Data/Profiles/", model_name,"_Model/","Grid_Search_MIF_run_1/",
                          model_name, "_Grid_Search_MIF_run_1_combined_data_subset_including_traces_and_start.RData")

save(mif_sim_combined_output_with_traces_df, file = output_file_name)


output_file_name = paste0("../Generated_Data/Profiles/", model_name,"_Model/","Grid_Search_MIF_run_1/",
                          model_name, "_Grid_Search_MIF_run_1_combined_data.RData")

save(mif_sim_combined_output_df, file = output_file_name)

output_list = list(mif_sim_combined_output_df, mif_sim_combined_output_with_traces_df)
return(output_list)
}


  combine_grid_search_output(model_name = model_name)




```


## Analyze output
```{r}
library(GGally)

shared_params_plot1 = function(data, ..., ll= TRUE){
  if(missing(..1)){
    ae = aes(color=msg)
  } else{
    ae = aes(...)
  }

  cols = c("E_0", "z_0","R_0", "p_S", "p_H_cond_S","gamma", "b_a",
           "b_q", "b_p","sigma_M")
  collabs = c("E_0", "z_0","R_0", "p_S", "p_H_cond_S", "gamma", "b_a",
              "b_q","b_p", "sigma_M")
  if(ll) {
    cols = c(cols, "loglik")
    collabs = c(collabs, "log(L)")
  }
  data %>%
    ggpairs(mapping = ae, upper = NULL, legend = 1,
            lower = list(continuous=wrap("points", alpha = 0.5, size = 0.2)),
            diag = list(continuous = wrap("densityDiag", alpha = 0.5)),
            columns = cols, columLabels = collabs, labeller = "label_parsed") +
    theme(legend.position = "bottom", axis.text.x=element_text(angle = -90))
}

```

Plot shared parameters
```{r}
load(file = paste0("../Generated_Data/Profiles/",
       model_name,"_Model/","Grid_Search_MIF_run_1/",
       model_name,
       "_Grid_Search_MIF_run_1_combined_data_subset_including_traces_and_start.RData"))
head(mif_sim_combined_output_with_traces_df)

load(file = paste0("../Generated_Data/Profiles/", model_name,"_Model/","Grid_Search_MIF_run_1/",
                          model_name, "_Grid_Search_MIF_run_1_combined_data.RData"))
head(mif_sim_combined_output_df)
top_2_LL_params = mif_sim_combined_output_df %>%
  mutate(loglik = loglik-max(loglik, na.rm = TRUE)) %>%
  filter(is.na(loglik) | loglik>-2)
top_2_LL_params = top_2_LL_params %>%
  filter(msg == "mif1" || msg == "start")
mif_1_result_plot =  top_2_LL_params%>%
  shared_params_plot1()

png("../Figures/Profiles/N_12_Model/MIF_Run_1/MIF_Run_1_Histogram_Result_Plot.png")
print(mif_1_result_plot)
dev.off()
```

### Analyze R_0 values
```{r}
top_2_LL_end_params = top_2_LL_params %>%
  filter(msg == "mif1")
top_2_LL_end_params$R_0
min(mif_sim_combined_output_df$R_0)
mif_sim_combined_output_df_end_params = filter(mif_sim_combined_output_df) %>%
  filter(msg == "mif1")
min(mif_sim_combined_output_df_end_params$R_0)

range(top_2_LL_end_params$R_0)
hist(top_2_LL_end_params$R_0)


p = ggplot(data = top_2_LL_end_params,
           aes(x = R_0, y = loglik)) +
  geom_point() +
  rahul_man_figure_theme
p

p = ggplot(data = top_2_LL_end_params,
           aes(x = E_0, y = loglik)) +
  geom_point() +
  rahul_man_figure_theme
p

p = ggplot(data = top_2_LL_end_params,
           aes(x = E_0+z_0, y = loglik)) +
  geom_point() +
  rahul_man_figure_theme
p

p = ggplot(data = top_2_LL_end_params,
           aes(x = R_0, y = E_0+z_0)) +
  geom_point() +
  rahul_man_figure_theme
p

p = ggplot(data = top_2_LL_end_params,
           aes(x = R_0, y = p_S)) +
  geom_point() +
  rahul_man_figure_theme
p

range(top_2_LL_end_params$sigma_M)

```

### Analsyis of top 20 LL
```{r}
top_25_LL = mif_sim_combined_output_df_end_params %>%
  filter(loglik > max(loglik) - 25)
range(top_25_LL$R_0)

top_20_LL_end_params = mif_sim_combined_output_df_end_params %>%
  filter(loglik > max(loglik)-20)

top_5_LL = mif_sim_combined_output_df_end_params %>%
  filter(loglik > max(loglik) - 5)
range(top_5_LL$R_0)
range(top_5_LL$E_0)
p = ggplot(data = top_5_LL,
           aes(x = R_0, y = E_0)) +
  geom_point() + rahul_man_figure_theme
p

p = ggplot(data = top_5_LL,
           aes(x = p_S, y = R_0)) +
  geom_point() + rahul_man_figure_theme
p
```




# Evalulate model performance

## Antibody data
Anitbody data from Table 2
of 

https://www.medrxiv.org/content/10.1101/2020.06.28.20142190v1.full.pdf

(Version posted on June 29, 2020, accessed on July 4,2020).
```{r}
nyc_sentinel_antibody_obs = data.frame(Date = c("2020-03-01",
                                                "2020-03-08",
                                                "2020-03-15",
                                                "2020-03-22",
                                                "2020-03-29",
                                                "2020-04-05",
                                                "2020-04-12",
                                                "2020-04-19"),
                                       Num_Positive = c(8,
                                                        2,
                                                        8,
                                                        7,
                                                        9,
                                                        33,
                                                        27,
                                                        47),
                                       Prop_Positive = c(0.020,
                                                         0.005,
                                                         0.016,
                                                         0.017,
                                                         0.022,
                                                         0.101,
                                                         0.117,
                                                         0.193),
                                       Num_Sampled = c(402,
                                                       407,
                                                       493,
                                                       425,
                                                       412,
                                                       326,
                                                       230,
                                                       243))


nyc_sentinel_antibody_obs = nyc_sentinel_antibody_obs %>%
  mutate(Date = as.Date(Date))
write.csv(nyc_sentinel_antibody_obs,
          "../Generated_Data/raw_antibody_data_from_nyc_study.csv",
          row.names = FALSE)
p = ggplot(data = nyc_sentinel_antibody_obs,
           aes(x = Date, y = Prop_Positive)) + geom_point() +
  geom_line() + rahul_man_figure_theme
p

png("../Figures/Profiles/N_12_Model/Anitbody_data.png")
print(p)
dev.off()

```

We followed the Wilson-Brown CI method as described here:
https://www.itl.nist.gov/div898/handbook/prc/section2/prc241.htm



```{r}
#Ex:
#p = 0.1
#n = 10
#alpha = 0.05
get_Wilson_Brown_upper_CI = function(p, n, alpha){
  Z_score_upper = qnorm(p = 1-alpha/2, mean = 0, sd = 1)
  Z_score_upper_sq = Z_score_upper^2
  upper_under_sqrt = ((p*(1-p))/n) + Z_score_upper_sq/(4*n^2)
  
  UL_num = p + ((Z_score_upper_sq)/(2*n)) + Z_score_upper*sqrt(upper_under_sqrt)
  
  UL_denom = 1 + Z_score_upper_sq/n
  
  UL_bound = UL_num/UL_denom
  

  return(UL_bound)
}

get_Wilson_Brown_lower_CI = function(p, n, alpha){
   Z_score_lower = qnorm(p = alpha/2, mean = 0, sd = 1)
  Z_score_lower_sq = Z_score_lower^2
  lower_under_sqrt = ((p*(1-p))/n) + Z_score_lower_sq/(4*n^2)
  
  LL_num = p + ((Z_score_lower_sq)/(2*n)) + Z_score_lower*sqrt(lower_under_sqrt)
  LL_denom = 1 + Z_score_lower_sq/n
  
  LL_bound = LL_num/LL_denom
  return(LL_bound)
}



```


```{r}
nyc_antibody_df = nyc_sentinel_antibody_obs %>%
  mutate(times = as.numeric(Date - true_start_date),
         upper_CI = get_Wilson_Brown_upper_CI(n = Num_Sampled, p = Prop_Positive, alpha = 0.05),
         lower_CI = get_Wilson_Brown_lower_CI(n = Num_Sampled, p = Prop_Positive, alpha = 0.05))

write.csv(nyc_antibody_df,
          "../Generated_Data/antibody_data_from_nyc_study_with_RS_calc_CI.csv",
          row.names = FALSE)

p = ggplot(data = nyc_antibody_df,
           aes(x = Date, y = Prop_Positive)) + geom_ribbon(aes(ymin = lower_CI,
                                ymax = upper_CI),
                                fill = 'grey70',
                                alpha = 0.7) +
  geom_point() +
  geom_line() + rahul_man_figure_theme
p
png("../Figures/Profiles/N_12_Model/Anitbody_data_with_RS_calc_CI_dates.png")
print(p)
dev.off()

p = ggplot(data = nyc_antibody_df,
           aes(x = times, y = Prop_Positive)) + geom_ribbon(aes(ymin = lower_CI,
                                ymax = upper_CI),
                                fill = 'grey70',
                                alpha = 0.7) +
  geom_point() +
  geom_line() + rahul_man_figure_theme + xlab("Days since March 1, 2020")
p
png("../Figures/Profiles/N_12_Model/Anitbody_data_with_RS_calc_CI_days.png")
print(p)
dev.off()
```


###Load ML combination for model accross all five profiles
```{r}

MLE = mif_sim_combined_output_df %>%
  filter(msg == "mif1") %>%
  filter(loglik == max(loglik))
ML_params = MLE %>%
  dplyr::select(-param_index, -iter_num,
                -msg, -loglik, -nfail,
                -trace_num, -loglist.se)
MIF_run_1_MLE_params = ML_params
MIF_run_1_MLE_params
write.csv(MLE, file = "../Generated_Data/Profiles/N_12_Model/Grid_Search_MIF_run_1/MLE_Grid_Search_MIF_run_1_with_LL.csv",
          row.names = FALSE)

write.csv(MIF_run_1_MLE_params, file = "../Generated_Data/Profiles/N_12_Model/Grid_Search_MIF_run_1/MLE_Grid_Search_MIF_run_1.csv",
          row.names = FALSE)

small_E_0_param = top_5_LL %>%
  filter(E_0 == min(E_0))

small_E_0_param_combo = small_E_0_param %>%
  dplyr::select(-param_index, -iter_num,
                -msg, -loglik, -nfail,
                -trace_num, -loglist.se)

small_p_S_param = top_2_LL_end_params %>%
  filter(p_S == min(p_S))

small_p_S_param_combo = small_p_S_param %>%
  dplyr::select(-param_index, -iter_num,
                -msg, -loglik, -nfail,
                -trace_num, -loglist.se)

small_p_S_param

write.csv(small_p_S_param, file = "../Generated_Data/Profiles/N_12_Model/Grid_Search_MIF_run_1/small_p_S_top_2_LL_comb_with_loglik.csv",
          row.names = FALSE)

save(top_2_LL_end_params,file = paste0("../Generated_Data/Profiles/", model_name, "_Model/Grid_Search_MIF_run_1/top_2_LL_end_params.RData"))
# small_R_0_ML_params = small_R_0_MLE %>%
#   dplyr::select(-param_index, -iter_num,
#                 -msg, -loglik, -nfail,
#                 -trace_num, -loglist.se)
# small_R_0_ML_params

```

### Simulate trajectories from MLE parameters for baseline model
We simulate 100 stochastic trajectories (both process and environmental noise) from the overall MLE for the baseline model. We calculate the mean and the 2.5$\%$ and 97.5$\%$ quantile for values of the trajectories.
```{r}

##Simulation from ML
sim_data = simulate(nsim = 100,
                    seed = 12345,
                    times = Observed_data$times,
                    t0 = t0,
                    rprocess = pomp::euler(rproc,delta.t = 1),
                    params = ML_params,
                    paramnames = paramnames,
                    statenames = statenames,
                    obsnames = obsnames,
                    accumvars = acumvarnames,
                    rinit = init,
                    rmeas = rmeas,
                    partrans = par_trans,
                    covar = covar,
                    format = "data.frame")
#head(sim_data)
sim_data_median_Y = aggregate(Y ~ time, sim_data, median)
sim_data_quant = aggregate(Y ~ time, sim_data, quantile, probs = c(0.025, 0.975))
sim_data_quant$Y = as.data.frame(sim_data_quant$Y)
colnames(sim_data_quant$Y) = c("Q2.5", "Q97.5")

```

### Compare simulated trajectories with that of real data
The plots below show the real observed dengue case trajectory versus the mean and 2.5$\%$ and 97.5$\%$ quantile from the stochastic simulation of the baseline model MLE.
```{r}




comp_data = data.frame(time = sim_data_median_Y$time,
                       sim_data_median = sim_data_median_Y$Y,
                      sim_data_low_Q = sim_data_quant$Y$Q2.5,
                      sim_data_high_Q = sim_data_quant$Y$Q97.5,
                       true_data = Observed_data$Y)

comp_data_melt = melt(comp_data, id.vars = c("time", "sim_data_low_Q",
                                             "sim_data_high_Q"))




p = ggplot(data = comp_data_melt) +
  geom_ribbon(aes(x = time, ymin = sim_data_low_Q,
                  ymax = sim_data_high_Q), fill = "grey70") +
  geom_line(aes(x = time, y = value, color = variable)) +
  geom_point(aes(x = time, y = value, color = variable), size  = 3) +
  rahul_theme +
  theme_white_background +
  median_legend_lab + rahul_man_figure_theme +
   xlab("Days since March 1, 2020")+
  ylab("Observed Daily Cases")
p
png(paste0("../Figures/Profiles/", model_name,
 "_Model/MIF_Run_1/cases_over_time_simulation_from_ML_params.png"))
print(p)
dev.off()



p = ggplot(data = comp_data_melt) +
  geom_ribbon(aes(x = time, ymin = log(sim_data_low_Q),
                  ymax = log(sim_data_high_Q)), fill = "grey70") +
  geom_line(aes(x = time, y = log(value), color = variable)) +
  geom_point(aes(x = time, y = log(value), color = variable)) +
  rahul_theme +
  theme_white_background +
  median_legend_lab_with_fit_data + rahul_man_figure_theme +
   xlab("Days since March 1, 2020")+
  ylab("log(Observed Daily Cases)")
p

png(paste0("../Figures/Profiles/", model_name,
           "_Model/MIF_Run_1/log_cases_over_time_simulation_from_ML_params.png"))
print(p)
dev.off()

p = ggplot(data = comp_data_melt) +
  geom_ribbon(aes(x = time, ymin = log(sim_data_low_Q),
                  ymax = log(sim_data_high_Q)), fill = "grey70") +
  geom_line(aes(x = time, y = log(value), color = variable)) +
  geom_point(aes(x = time, y = log(value), color = variable)) +
  rahul_theme +
  theme_white_background +
  median_legend_lab_with_fit_data +rahul_man_figure_theme+
   xlab("Days since March 1, 2020")+
  ylab("log(Daily Reported Cases)")
p

```

### S over N
```{r}
sim_data$S_over_N = sim_data$S/sim_data$N

sim_data_S_over_N_median = aggregate(S_over_N ~ time, sim_data, median)
sim_data_S_over_N_quant = aggregate(S_over_N ~ time, sim_data, quantile, probs = c(0.025, 0.975))
sim_data_S_over_N_quant$S_over_N = as.data.frame(sim_data_S_over_N_quant$S_over_N)
colnames(sim_data_S_over_N_quant$S_over_N) = c("Q2.5", "Q97.5")


comp_data = data.frame(time = sim_data_S_over_N_median$time,
                       sim_data_median = sim_data_S_over_N_median$S_over_N,
                      sim_data_low_Q = sim_data_S_over_N_quant$S_over_N$Q2.5,
                      sim_data_high_Q = sim_data_S_over_N_quant$S_over_N$Q97.5)

comp_data_melt = melt(comp_data, id.vars = c("time", "sim_data_low_Q",
                                             "sim_data_high_Q"))




p = ggplot(data = comp_data_melt) +
  geom_ribbon(aes(x = time, ymin = sim_data_low_Q,
                  ymax = sim_data_high_Q), fill = "grey70") +
  geom_line(aes(x = time, y = value, color = variable)) +
  geom_point(aes(x = time, y = value, color = variable), size  = 3) +
  rahul_theme +
  theme_white_background +
  median_legend_lab + rahul_man_figure_theme +
   xlab("Days since March 1, 2020")+
  ylab("S over N")
p
png("../Figures/Profiles/N_12_Model/MLE_S_over_N.png")
print(p)
dev.off()
```

### Specific trajectories (S/N MLE parameter combination)
```{r}
select_trajectories  = filter(sim_data, .id %in% seq(from = 5, to = 10))
select_trajectories = dplyr::select(select_trajectories, time, .id, S, N)
select_trajectories = select_trajectories %>%
  mutate(S_over_N = S/N)
select_trajectories = select_trajectories %>%
  dplyr::select(-S, -N)
select_trajectories$type = "Sim"




library(RColorBrewer)
full_blue_pallete = brewer.pal(9, "Blues")
sim_traj_pallete = full_blue_pallete[9:4]
sim_traj_scale = scale_color_manual(name = "Legend", values = c( sim_traj_pallete), labels =  c("Sim_Traj_1", "Sim_Traj_2", "Sim_Traj_3", "Sim_Traj_4", "Sim_Traj_5", "Sim_Traj_6")) 
p = ggplot(data = select_trajectories,
           aes(x = time, y = S_over_N, color = .id)) + geom_point(size = 2) + geom_line(aes(group = .id)) + rahul_theme + rahul_man_figure_theme + theme_white_background +
  sim_traj_scale
p
png("../Figures/Profiles/N_12_Model/MIF_Run_1/Specific_traj_S_over_N_MLE.png")
print(p)
dev.off()
```


### R over N (MLE parameter combination)
```{r}
sim_data$R_over_N = (sim_data$R_A +sim_data$R_F + sim_data$R_H)/sim_data$N

sim_data_R_over_N_median = aggregate(R_over_N ~ time, sim_data, median)
sim_data_R_over_N_quant = aggregate(R_over_N ~ time, sim_data, quantile, probs = c(0.025, 0.975))
sim_data_R_over_N_quant$R_over_N = as.data.frame(sim_data_R_over_N_quant$R_over_N)
colnames(sim_data_R_over_N_quant$R_over_N) = c("Q2.5", "Q97.5")


comp_data = data.frame(time = sim_data_R_over_N_median$time,
                       sim_data_median = sim_data_R_over_N_median$R_over_N,
                      sim_data_low_Q = sim_data_R_over_N_quant$R_over_N$Q2.5,
                      sim_data_high_Q = sim_data_R_over_N_quant$R_over_N$Q97.5)

comp_data_melt = melt(comp_data, id.vars = c("time", "sim_data_low_Q",
                                             "sim_data_high_Q"))




p = ggplot(data = comp_data_melt) +
  geom_ribbon(aes(x = time, ymin = sim_data_low_Q,
                  ymax = sim_data_high_Q), fill = "grey70") +
  geom_line(aes(x = time, y = value, color = variable)) +
  geom_point(aes(x = time, y = value, color = variable), size  = 3) +
  rahul_theme +
  theme_white_background +
  median_legend_lab + rahul_man_figure_theme +
   xlab("Days since March 1, 2020")+
  ylab("R over N")
p
png("../Figures/Profiles/N_12_Model/MLE_param_R_over_N.png")
print(p)
dev.off()
```

### Specific trajectories (R/N MLE combination)
```{r}
select_trajectories  = filter(sim_data, .id %in% seq(from = 5, to = 10))
select_trajectories = dplyr::select(select_trajectories, time, .id, R_A,R_F, R_H, N)
select_trajectories = select_trajectories %>%
  mutate(R_over_N = (R_A + R_H + R_F)/N)
select_trajectories = select_trajectories %>%
  dplyr::select(-R_A, -R_H, -R_F, -N)
select_trajectories$type = "Sim"




library(RColorBrewer)
full_blue_pallete = brewer.pal(9, "Blues")
sim_traj_pallete = full_blue_pallete[9:4]
sim_traj_scale = scale_color_manual(name = "Legend", values = c( sim_traj_pallete), labels =  c("Sim_Traj_1", "Sim_Traj_2", "Sim_Traj_3", "Sim_Traj_4", "Sim_Traj_5", "Sim_Traj_6")) 
p = ggplot(data = select_trajectories,
           aes(x = time, y = R_over_N, color = .id)) + geom_point(size = 2) + geom_line(aes(group = .id)) + rahul_theme + rahul_man_figure_theme + theme_white_background +
  sim_traj_scale
p
png("../Figures/Profiles/N_12_Model/MIF_Run_1/Specific_traj_R_over_N_MLE_comb.png")
print(p)
dev.off()
```


### Compare R/N with anitbody data (MLE parameter combination)
```{r}
p = ggplot() +
  geom_ribbon(data = comp_data_melt,
              aes(x = time, ymin = sim_data_low_Q,
                  ymax = sim_data_high_Q), fill = "grey70") +
  geom_line(data = comp_data_melt,
            aes(x = time, y = value, color = variable)) +
  geom_point(data = comp_data_melt,
             aes(x = time, y = value, color = variable), size  = 3) +
  rahul_theme +
  theme_white_background +
  median_legend_lab + rahul_man_figure_theme +
   xlab("Days since March 1, 2020")+
  ylab("R over N") +
  geom_ribbon(data = nyc_antibody_df,aes(x = times, ymin = lower_CI,
                                ymax = upper_CI),
                                fill = 'grey70',
                                alpha = 0.7) +
  geom_point(data = nyc_antibody_df,
           aes(x = times, y = Prop_Positive), color = 'blue') +
  geom_line(data = nyc_antibody_df,
           aes(x = times, y = Prop_Positive), color = 'blue')
  
p
png("../Figures/Profiles/N_12_Model/MLE_param_R_over_N_vs_anitbody_test.png")
print(p)
dev.off()
```


### Simulate trajectories from small p_S param
We simulate 100 stochastic trajectories (both process and environmental noise) from the overall MLE for the baseline model. We calculate the mean and the 2.5$\%$ and 97.5$\%$ quantile for values of the trajectories.
```{r}

##Simulation from ML
sim_data = simulate(nsim = 100,
                    seed = 12345,
                    times = Observed_data$times,
                    t0 = t0,
                    rprocess = pomp::euler(rproc,delta.t = 1),
                    params = small_p_S_param_combo,
                    paramnames = paramnames,
                    statenames = statenames,
                    obsnames = obsnames,
                    accumvars = acumvarnames,
                    rinit = init,
                    rmeas = rmeas,
                    partrans = par_trans,
                    covar = covar,
                    format = "data.frame")
#head(sim_data)
sim_data_median_Y = aggregate(Y ~ time, sim_data, median)
sim_data_quant = aggregate(Y ~ time, sim_data, quantile, probs = c(0.025, 0.975))
sim_data_quant$Y = as.data.frame(sim_data_quant$Y)
colnames(sim_data_quant$Y) = c("Q2.5", "Q97.5")

```





### Compare simulated trajectories with that of real data
The plots below show the real observed dengue case trajectory versus the mean and 2.5$\%$ and 97.5$\%$ quantile from the stochastic simulation of the baseline model MLE.
```{r}




comp_data = data.frame(time = sim_data_median_Y$time,
                       sim_data_median = sim_data_median_Y$Y,
                      sim_data_low_Q = sim_data_quant$Y$Q2.5,
                      sim_data_high_Q = sim_data_quant$Y$Q97.5,
                       true_data = Observed_data$Y)

comp_data_melt = melt(comp_data, id.vars = c("time", "sim_data_low_Q",
                                             "sim_data_high_Q"))




p = ggplot(data = comp_data_melt) +
  geom_ribbon(aes(x = time, ymin = sim_data_low_Q,
                  ymax = sim_data_high_Q), fill = "grey70") +
  geom_line(aes(x = time, y = value, color = variable)) +
  geom_point(aes(x = time, y = value, color = variable), size  = 3) +
  rahul_theme +
  theme_white_background +
  median_legend_lab + rahul_man_figure_theme +
   xlab("Days since March 1, 2020")+
  ylab("Observed Daily Cases")
p
png(paste0("../Figures/Profiles/", model_name,
 "_Model/MIF_Run_1/cases_over_time_simulation_from_small_p_S_params.png"))
print(p)
dev.off()



p = ggplot(data = comp_data_melt) +
  geom_ribbon(aes(x = time, ymin = log(sim_data_low_Q),
                  ymax = log(sim_data_high_Q)), fill = "grey70") +
  geom_line(aes(x = time, y = log(value), color = variable)) +
  geom_point(aes(x = time, y = log(value), color = variable), size = 3) +
  rahul_theme +
  theme_white_background +
  median_legend_lab_with_fit_data + rahul_man_figure_theme +
   xlab("Days since March 1, 2020")+
  ylab("log(Observed Daily Cases)")
p

png(paste0("../Figures/Profiles/", model_name,
           "_Model/MIF_Run_1/log_cases_over_time_simulation_from_small_p_S_params.png"))
print(p)
dev.off()

p = ggplot(data = comp_data_melt) +
  geom_ribbon(aes(x = time, ymin = log(sim_data_low_Q),
                  ymax = log(sim_data_high_Q)), fill = "grey70") +
  geom_line(aes(x = time, y = log(value), color = variable)) +
  geom_point(aes(x = time, y = log(value), color = variable),
             size = 3) +
  rahul_theme +
  theme_white_background +
  median_legend_lab_with_fit_data +rahul_man_figure_theme+
   xlab("Days since March 1, 2020")+
  ylab("log(Daily Reported Cases)")
p

```



### S over N
```{r}
sim_data$S_over_N = sim_data$S/sim_data$N

sim_data_S_over_N_median = aggregate(S_over_N ~ time, sim_data, median)
sim_data_S_over_N_quant = aggregate(S_over_N ~ time, sim_data, quantile, probs = c(0.025, 0.975))
sim_data_S_over_N_quant$S_over_N = as.data.frame(sim_data_S_over_N_quant$S_over_N)
colnames(sim_data_S_over_N_quant$S_over_N) = c("Q2.5", "Q97.5")


comp_data = data.frame(time = sim_data_S_over_N_median$time,
                       sim_data_median = sim_data_S_over_N_median$S_over_N,
                      sim_data_low_Q = sim_data_S_over_N_quant$S_over_N$Q2.5,
                      sim_data_high_Q = sim_data_S_over_N_quant$S_over_N$Q97.5)

comp_data_melt = melt(comp_data, id.vars = c("time", "sim_data_low_Q",
                                             "sim_data_high_Q"))




p = ggplot(data = comp_data_melt) +
  geom_ribbon(aes(x = time, ymin = sim_data_low_Q,
                  ymax = sim_data_high_Q), fill = "grey70") +
  geom_line(aes(x = time, y = value, color = variable)) +
  geom_point(aes(x = time, y = value, color = variable), size  = 3) +
  rahul_theme +
  theme_white_background +
  median_legend_lab + rahul_man_figure_theme +
   xlab("Days since March 1, 2020")+
  ylab("S over N")
p
png("../Figures/Profiles/N_12_Model/Small_p_S_param_S_over_N.png")
print(p)
dev.off()
```

### Specific trajectories (S/N small p_s_param combination)
```{r}
select_trajectories  = filter(sim_data, .id %in% seq(from = 5, to = 10))
select_trajectories = dplyr::select(select_trajectories, time, .id, S, N)
select_trajectories = select_trajectories %>%
  mutate(S_over_N = S/N)
select_trajectories = select_trajectories %>%
  dplyr::select(-S, -N)
select_trajectories$type = "Sim"




library(RColorBrewer)
full_blue_pallete = brewer.pal(9, "Blues")
sim_traj_pallete = full_blue_pallete[9:4]
sim_traj_scale = scale_color_manual(name = "Legend", values = c( sim_traj_pallete), labels =  c("Sim_Traj_1", "Sim_Traj_2", "Sim_Traj_3", "Sim_Traj_4", "Sim_Traj_5", "Sim_Traj_6")) 
p = ggplot(data = select_trajectories,
           aes(x = time, y = S_over_N, color = .id)) + geom_point(size = 2) + geom_line(aes(group = .id)) + rahul_theme + rahul_man_figure_theme + theme_white_background +
  sim_traj_scale
p
png("../Figures/Profiles/N_12_Model/MIF_Run_1/Specific_traj_S_over_N_small_p_S_comb.png")
print(p)
dev.off()
```

### R over N (small $p_S$ parameter combination)
```{r}
sim_data$R_over_N = (sim_data$R_A +sim_data$R_F + sim_data$R_H)/sim_data$N

sim_data_R_over_N_median = aggregate(R_over_N ~ time, sim_data, median)
sim_data_R_over_N_quant = aggregate(R_over_N ~ time, sim_data, quantile, probs = c(0.025, 0.975))
sim_data_R_over_N_quant$R_over_N = as.data.frame(sim_data_R_over_N_quant$R_over_N)
colnames(sim_data_R_over_N_quant$R_over_N) = c("Q2.5", "Q97.5")


comp_data = data.frame(time = sim_data_R_over_N_median$time,
                       sim_data_median = sim_data_R_over_N_median$R_over_N,
                      sim_data_low_Q = sim_data_R_over_N_quant$R_over_N$Q2.5,
                      sim_data_high_Q = sim_data_R_over_N_quant$R_over_N$Q97.5)

comp_data_melt = melt(comp_data, id.vars = c("time", "sim_data_low_Q",
                                             "sim_data_high_Q"))




p = ggplot(data = comp_data_melt) +
  geom_ribbon(aes(x = time, ymin = sim_data_low_Q,
                  ymax = sim_data_high_Q), fill = "grey70") +
  geom_line(aes(x = time, y = value, color = variable)) +
  geom_point(aes(x = time, y = value, color = variable), size  = 3) +
  rahul_theme +
  theme_white_background +
  median_legend_lab + rahul_man_figure_theme +
   xlab("Days since March 1, 2020")+
  ylab("R over N")
p
png("../Figures/Profiles/N_12_Model/Small_p_S_param_R_over_N.png")
print(p)
dev.off()
```

### Specific trajectories (R/N small p_s_parameter combination)
```{r}
select_trajectories  = filter(sim_data, .id %in% seq(from = 5, to = 10))
select_trajectories = dplyr::select(select_trajectories, time, .id, R_A,R_F, R_H, N)
select_trajectories = select_trajectories %>%
  mutate(R_over_N = (R_A + R_H + R_F)/N)
select_trajectories = select_trajectories %>%
  dplyr::select(-R_A, -R_H, -R_F, -N)
select_trajectories$type = "Sim"




library(RColorBrewer)
full_blue_pallete = brewer.pal(9, "Blues")
sim_traj_pallete = full_blue_pallete[9:4]
sim_traj_scale = scale_color_manual(name = "Legend", values = c( sim_traj_pallete), labels =  c("Sim_Traj_1", "Sim_Traj_2", "Sim_Traj_3", "Sim_Traj_4", "Sim_Traj_5", "Sim_Traj_6")) 
p = ggplot(data = select_trajectories,
           aes(x = time, y = R_over_N, color = .id)) + geom_point(size = 2) + geom_line(aes(group = .id)) + rahul_theme + rahul_man_figure_theme + theme_white_background +
  sim_traj_scale
p
png("../Figures/Profiles/N_12_Model/MIF_Run_1/Specific_traj_R_over_N_small_p_S_comb.png")
print(p)
dev.off()
```


### Compare R/N with anitbody data (small $p_S$ parameter combination)
```{r}
p = ggplot() +
  geom_ribbon(data = comp_data_melt,
              aes(x = time, ymin = sim_data_low_Q,
                  ymax = sim_data_high_Q), fill = "grey70") +
  geom_line(data = comp_data_melt,
            aes(x = time, y = value, color = variable)) +
  geom_point(data = comp_data_melt,
             aes(x = time, y = value, color = variable), size  = 3) +
  rahul_theme +
  theme_white_background +
  median_legend_lab + rahul_man_figure_theme +
   xlab("Days since March 1, 2020")+
  ylab("R over N") +
  geom_ribbon(data = nyc_antibody_df,aes(x = times, ymin = lower_CI,
                                ymax = upper_CI),
                                fill = 'grey70',
                                alpha = 0.7) +
  geom_point(data = nyc_antibody_df,
           aes(x = times, y = Prop_Positive), color = 'blue') +
  geom_line(data = nyc_antibody_df,
           aes(x = times, y = Prop_Positive), color = 'blue')
  
p
png("../Figures/Profiles/N_12_Model/Small_p_S_param_R_over_N_vs_anitbody_test.png")
print(p)
dev.off()
```

# Top 2LL Simluation (TBD)

### Combine output subsets
```{r}
head(top_2_LL_end_params)

top_2_LL_end_with_antibody_LL =
    data.frame(matrix(nrow = 0,
                      ncol = ncol(top_2_LL_end_params) + 3))
  colnames(top_2_LL_end_with_antibody_LL) = 
    c(colnames(top_2_LL_end_params), "Antibody_Mean_LL", "Antibody_LL_SE","Median_Herd_Immunity")
  
  top_2_LL_all_combo_data = data.frame(matrix(nrow = 0, ncol = 5))
  colnames(top_2_LL_all_combo_data) = c("time", "sim_data_median ",  "sim_data_low_Q",
                               "sim_data_high_Q","combo_num")
  top_2_LL_all_combo_S_data = data.frame(matrix(nrow = 0, ncol = 5))
  colnames(top_2_LL_all_combo_S_data) = c("time", "sim_data_S_over_N_median ",  "sim_data_S_over_N_low_Q",
                                 "sim_data_S_over_N_high_Q","combo_num")
  top_2_LL_all_combo_C_Q1_data = data.frame(matrix(nrow = 0, ncol = 5))
  colnames(top_2_LL_all_combo_C_Q1_data) = c("time", "sim_data_C_Q1_median ",  "sim_data_C_Q1_low_Q",
                                    "sim_data_C_Q1_high_Q","combo_num")
  
  top_2_LL_all_combo_R_data = data.frame(matrix(nrow = 0, ncol = 5))
  colnames(top_2_LL_all_combo_R_data) = c("time", "sim_data_R_over_N_median ",  "sim_data_R_over_N_low_Q",
                                 "sim_data_R_over_N_high_Q","combo_num")
  
  
  
midway_max_jobs = 500
group_size = nrow(top_2_LL_end_params) / midway_max_jobs


for(param_index in seq(1:midway_max_jobs)){
  if(param_index %% 50 == 0){
      print(param_index)
  }
  
     load(file = paste0("../Generated_Data/Profiles/",
       model_name, "_Model/Antibody_LL_Param_Subsets/",
                   model_name, "_Model_top_2_LL_all_params_top_2_LL_subset_",
                   param_index, ".RData"))
     top_2_LL_end_with_antibody_LL = rbind(top_2_LL_end_with_antibody_LL,
        top_2_LL_end_subset_with_antibody_LL)
     
     load(
       file = paste0(
         "../Generated_Data/Profiles/",
         model_name, "_Model/C_Q1_Subsets/",model_name,
         "_Model_top_2_LL_all_params_top_2_LL_subset_",
         param_index, ".RData"))
     top_2_LL_all_combo_C_Q1_data = rbind(top_2_LL_all_combo_C_Q1_data,
                                          all_combo_C_Q1_data)
     
     load(file = paste0(
       "../Generated_Data/Profiles/",
       model_name, "_Model/R_over_N_Subsets/",
       model_name, "_Model_top_2_LL_all_params_sim_R_over_N_data_subset_",
       param_index, ".RData"
     ))
     top_2_LL_all_combo_R_data = rbind(top_2_LL_all_combo_R_data,
                                       all_combo_R_data)
     
     load(file = paste0(
       "../Generated_Data/Profiles/",
       model_name, "_Model/S_over_N_Subsets/",
       model_name, "_Model_top_2_LL_all_params_sim_S_over_N_data_subset_",
       param_index, ".RData"
       ))
     top_2_LL_all_combo_S_data = rbind(top_2_LL_all_combo_S_data,
                                       all_combo_S_data)
     
     load(file = paste0(
       "../Generated_Data/Profiles/",
       model_name, "_Model/combo_data_Subsets/",model_name,
       "_Model_top_2_LL_all_params_sim_cases_data_subset_",
       param_index, ".RData"))
     top_2_LL_all_combo_data = rbind(top_2_LL_all_combo_data,
                                     all_combo_data)
     
     
     
     
     
  
  
}

save(top_2_LL_all_combo_data,file = paste0("../Generated_Data/Profiles/",
       model_name, "_Model/top_2_LL_data/",model_name,
       "_Model_top_2_LL_all_params_sim_cases_data.RData"))

save(top_2_LL_all_combo_S_data,file = paste0("../Generated_Data/Profiles/",
       model_name, "_Model/top_2_LL_data/",model_name,
       "_Model_top_2_LL_all_params_sim_S_over_N_data.RData"))

save(top_2_LL_all_combo_R_data,file = paste0("../Generated_Data/Profiles/",
       model_name, "_Model/top_2_LL_data/",model_name,
       "_Model_top_2_LL_all_params_sim_R_over_N_data.RData"))

save(top_2_LL_all_combo_C_Q1_data,file = paste0("../Generated_Data/Profiles/",
       model_name, "_Model/top_2_LL_data/",model_name,
       "_Model_top_2_LL_all_params_sim_C_Q_1_data.RData"))

save(top_2_LL_end_with_antibody_LL,file = paste0("../Generated_Data/Profiles/",
       model_name, "_Model/top_2_LL_data/",model_name,
       "_Model_top_2_LL_all_params_with_antibody_LL.RData"))
     

     

```


## Calculate R_0 NGM for top_2_LL

\begin{equation}
R_{0_{NGM}} = \frac{\beta_P}{\phi_U} + \frac{\beta_A (1-p_S)}{\phi_S} + \frac{\beta p_S}{\phi_S} + \frac{\beta (1-p_{\text{H_cond_S}}) p_S}{\gamma}
\end{equation}

In terms of model parameters:
\begin{equation}
R_{0_{NGM}} = \frac{\beta*b_p}{\phi_U} + \frac{\beta*b_a (1-p_S)}{\phi_S} + \frac{\beta p_S}{\phi_S} + \frac{\beta (1-p_{\text{H_cond_S}}) p_S}{\gamma}
\end{equation}
```{r}
head(top_2_LL_end_with_antibody_LL)
top_2_LL_end_with_antibody_LL$duration_of_symp_1 = 1/top_2_LL_end_with_antibody_LL$phi_S
top_2_LL_end_with_antibody_LL$duration_of_symp_2 = 1/top_2_LL_end_with_antibody_LL$gamma
top_2_LL_end_with_antibody_LL =  top_2_LL_end_with_antibody_LL %>%
  mutate(duration_of_symp = duration_of_symp_1 + duration_of_symp_2)
top_2_LL_end_with_antibody_LL$gamma_total = 1/top_2_LL_end_with_antibody_LL$duration_of_symp
top_2_LL_end_with_antibody_LL = top_2_LL_end_with_antibody_LL %>%
  mutate(Beta = R_0*gamma_total)

top_2_LL_end_with_antibody_LL = top_2_LL_end_with_antibody_LL%>%
  mutate(R_0_P = (Beta*b_p)/phi_U,
         R_0_A = (Beta*b_a *(1-p_S))/phi_S,
         R_0_S_1 = (Beta*p_S)/phi_S,
         R_0_S_2 = (Beta*(1-p_H_cond_S)*p_S)/gamma)
top_2_LL_end_with_antibody_LL = top_2_LL_end_with_antibody_LL %>%
  mutate(R_0_NGM = R_0_P + R_0_A + R_0_S_1 + R_0_S_2)
p = ggplot(data = top_2_LL_end_with_antibody_LL,
           aes(x = R_0_NGM)) + 
  geom_density() +
  rahul_man_figure_theme
p
png(file = paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/", model_name,
                  "_density_plot_of_R_0_NGM_for_all_parameter_combinations_within_2LL_of_MLE_fit_to_cases.png"))
print(p)
dev.off()

p = ggplot(data = top_2_LL_end_with_antibody_LL,
           aes(x = R_0_NGM)) + 
  geom_histogram() +
  rahul_man_figure_theme
p

png(file = paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/", model_name,
                  "_histogram_of_R_0_NGM_for_all_parameter_combinations_within_2LL_of_MLE_fit_to_cases.png"))
print(p)
dev.off()

p = ggplot(data = top_2_LL_end_with_antibody_LL,
           aes(x = R_0_A,
               y = R_0_S_1 + R_0_S_2)) + 
  geom_point() +
  rahul_man_figure_theme
p

png(file = paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/", model_name,
                  "_R_0_A_vs_R_0_S_for_all_parameter_combinations_within_2LL_of_MLE_fit_to_cases.png"))
print(p)
dev.off()

p = ggplot(data = top_2_LL_end_with_antibody_LL,
           aes(x = R_0,
               y = R_0_NGM,
               color = b_a)) + 
  geom_point() +
  scale_color_viridis_c() +
  rahul_man_figure_theme
p
png(file = paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/", model_name,
                  "_R_0_vs_R_0_NGM_for_all_parameter_combinations_within_2LL_of_MLE_fit_to_cases.png"))
print(p)
dev.off()

p = ggplot(data = top_2_LL_end_with_antibody_LL,
           aes(x = R_0,
               y = R_0_S_1 + R_0_S_2)) + 
  geom_point() +
  rahul_man_figure_theme
p
png(file = paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/", model_name,
                  "_R_0_vs_R_0_S_for_all_parameter_combinations_within_2LL_of_MLE_fit_to_cases.png"))
print(p)
dev.off()


p = ggplot(data = top_2_LL_end_with_antibody_LL,
           aes(x = R_0_NGM,
               y = Antibody_Mean_LL)) + 
  geom_point() +
  rahul_man_figure_theme
p

png(file = paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/", model_name,
                  "_R_0_NGM_vs_Likelihood_with_respect_to_antibody_for_all_parameter_combinations_within_2LL_of_MLE_fit_to_cases.png"))
print(p)
dev.off()
```


```{r}
head(top_2_LL_end_with_antibody_LL)
p = ggplot(data = top_2_LL_end_with_antibody_LL,
           aes(x = p_S,
               y = Antibody_Mean_LL)) +
  geom_point() + rahul_man_figure_theme
p

png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "p_S_vs_Antibody_LL_", model_name,
           "_model_antibody_LL_from_top_2_cases_LL.png"))
print(p)
dev.off()


p = ggplot(data = top_2_LL_end_with_antibody_LL,
           aes(x = p_S,
               y = Median_Herd_Immunity)) +
  geom_point() + rahul_man_figure_theme
p

png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "p_S_vs_herd_immunity_", model_name,
           "_model_antibody_LL_from_top_2_cases_LL.png"))
print(p)
dev.off()


p = ggplot(data = top_2_LL_end_with_antibody_LL,
           aes(x = R_0,
               y = Antibody_Mean_LL)) +
  geom_point() + rahul_man_figure_theme
p

png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "R_0_vs_Antibody_LL_", model_name,
           "_model_antibody_LL_from_top_2_cases_LL.png"))
print(p)
dev.off()

p = ggplot(data = top_2_LL_end_with_antibody_LL,
           aes(x = R_0,
               y = Median_Herd_Immunity)) +
  geom_point() + rahul_man_figure_theme
p
png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "R_0_vs_herd_immunity_", model_name,
           "_model_antibody_LL_from_top_2_cases_LL.png"))
print(p)
dev.off()


p = ggplot(data = top_2_LL_end_with_antibody_LL,
           aes(x = b_a,
               y = Antibody_Mean_LL)) +
  geom_point() + rahul_man_figure_theme
p

png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "b_a_vs_Antibody_LL_", model_name,
           "_model_antibody_LL_from_top_2_cases_LL.png"))
print(p)
dev.off()

p = ggplot(data = top_2_LL_end_with_antibody_LL,
           aes(x = b_a,
               y = Median_Herd_Immunity)) +
  geom_point() + rahul_man_figure_theme
p

png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "b_a_vs_herd_immunity_", model_name,
           "_model_antibody_LL_from_top_2_cases_LL.png"))
print(p)
dev.off()


p = ggplot(data = top_2_LL_end_with_antibody_LL,
           aes(x = Median_Herd_Immunity,
               y = Antibody_Mean_LL)) +
  geom_point() + rahul_man_figure_theme
p

png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "herd_immunity_vs_Antibody_Mean_LL_", model_name,
           "_model_from_top_2_cases_LL.png"))
print(p)
dev.off()


```
# Isloate top 2LL of antibodyLL from top 2 LL of Model N_12 Initial Fit
```{r}
antibody_top_2_LL_from_grid_cases_top_2_LL = top_2_LL_end_with_antibody_LL %>%
  filter(Antibody_Mean_LL > max(Antibody_Mean_LL)-2)
nrow(antibody_top_2_LL_from_grid_cases_top_2_LL)

p = ggplot(data = antibody_top_2_LL_from_grid_cases_top_2_LL,
           aes(x = Median_Herd_Immunity,
               y = Antibody_Mean_LL)) +
  geom_point() + rahul_man_figure_theme
p

png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "herd_immunity_vs_Antibody_Mean_LL_", model_name,
           "_model_top_2_antibody_LL_from_top_2_cases_and_antibody_LL.png"))
print(p)
dev.off()


p = ggplot(data = antibody_top_2_LL_from_grid_cases_top_2_LL,
           aes(x = p_S,
               y = Antibody_Mean_LL)) +
  rahul_man_figure_theme + geom_point()
p

png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "top_2_LL_via_antibody_comp_plots/",
           "p_S_vs_antibody_LL_", model_name,
           "_model_top_2_antibody_LL_from_top_2_cases_LL.png"))
print(p)
dev.off()

p = ggplot(data = antibody_top_2_LL_from_grid_cases_top_2_LL,
           aes(x = p_S,
               y = R_0)) +
  rahul_man_figure_theme + geom_point()
p
png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "top_2_LL_via_antibody_comp_plots/",
           "p_S_vs_R_0_", model_name,
           "_model_top_2_antibody_LL_from_top_2_cases_LL.png"))
print(p)
dev.off()

p = ggplot(data = antibody_top_2_LL_from_grid_cases_top_2_LL,
           aes(x = b_a,
               y = R_0)) +
  rahul_man_figure_theme + geom_point()
p
png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "top_2_LL_via_antibody_comp_plots/",
           "b_a_vs_R_0_", model_name,
           "_model_top_2_antibody_LL_from_top_2_cases_LL.png"))
print(p)
dev.off()

p = ggplot(data = antibody_top_2_LL_from_grid_cases_top_2_LL,
           aes(x = R_0_NGM)) +
  geom_histogram() +
  rahul_man_figure_theme
p
png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "top_2_LL_via_antibody_comp_plots/",
           "R_0_NGM_histogram_", model_name,
           "_model_top_2_antibody_LL_from_top_2_cases_LL.png"))
print(p)
dev.off()

p = ggplot(data = antibody_top_2_LL_from_grid_cases_top_2_LL,
           aes(x = R_0_A,
               y = R_0_S_1 + R_0_S_2)) +
  geom_point() +
  rahul_man_figure_theme
p

png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "top_2_LL_via_antibody_comp_plots/",
           "R_0_A_vs_R_0_S_", model_name,
           "_model_top_2_antibody_LL_from_top_2_cases_LL.png"))
print(p)
dev.off()

p = ggplot(data = antibody_top_2_LL_from_grid_cases_top_2_LL,
           aes(x = R_0,
               y = R_0_NGM,
               color = b_a)) +
  geom_point(size = 5) +
  scale_color_viridis_c() +
  rahul_man_figure_theme +
  theme_white_background +
  scale_x_continuous(breaks=c(seq(2,10,1), 15, 18)) +
  scale_y_continuous(breaks=seq(2,5,1)) +
  coord_cartesian(expand = FALSE, #turn off axis expansion (padding)
                  xlim = c(1.75, 9), ylim = c(1.75, 5.25)) #manually set limits
p
png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "top_2_LL_via_antibody_comp_plots/",
           "R_0_vs_R_0_NGM_", model_name,
           "_model_top_2_antibody_LL_from_top_2_cases_LL.png"))
print(p)
dev.off()

png(paste0("../Figures/Profiles/", model_name, "_Model/Sup_Figs/",
           "R_0_vs_R_0_NGM_", model_name,
           "_model_top_2_antibody_LL_from_top_2_cases_LL.png"))
print(p)
dev.off()



p = ggplot(data = antibody_top_2_LL_from_grid_cases_top_2_LL,
           aes(x = R_0,
               y = R_0_S_1+ R_0_S_2)) +
  geom_point() +
  rahul_man_figure_theme
p
png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "top_2_LL_via_antibody_comp_plots/",
           "R_0_vs_R_0_S_", model_name,
           "_model_top_2_antibody_LL_from_top_2_cases_LL.png"))
print(p)
dev.off()

```

<!-- <!-- ### Top 2 LL Median Analysis --> -->





## R over N for top parameter combinations within 2LL when fit to antibody and case data
```{r}

params_with_data = join(top_2_LL_all_combo_R_data,
                        top_2_LL_end_with_antibody_LL)
params_with_data = join(params_with_data,
                        top_2_LL_all_combo_S_data)
params_with_data = join(params_with_data,
                        top_2_LL_all_combo_C_Q1_data)
params_with_data = join(params_with_data,
                        top_2_LL_all_combo_data)
antibody_top_2_LL_params_and_sim_data = params_with_data %>%
  filter(Antibody_Mean_LL > max(Antibody_Mean_LL)-2)


#head(params_with_data)
all_combo_data_high_Q_max = aggregate(sim_data_R_over_N_high_Q ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = max)
all_combo_data_high_Q_max = dplyr::select(all_combo_data_high_Q_max,
                                          time = time,
                                          all_combo_high_Q_max = sim_data_R_over_N_high_Q)
all_combo_data_low_Q_min = aggregate(sim_data_R_over_N_low_Q ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = min)
all_combo_data_low_Q_min = dplyr::select(all_combo_data_low_Q_min,
                                          time = time,
                                          all_combo_low_Q_min = sim_data_R_over_N_low_Q)
all_combo_data_median_max = aggregate(sim_data_R_over_N_median ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = max)

all_combo_data_median_max = dplyr::select(all_combo_data_median_max,
                                          time = time,
                                          all_combo_median_max = sim_data_R_over_N_median)

all_combo_data_median_min = aggregate(sim_data_R_over_N_median ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = min)
all_combo_data_median_min = dplyr::select(all_combo_data_median_min,
                                          time = time,
                                          all_combo_median_min = sim_data_R_over_N_median)
ML_output = antibody_top_2_LL_params_and_sim_data %>%
  filter(Antibody_Mean_LL == max(Antibody_Mean_LL))

ML_output = dplyr::select(ML_output, time = time,
                          ML_median = sim_data_R_over_N_median,
                          ML_high_Q = sim_data_R_over_N_high_Q,
                          ML_low_Q = sim_data_R_over_N_low_Q)

comp_data = join(ML_output, all_combo_data_high_Q_max)
comp_data = join(comp_data, all_combo_data_low_Q_min)
comp_data = join(comp_data, all_combo_data_median_min)
comp_data = join(comp_data, all_combo_data_median_max)

comp_data_melt = melt(comp_data, id.vars = c("time",
                                             "ML_high_Q", "ML_low_Q",
                                             "all_combo_high_Q_max",
                                             "all_combo_low_Q_min",
                                             "all_combo_median_min",
                                             "all_combo_median_max"))
ML_Q_Rib_Col_lab = "95% Simulation Quantiles \n (MLE for antibody data)"
All_combo_Med_Rib_Col_lab = "Simulation Median \n  (all 2 LL combinations (for antibody data))"
All_combo_Q_Rib_Col_lab = "95% Simulation Quantiles \n (all 2 LL combinations (for antibody data))"
comp_data_melt$ML_Q_Rib_Col = ML_Q_Rib_Col_lab
comp_data_melt$All_combo_Med_Rib_Col = All_combo_Med_Rib_Col_lab
comp_data_melt$All_combo_Q_Rib_Col = All_combo_Q_Rib_Col_lab

fill_vec = c("pink", "skyblue", "grey70")
names(fill_vec) = c(All_combo_Med_Rib_Col_lab, ML_Q_Rib_Col_lab, All_combo_Q_Rib_Col_lab)

p = ggplot() +
  geom_ribbon(data = comp_data_melt,
              aes(x = time, ymin = all_combo_low_Q_min,
                  ymax = all_combo_high_Q_max, fill = All_combo_Q_Rib_Col), inherit.aes = FALSE) +
  geom_ribbon(data = comp_data_melt,
              aes(x = time, ymin = all_combo_median_min,
                  ymax = all_combo_median_max, fill = All_combo_Med_Rib_Col), inherit.aes = FALSE) +
    geom_ribbon(data = comp_data_melt,
                aes(x = time, ymin = ML_low_Q,
                  ymax = ML_high_Q, fill = ML_Q_Rib_Col),  inherit.aes = FALSE) +
  geom_line(data = comp_data_melt,
            aes(x = time, y = value, color = variable)) +
  geom_point(data = comp_data_melt,
             aes(x = time, y = value, color = variable)) +
  rahul_theme +
  theme(legend.text = element_text(size = 12,
                             face = "bold",
                             color = "black")) +
  theme_white_background +

    scale_fill_manual(name = "Ribbon  Legend", values = fill_vec) +
  scale_color_manual(name = "Color  Legend", values = c("red"),
                                     labels =
                                       c("Simulation Median \n (MLE)"))  +
   xlab("Days since March 1 2020")+
  ylab(expression(paste(frac(R,N)))) +
  geom_ribbon(data = nyc_antibody_df,aes(x = times, ymin = lower_CI,
                                ymax = upper_CI),
                                fill = 'blue',
                                alpha = 0.5) +
  geom_point(data = nyc_antibody_df,
           aes(x = times, y = Prop_Positive), color = 'blue') +
  geom_line(data = nyc_antibody_df,
           aes(x = times, y = Prop_Positive), color = 'blue')
  
p

```

```{r}
png(paste0("../Figures/Profiles/", model_name,
 "_Model/top_2_LL_sim_plots/top_2_LL_via_antibody_comp_plots/Observed_Antibody_data_vs_Ribbon_Plot_R_over_N_over_time_simulation_from_all_params_2_LL_antibody_from_antibody_MLE_params.png"))
print(p)
dev.off()
```


## C_Q1
```{r}
all_combo_data_high_Q_max = aggregate(sim_data_C_Q1_high_Q ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = max)
all_combo_data_high_Q_max = dplyr::select(all_combo_data_high_Q_max,
                                          time = time,
                                          all_combo_high_Q_max = sim_data_C_Q1_high_Q)
all_combo_data_low_Q_min = aggregate(sim_data_C_Q1_low_Q ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = min)
all_combo_data_low_Q_min = dplyr::select(all_combo_data_low_Q_min,
                                          time = time,
                                          all_combo_low_Q_min = sim_data_C_Q1_low_Q)
all_combo_data_median_max = aggregate(sim_data_C_Q1_median ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = max)

all_combo_data_median_max = dplyr::select(all_combo_data_median_max,
                                          time = time,
                                          all_combo_median_max = sim_data_C_Q1_median)

all_combo_data_median_min = aggregate(sim_data_C_Q1_median ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = min)
all_combo_data_median_min = dplyr::select(all_combo_data_median_min,
                                          time = time,
                                          all_combo_median_min = sim_data_C_Q1_median)


ML_output = antibody_top_2_LL_params_and_sim_data %>%
  filter(Antibody_Mean_LL == max(Antibody_Mean_LL))
ML_output = dplyr::select(ML_output, time = time,
                          ML_median = sim_data_C_Q1_median,
                          ML_high_Q = sim_data_C_Q1_high_Q,
                          ML_low_Q = sim_data_C_Q1_low_Q)

comp_data = join(ML_output, all_combo_data_high_Q_max)
comp_data = join(comp_data, all_combo_data_low_Q_min)
comp_data = join(comp_data, all_combo_data_median_min)
comp_data = join(comp_data, all_combo_data_median_max)

comp_data_melt = melt(comp_data, id.vars = c("time",
                                             "ML_high_Q", "ML_low_Q",
                                             "all_combo_high_Q_max",
                                             "all_combo_low_Q_min",
                                             "all_combo_median_min",
                                             "all_combo_median_max"))
ML_Q_Rib_Col_lab = "95% Simulation Quantiles \n (MLE)"
All_combo_Med_Rib_Col_lab = "Simulation Median \n  (all 2 LL combinations)"
All_combo_Q_Rib_Col_lab = "95% Simulation Quantiles \n (all 2 LL combinations)"
comp_data_melt$ML_Q_Rib_Col = ML_Q_Rib_Col_lab
comp_data_melt$All_combo_Med_Rib_Col = All_combo_Med_Rib_Col_lab
comp_data_melt$All_combo_Q_Rib_Col = All_combo_Q_Rib_Col_lab

fill_vec = c("pink", "skyblue", "grey70")
names(fill_vec) = c(All_combo_Med_Rib_Col_lab, ML_Q_Rib_Col_lab, All_combo_Q_Rib_Col_lab)


hosp_comp_df = read.csv("../Generated_Data/hosp_comp_df.csv")

obs_hosp_df = hosp_comp_df %>%
  filter(variable == "HOSPITALIZED_COUNT") %>%
  dplyr::select(-Date, -Day_of_Week, time = times) 


p = ggplot() +
  geom_ribbon(data = comp_data_melt,
              aes(x = time, ymin = all_combo_low_Q_min,
                  ymax = all_combo_high_Q_max, fill = All_combo_Q_Rib_Col), inherit.aes = FALSE) +
  geom_ribbon(data = comp_data_melt,
              aes(x = time, ymin = all_combo_median_min,
                  ymax = all_combo_median_max, fill = All_combo_Med_Rib_Col), inherit.aes = FALSE) +
    geom_ribbon(data = comp_data_melt,
                aes(x = time, ymin = ML_low_Q,
                  ymax = ML_high_Q, fill = ML_Q_Rib_Col),  inherit.aes = FALSE) +
  geom_line(data = comp_data_melt,
            aes(x = time, y = value, color = variable)) +
  geom_point(data = comp_data_melt,
             aes(x = time, y = value, color = variable)) +
  rahul_theme +
  theme(legend.text = element_text(size = 12,
                             face = "bold",
                             color = "black")) +
  theme_white_background +
    scale_fill_manual(name = "Ribbon  Legend", values = fill_vec) +
  scale_color_manual(name = "Color  Legend", values = c("red"),
                                     labels =
                                       c("Simulation Median \n (MLE)"))  +
   xlab("Days since March 1 2020")+
  ylab(expression(paste(C_Q1))) +
  geom_point(data = obs_hosp_df, aes(x = time, y = value), color = 'blue') +
  geom_line(data = obs_hosp_df, aes(x = time, y = value), color = 'blue') 
p

```

```{r}
png(paste0("../Figures/Profiles/", model_name,
 "_Model/top_2_LL_sim_plots/top_2_LL_via_antibody_comp_plots/Obs_COVID_hosp_cases_vs_Ribbon_Plot_C_Q1_over_time_simulation_from_all_params_2_LL_antibody_from_antibody_MLE_params.png"))
print(p)
dev.off()
```


## Compare to observed data
```{r}
#all_combo_melt_data = melt(all_combo_data, id.vars = c("time", "combo_num"))

all_combo_data_high_Q_max = aggregate(sim_data_high_Q ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = max)
all_combo_data_high_Q_max = dplyr::select(all_combo_data_high_Q_max,
                                          time = time,
                                          all_combo_high_Q_max = sim_data_high_Q)
all_combo_data_low_Q_min = aggregate(sim_data_low_Q ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = min)
all_combo_data_low_Q_min = dplyr::select(all_combo_data_low_Q_min,
                                          time = time,
                                          all_combo_low_Q_min = sim_data_low_Q)
all_combo_data_median_max = aggregate(sim_data_median ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = max)

all_combo_data_median_max = dplyr::select(all_combo_data_median_max,
                                          time = time,
                                          all_combo_median_max = sim_data_median)

all_combo_data_median_min = aggregate(sim_data_median ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = min)
all_combo_data_median_min = dplyr::select(all_combo_data_median_min,
                                          time = time,
                                          all_combo_median_min = sim_data_median)


ML_output = antibody_top_2_LL_params_and_sim_data %>%
  filter(Antibody_Mean_LL == max(Antibody_Mean_LL))

ML_output = dplyr::select(ML_output, time = time,
                          ML_median = sim_data_median,
                          ML_high_Q = sim_data_high_Q,
                          ML_low_Q = sim_data_low_Q)

comp_data = join(ML_output, all_combo_data_high_Q_max)



## Joining by: time

comp_data = join(comp_data, all_combo_data_low_Q_min)

## Joining by: time

comp_data = join(comp_data, all_combo_data_median_min)

## Joining by: time

comp_data = join(comp_data, all_combo_data_median_max)

## Joining by: time

true_data = dplyr::select(Observed_data, time = times,
                          Observed_Data = Y)
comp_data = join(comp_data, true_data)

## Joining by: time



comp_data_melt = melt(comp_data, id.vars = c("time",
                                             "ML_high_Q", "ML_low_Q",
                                             "all_combo_high_Q_max",
                                             "all_combo_low_Q_min",
                                             "all_combo_median_min",
                                             "all_combo_median_max"))





comp_data_melt$ML_Q_Rib_Col = "95% Simulation Quantiles \n (MLE)"
comp_data_melt$All_combo_Med_Rib_Col = "Simulation Median \n  (all 2 LL combinations)"
comp_data_melt$All_combo_Q_Rib_Col = "95% Simulation Quantiles \n (all 2 LL combinations)"

fill_vec = c("Simulation Median \n  (all 2 LL combinations)" = "pink", "95% Simulation Quantiles \n (MLE)" = "skyblue", "95% Simulation Quantiles \n (all 2 LL combinations)" = "grey70")

p = ggplot(data = comp_data_melt) +
  geom_ribbon(aes(x = time, ymin = all_combo_low_Q_min,
                  ymax = all_combo_high_Q_max, fill = All_combo_Q_Rib_Col), inherit.aes = FALSE) +
  geom_ribbon(aes(x = time, ymin = ML_low_Q,
                  ymax = ML_high_Q, fill = ML_Q_Rib_Col),  inherit.aes = FALSE) +
  geom_ribbon(aes(x = time, ymin = all_combo_median_min,
                  ymax = all_combo_median_max, fill = All_combo_Med_Rib_Col), inherit.aes = FALSE) +
  geom_line(aes(x = time, y = value, color = variable)) +
  geom_point(aes(x = time, y = value, color = variable)) +
  rahul_theme +
  theme(legend.text = element_text(size = 12,
                             face = "bold",
                             color = "black")) +
  theme_white_background +

    scale_fill_manual(name = "Ribbon  Legend", values = fill_vec) +
  scale_color_manual(name = "Color  Legend", values = c("red","blue"),
                                     labels =
                                       c("Simulation Median \n (MLE)",
                                         "Observed",
                                         "Data Used For Fitting"))  +
   xlab("Days since March 1 2020")+
  ylab("Observed Monthly Cases")
p

```

```{r}
png(paste0("../Figures/Profiles/", model_name,
 "_Model/top_2_LL_sim_plots/top_2_LL_via_antibody_comp_plots/Obs_daily_COVID_cases_vs_Ribbon_Plot_simulated_cases_over_time_simulation_from_all_params_2_LL_antibody_from_antibody_MLE_params.png"))
print(p)
dev.off()
```


```{r}
p = ggplot(data = comp_data_melt) +
  geom_ribbon(aes(x = time, ymin = log(all_combo_low_Q_min),
                  ymax = log(all_combo_high_Q_max), fill = All_combo_Q_Rib_Col), inherit.aes = FALSE) +
  geom_ribbon(aes(x = time, ymin = log(ML_low_Q),
                  ymax = log(ML_high_Q), fill = ML_Q_Rib_Col),  inherit.aes = FALSE) +
  geom_ribbon(aes(x = time, ymin = log(all_combo_median_min),
                  ymax = log(all_combo_median_max), fill = All_combo_Med_Rib_Col), inherit.aes = FALSE) +
  geom_line(aes(x = time, y = log(value), color = variable)) +
  geom_point(aes(x = time, y = log(value), color = variable)) +
  rahul_theme +
  theme(legend.text = element_text(size = 12,
                             face = "bold",
                             color = "black")) +
  theme_white_background +

    scale_fill_manual(name = "Ribbon  Legend", values = fill_vec) +
  scale_color_manual(name = "Color  Legend", values = c("red","blue"),
                                     labels =
                                       c("Simulation Median \n (MLE)",
                                         "Observed",
                                         "Data Used For Fitting"))  +
   xlab("Days since March 1 2020")+
  ylab("Observed Monthly Cases")
p
```

```{r}
png(paste0("../Figures/Profiles/", model_name,
 "_Model/top_2_LL_sim_plots/top_2_LL_via_antibody_comp_plots/log_Obs_daily_COVID_cases_vs_Ribbon_Plot_simulated_cases_over_time_simulation_from_all_params_2_LL_antibody_from_antibody_MLE_params.png"))
print(p)
dev.off()
```
## Write MLE
```{r}
head(MLE)
head(ML_params)
write.csv(ML_params,
          file = "../Generated_Data/Profiles/N_12_Model/Grid_Search_MIF_run_1/ML_param_combination.csv", row.names = FALSE)

write.csv(MLE,
          file = "../Generated_Data/Profiles/N_12_Model/Grid_Search_MIF_run_1/MLE_param_combination_with_LL.csv", row.names = FALSE)
```

### Get param grid box for profiles
```{r}
#head(top_20_LL_end_params)


top_20_LL_box = top_20_LL_end_params %>%
  filter(loglist.se < 2) %>%
  sapply(range)
write.csv(top_20_LL_box, file = "../Generated_Data/Profile_Combination_Lists/N_12_Model/orignal_20_LL_param_box_from_1st_MIF_run.csv",
          row.names = FALSE)
```

### Combine output from profiles
```{r}

  # ---- combine_profile_output ----


# Header ------------------------------------------------------------------
## Name: combine_profile_output.R
## Author: Rahul Subramanian
## Description: Combine MIF real profile output data into one big data frame

  combine_profile_output = function(profile_var, model_name){


ptm = proc.time()


#profile_var = "I_S_0"
#args = commandArgs(trailingOnly=TRUE)

#profile_var = as.character(args[1])
print(profile_var)

###Load parameter list
pd = read.csv(file = paste0("../Generated_Data/Profile_Combination_Lists/",
                            model_name,"_Model/",profile_var,"_",
                            model_name,
                            "_profile_combination_list.csv"),
              header = TRUE)
#head(pd)


mif_sim_combined_output_df = data.frame(
  matrix(nrow = 0, ncol = ncol(pd) + 7)
)
colnames(mif_sim_combined_output_df) = c(colnames(pd), "LL")

colnames(mif_sim_combined_output_df) = c(colnames(pd),"msg", "iter_num", "param_index", "loglik", "nfail", "trace_num",  "loglist.se")
midway_max_jobs = 500


for(param_index in seq(1:midway_max_jobs)){
		#print(param_index)

  input_file_name = paste0("../Generated_Data/Profiles/", model_name,
                           "_Model/",profile_var,"_Profile/Subset_Outputs/",profile_var,
                           "_", model_name,
                           "_Profile_subset_",param_index,".RData")
  if(file.exists(input_file_name) == TRUE){
    load(file = input_file_name)
    mif_output_df_single_subset = res
  }else{
    group_size = nrow(pd)/midway_max_jobs
    start_index = (param_index-1)*group_size + 1
    end_index = param_index*group_size
    Num_mif_runs_per_start = 1
    param_data_subset_act = pd[start_index:end_index,]
    param_data_subset = param_data_subset_act[rep(seq_len(nrow(param_data_subset_act)), each = Num_mif_runs_per_start),]
    #param_data_subset$seed = NA;

    param_data_subset$msg = NA
    param_data_subset$iter_num = NA
    param_data_subset$param_index = NA
    param_data_subset$nfail = NA
    param_data_subset$trace_num = NA
    param_data_subset$loglik = NA
    param_data_subset$loglist.se = NA
    mif_output_df_single_subset = param_data_subset

  }

  #head(mif_output_df_single_subset)
  mif_sim_combined_output_df = rbind(mif_sim_combined_output_df, mif_output_df_single_subset)
}

output_file_name = paste0("../Generated_Data/Profiles/", model_name,"_Model/", profile_var, "_Profile/",
                          profile_var, "_", model_name, "_profile_combined_data_including_traces_and_start.RData")

save(mif_sim_combined_output_df, file = output_file_name)

profile_data_no_traces_or_start = filter(mif_sim_combined_output_df,
                                         msg == "mif1")

output_file_name = paste0("../Generated_Data/Profiles/", model_name,"_Model/", profile_var, "_Profile/",
                          profile_var, "_", model_name, "_profile_combined_data.csv")
write.csv(profile_data_no_traces_or_start, file = output_file_name, row.names=FALSE,na="")
}

combine_profile_output(profile_var = "G_w_y_scaling", model_name = model_name)

# combine_profile_output(profile_var = "z_0", model_name = model_name)
# combine_profile_output(profile_var = "E_0", model_name = model_name)
# combine_profile_output(profile_var = "R_0", model_name = model_name)
combine_profile_output(profile_var = "b_a", model_name = model_name)
# combine_profile_output(profile_var = "b_e", model_name = model_name)
# combine_profile_output(profile_var = "b_q", model_name = model_name)
# combine_profile_output(profile_var = "p_S", model_name = model_name)
# combine_profile_output(profile_var = "p_H_cond_S", model_name = model_name)
# combine_profile_output(profile_var = "gamma", model_name = model_name)
# combine_profile_output(profile_var = "sigma_M", model_name = model_name)


```

# Plot profiles
For each profile, three plots are generated. The first plot("all_clean_data_points") shows the likelihoods of every MIF run conducted for that profile. The second plot is the actual plot of the profile. For the second plot, only the maximum likelihood of each profiled parameter value is shown on the plot. The third plot is a "zoom-in" of the region near the MLE, only showing combinations within 20 log-likelihood units of the MLE. On all three plots, red horizontal lines denote likelihood values 20 log-likelihood units below the profile MLE, while blue horizontal lines denote likelihood values 2 log-likelihood units below the MLE.

## Plotting function
```{r}
plot_profiles = function(profile_var, model_name){

#Load results
profile_data = read.csv(file = paste0("../Generated_Data/Profiles/", model_name, "_Model/", profile_var, "_Profile/",
                          profile_var, "_", model_name, "_profile_combined_data.csv"))
#head(profile_data)

na_data = filter(profile_data, is.na(loglik) == TRUE)
print(paste("There are ", nrow(na_data), " entries with NA likelihoods"))

profile_data_clean = filter(profile_data, is.na(loglik) == FALSE)


ML = max(profile_data_clean$loglik)
cutoff_thres_20_LL_from_ML = ML - 20



p = ggplot(data = profile_data_clean, aes_string(x = eval(profile_var), y = "loglik")) + geom_point() + geom_hline(yintercept = cutoff_thres_20_LL_from_ML,
                                                                                                               color = 'red')+
  rahul_theme
print(p)
png(paste0("../Figures/Profiles/", model_name, "_Model/", profile_var, "_Profile/all_clean_data_points_",
           profile_var,"_", model_name, "_profile.png"))
print(p)
dev.off()

cutoff_thres_2_LL_from_ML = ML - 2




### Take trace of profile (max at each value of profile variable)
profile_var_profile = aggregate(formula(paste0("loglik ~ ",eval(profile_var))), profile_data_clean, max)
#head(profile_var_profile)
p = ggplot(data = profile_var_profile, aes_string(x = eval(profile_var), y = "loglik")) +
  geom_point(size = 3) + geom_hline(yintercept = cutoff_thres_20_LL_from_ML, color = 'red') + rahul_theme
print(p)
png(paste0("../Figures/Profiles/", model_name, "_Model/", profile_var, "_Profile/full_",
           profile_var, "_", model_name, "_profile.png"))
print(p)
dev.off()


top_20_LL_units = filter(profile_var_profile, loglik > cutoff_thres_20_LL_from_ML)

p = ggplot(data = top_20_LL_units, aes_string(x = eval(profile_var), y = "loglik")) +
  geom_point() + geom_hline(yintercept = cutoff_thres_2_LL_from_ML,color = 'blue') +
  rahul_theme + theme_white_background +
  ylab("Log Likelihood")


if(profile_var == "G_w_y_scaling"){
  p = p + xlab("s")
}

print(p)

png(paste0("../Figures/Profiles/", model_name, "_Model/", profile_var, "_Profile/20_LL_from_ML_",
           profile_var, "_", model_name, "_profile.png"))
print(p)
dev.off()
}
```

## $b_a$ Profile

```{r}
plot_profiles(profile_var = "b_a", model_name = model_name)
```

## $G_w_y_scaling$ Profile

```{r}
plot_profiles(profile_var = "G_w_y_scaling", model_name = model_name)
```
# ```{r}
# plot_profiles(profile_var = "R_0", model_name = model_name)
# ```

# ```{r}
# plot_profiles(profile_var = "E_0", model_name = model_name)
# ```


```{r}
profile_var = "G_w_y_scaling"
profile_data= read.csv(file = paste0("../Generated_Data/Profiles/", model_name, "_Model/", profile_var, "_Profile/",
                          profile_var, "_", model_name, "_profile_combined_data.csv"))
profile_peak_data_G_w_y_scaling = profile_data %>%
  filter(loglik > max(loglik)-2)
range(profile_peak_data_G_w_y_scaling$R_0)
save(profile_peak_data_G_w_y_scaling, file = paste0("../Generated_Data/Profiles/",
     model_name,
     "_Model/G_w_y_scaling_Profile/top_2_LL_of_G_w_y_scaling_profile.RData"))
profile_peak_data_5LL = profile_data %>%
  filter(loglik > max(loglik)-5)
range(profile_peak_data_5LL$R_0)
```


```{r}
profile_var = "b_a"
profile_data= read.csv(file = paste0("../Generated_Data/Profiles/", model_name, "_Model/", profile_var, "_Profile/",
                          profile_var, "_", model_name, "_profile_combined_data.csv"))
profile_peak_data_b_a = profile_data %>%
  filter(loglik > max(loglik)-2)
range(profile_peak_data_b_a$R_0)
save(profile_peak_data_b_a, file = paste0("../Generated_Data/Profiles/",
     model_name,
     "_Model/b_a_Profile/top_2_LL_of_b_a_profile.RData"))
profile_peak_data = profile_data %>%
  filter(loglik > max(loglik)-5)
range(profile_peak_data$R_0)

p = ggplot(data = profile_peak_data,
           aes(x = G_w_y_scaling,
               y = R_0)) + 
  geom_point() +
  rahul_theme 
p
p = ggplot(data = profile_peak_data,
           aes(x = G_w_y_scaling,
               y = p_S)) + 
  geom_point() +
  rahul_theme 
p

```


```{r}
p = ggplot(data = profile_peak_data,
           aes(x = b_a,
               y = b_p,
               color = p_S < .15)) + 
  geom_point() +
  rahul_theme 
p

p = ggplot(data = profile_peak_data,
           aes(x = b_a,
               y = p_S)) + 
  geom_point() +
  rahul_theme
p

p = ggplot(data = profile_peak_data,
           aes(x = R_0,
               y = p_S)) + 
  geom_point() +
  rahul_theme
p


p = ggplot(data = profile_peak_data,
           aes(x = p_S,
               y = log(R_0))) + 
  geom_point() + geom_hline(yintercept = log(3), color = 'orange') +
    geom_hline(yintercept = log(4), color = 'purple') +
  rahul_theme
p
range(profile_peak_data$p_S)

png("../Figures/Profiles/N_12_Model/b_a_Profile/p_S_vs_log_R_0_b_a_Profile_data.png")
print(p)
dev.off()

p = ggplot(data = profile_peak_data,
           aes(x = b_a,
               y = log(R_0))) + 
  geom_point() + geom_hline(yintercept = log(3), color = 'orange') +
  geom_hline(yintercept = log(4), color = 'purple') +
  rahul_theme
p
png("../Figures/Profiles/N_12_Model/b_a_Profile/b_a_vs_log_R_0_b_a_Profile_data.png")
print(p)
dev.off()

small_R_0_profile_peak_params = profile_peak_data %>%
  filter(R_0 <= 3)
range(small_R_0_profile_peak_params$p_S)

```



## Plot Antibody LL for Profile Peaks

### b_a profile peak
```{r}
source("Sim_b_a_profile_peak_Model_N_12.R")
```
## R over N for top parameter combinations within 2LL when fit to antibody and case data (b_a Profile)
```{r}

params_with_data = join(all_combo_R_data,
                        top_2_LL_end_subset_with_antibody_LL)
params_with_data = join(params_with_data,
                        all_combo_S_data)
params_with_data = join(params_with_data,
                        all_combo_C_Q1_data)
params_with_data = join(params_with_data,
                        all_combo_data)
antibody_top_2_LL_params_and_sim_data = params_with_data %>%
  filter(Antibody_Mean_LL > max(Antibody_Mean_LL)-2)


#head(params_with_data)
all_combo_data_high_Q_max = aggregate(sim_data_R_over_N_high_Q ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = max)
all_combo_data_high_Q_max = dplyr::select(all_combo_data_high_Q_max,
                                          time = time,
                                          all_combo_high_Q_max = sim_data_R_over_N_high_Q)
all_combo_data_low_Q_min = aggregate(sim_data_R_over_N_low_Q ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = min)
all_combo_data_low_Q_min = dplyr::select(all_combo_data_low_Q_min,
                                          time = time,
                                          all_combo_low_Q_min = sim_data_R_over_N_low_Q)
all_combo_data_median_max = aggregate(sim_data_R_over_N_median ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = max)

all_combo_data_median_max = dplyr::select(all_combo_data_median_max,
                                          time = time,
                                          all_combo_median_max = sim_data_R_over_N_median)

all_combo_data_median_min = aggregate(sim_data_R_over_N_median ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = min)
all_combo_data_median_min = dplyr::select(all_combo_data_median_min,
                                          time = time,
                                          all_combo_median_min = sim_data_R_over_N_median)
ML_output = antibody_top_2_LL_params_and_sim_data %>%
  filter(Antibody_Mean_LL == max(Antibody_Mean_LL))

ML_output = dplyr::select(ML_output, time = time,
                          ML_median = sim_data_R_over_N_median,
                          ML_high_Q = sim_data_R_over_N_high_Q,
                          ML_low_Q = sim_data_R_over_N_low_Q)

comp_data = join(ML_output, all_combo_data_high_Q_max)
comp_data = join(comp_data, all_combo_data_low_Q_min)
comp_data = join(comp_data, all_combo_data_median_min)
comp_data = join(comp_data, all_combo_data_median_max)
nyc_antibody_df = nyc_antibody_df %>%
  filter(time > 0)
comp_data = comp_data %>%
  filter(time <= max(nyc_antibody_df$time)) %>%
  filter(time >= min(nyc_antibody_df$time))


comp_data_melt = melt(comp_data, id.vars = c("time",
                                             "ML_high_Q", "ML_low_Q",
                                             "all_combo_high_Q_max",
                                             "all_combo_low_Q_min",
                                             "all_combo_median_min",
                                             "all_combo_median_max"))
ML_Q_Rib_Col_lab = "95% Simulation Quantiles \n (MLE for antibody data)"
All_combo_Med_Rib_Col_lab = "Simulation Median \n  (all 2 LL combinations (for antibody data))"
All_combo_Q_Rib_Col_lab = "95% Simulation Quantiles \n (all 2 LL combinations (for antibody data))"
comp_data_melt$ML_Q_Rib_Col = ML_Q_Rib_Col_lab
comp_data_melt$All_combo_Med_Rib_Col = All_combo_Med_Rib_Col_lab
comp_data_melt$All_combo_Q_Rib_Col = All_combo_Q_Rib_Col_lab

fill_vec = c("pink", "skyblue", "red")
names(fill_vec) = c(All_combo_Med_Rib_Col_lab, ML_Q_Rib_Col_lab, All_combo_Q_Rib_Col_lab)

p = ggplot() +
  geom_ribbon(data = comp_data_melt,
              aes(x = time, ymin = all_combo_low_Q_min,
                  ymax = all_combo_high_Q_max, fill = All_combo_Q_Rib_Col,
                  alpha = 0.5), inherit.aes = FALSE) +
  # geom_ribbon(data = comp_data_melt,
  #             aes(x = time, ymin = all_combo_median_min,
  #                 ymax = all_combo_median_max, fill = All_combo_Med_Rib_Col), inherit.aes = FALSE) +
  #   geom_ribbon(data = comp_data_melt,
  #               aes(x = time, ymin = ML_low_Q,
  #                 ymax = ML_high_Q, fill = ML_Q_Rib_Col),  inherit.aes = FALSE) +
  geom_line(data = comp_data_melt,
            aes(x = time, y = value, color = variable)) +
  geom_point(data = comp_data_melt,
             aes(x = time, y = value, color = variable)) +
  rahul_theme +
  theme(legend.text = element_text(size = 12,
                             face = "bold",
                             color = "black")) +
  theme_white_background +

    scale_fill_manual(name = "Ribbon  Legend", values = fill_vec) +
  scale_color_manual(name = "Color  Legend", values = c("red"),
                                     labels =
                                       c("Simulation Median \n (MLE)"))  +
   xlab("Days since March 1 2020")+
  ylab(expression(paste(frac(R,N)))) +
  geom_ribbon(data = nyc_antibody_df,aes(x = times, ymin = lower_CI,
                                ymax = upper_CI),
                                fill = 'blue',
                                alpha = 0.5) +
  geom_point(data = nyc_antibody_df,
           aes(x = times, y = Prop_Positive), color = 'blue') +
  geom_line(data = nyc_antibody_df,
           aes(x = times, y = Prop_Positive), color = 'blue') +
  theme(legend.position = "None") +
  theme(axis.title.x = element_text(face = "plain", size = 24),
        axis.title.y = element_text(face = "plain", size = 24)) +
  theme(axis.line = element_line(colour = 'black', size = 1))+
  theme(axis.ticks = element_line(colour = "black", size = 1.5)) +
  theme(axis.text.x = element_text(size=21)) +
  theme(axis.text.y = element_text(size=21))

  # xlab("")+
  # ylab("")
  
p

```

```{r}
png(paste0("../Figures/Profiles/", model_name,
 "_Model/top_2_LL_sim_plots/top_2_LL_via_antibody_comp_plots/b_a_profile_Observed_Antibody_data_vs_Ribbon_Plot_R_over_N_over_time_simulation_from_b_a_profile__2_LL_antibody_from_antibody_b_a_profile_peak_params.png"))
print(p)
dev.off()
```

```{r}
png(paste0("../Figures/Profiles/", model_name,
 "_Model/Man_Figs/b_a_profile_Observed_Antibody_data_vs_Ribbon_Plot_R_over_N_over_time_simulation_from_b_a_profile__2_LL_antibody_from_antibody_b_a_profile_peak_params.png"))
print(p)
dev.off()

pdf(paste0("../Figures/Profiles/", model_name,
 "_Model/Man_Figs/b_a_profile_Observed_Antibody_data_vs_Ribbon_Plot_R_over_N_over_time_simulation_from_b_a_profile__2_LL_antibody_from_antibody_b_a_profile_peak_params.pdf"))
print(p)
dev.off()

p = ggplot() +
  geom_ribbon(data = comp_data_melt,
              aes(x = time, ymin = all_combo_low_Q_min,
                  ymax = all_combo_high_Q_max, fill = All_combo_Q_Rib_Col,
                  alpha = 0.5), inherit.aes = FALSE) +
  # geom_ribbon(data = comp_data_melt,
  #             aes(x = time, ymin = all_combo_median_min,
  #                 ymax = all_combo_median_max, fill = All_combo_Med_Rib_Col), inherit.aes = FALSE) +
  #   geom_ribbon(data = comp_data_melt,
  #               aes(x = time, ymin = ML_low_Q,
  #                 ymax = ML_high_Q, fill = ML_Q_Rib_Col),  inherit.aes = FALSE) +
  geom_line(data = comp_data_melt,
            aes(x = time, y = value, color = variable)) +
  geom_point(data = comp_data_melt,
             aes(x = time, y = value, color = variable)) +
  rahul_theme +
  theme(legend.text = element_text(size = 12,
                             face = "bold",
                             color = "black")) +
  theme_white_background +

    scale_fill_manual(name = "Ribbon  Legend", values = fill_vec) +
  scale_color_manual(name = "Color  Legend", values = c("red"),
                                     labels =
                                       c("Simulation Median \n (MLE)"))  +
   xlab("Days since March 1 2020")+
  ylab(expression(paste(frac(R,N)))) +
  geom_ribbon(data = nyc_antibody_df,aes(x = times, ymin = lower_CI,
                                ymax = upper_CI),
                                fill = 'blue',
                                alpha = 0.5) +
  geom_point(data = nyc_antibody_df,
           aes(x = times, y = Prop_Positive), color = 'blue') +
  geom_line(data = nyc_antibody_df,
           aes(x = times, y = Prop_Positive), color = 'blue') +
  theme(legend.position = "None") +
  theme(axis.title.x = element_text(face = "plain"),
        axis.title.y = element_text(face = "plain"))  +
  xlab("")+
  ylab("") +
  theme(axis.line = element_line(colour = 'black', size = 1))+
  theme(axis.ticks = element_line(colour = "black", size = 1.5))
  
p

png(paste0("../Figures/Profiles/", model_name,
 "_Model/Man_Figs/b_a_profile_Observed_Antibody_data_vs_Ribbon_Plot_R_over_N_over_time_simulation_from_b_a_profile__2_LL_antibody_from_antibody_b_a_profile_peak_params_no_labs.png"))
print(p)
dev.off()

```


## C_Q1 (b_a Profile)
### Top 2LL via cases data
```{r}
all_combo_data_high_Q_max = aggregate(sim_data_C_Q1_high_Q ~ time, params_with_data,
                               FUN = max)
all_combo_data_high_Q_max = dplyr::select(all_combo_data_high_Q_max,
                                          time = time,
                                          all_combo_high_Q_max = sim_data_C_Q1_high_Q)
all_combo_data_low_Q_min = aggregate(sim_data_C_Q1_low_Q ~ time, params_with_data,
                               FUN = min)
all_combo_data_low_Q_min = dplyr::select(all_combo_data_low_Q_min,
                                          time = time,
                                          all_combo_low_Q_min = sim_data_C_Q1_low_Q)
all_combo_data_median_max = aggregate(sim_data_C_Q1_median ~ time, params_with_data,
                               FUN = max)

all_combo_data_median_max = dplyr::select(all_combo_data_median_max,
                                          time = time,
                                          all_combo_median_max = sim_data_C_Q1_median)

all_combo_data_median_min = aggregate(sim_data_C_Q1_median ~ time, params_with_data,
                               FUN = min)
all_combo_data_median_min = dplyr::select(all_combo_data_median_min,
                                          time = time,
                                          all_combo_median_min = sim_data_C_Q1_median)


ML_output = antibody_top_2_LL_params_and_sim_data %>%
  filter(Antibody_Mean_LL == max(Antibody_Mean_LL))
ML_output = dplyr::select(ML_output, time = time,
                          ML_median = sim_data_C_Q1_median,
                          ML_high_Q = sim_data_C_Q1_high_Q,
                          ML_low_Q = sim_data_C_Q1_low_Q)

comp_data = join(ML_output, all_combo_data_high_Q_max)
comp_data = join(comp_data, all_combo_data_low_Q_min)
comp_data = join(comp_data, all_combo_data_median_min)
comp_data = join(comp_data, all_combo_data_median_max)

comp_data_melt = melt(comp_data, id.vars = c("time",
                                             "ML_high_Q", "ML_low_Q",
                                             "all_combo_high_Q_max",
                                             "all_combo_low_Q_min",
                                             "all_combo_median_min",
                                             "all_combo_median_max"))
ML_Q_Rib_Col_lab = "95% Simulation Quantiles \n (MLE)"
All_combo_Med_Rib_Col_lab = "Simulation Median \n  (all 2 LL combinations)"
All_combo_Q_Rib_Col_lab = "95% Simulation Quantiles \n (all 2 LL combinations)"
comp_data_melt$ML_Q_Rib_Col = ML_Q_Rib_Col_lab
comp_data_melt$All_combo_Med_Rib_Col = All_combo_Med_Rib_Col_lab
comp_data_melt$All_combo_Q_Rib_Col = All_combo_Q_Rib_Col_lab

fill_vec = c("pink", "skyblue", "grey70")
names(fill_vec) = c(All_combo_Med_Rib_Col_lab, ML_Q_Rib_Col_lab, All_combo_Q_Rib_Col_lab)


hosp_comp_df = read.csv("../Generated_Data/hosp_comp_df.csv")

obs_hosp_df = hosp_comp_df %>%
  filter(variable == "HOSPITALIZED_COUNT") %>%
  dplyr::select(-Date, -Day_of_Week, time = times) 


p = ggplot() +
  geom_ribbon(data = comp_data_melt,
              aes(x = time, ymin = all_combo_low_Q_min,
                  ymax = all_combo_high_Q_max, fill = All_combo_Q_Rib_Col), inherit.aes = FALSE) +
  geom_ribbon(data = comp_data_melt,
              aes(x = time, ymin = all_combo_median_min,
                  ymax = all_combo_median_max, fill = All_combo_Med_Rib_Col), inherit.aes = FALSE) +
    geom_ribbon(data = comp_data_melt,
                aes(x = time, ymin = ML_low_Q,
                  ymax = ML_high_Q, fill = ML_Q_Rib_Col),  inherit.aes = FALSE) +
  geom_line(data = comp_data_melt,
            aes(x = time, y = value, color = variable)) +
  geom_point(data = comp_data_melt,
             aes(x = time, y = value, color = variable)) +
  rahul_theme +
  theme(legend.text = element_text(size = 12,
                             face = "bold",
                             color = "black")) +
  theme_white_background +
    scale_fill_manual(name = "Ribbon  Legend", values = fill_vec) +
  scale_color_manual(name = "Color  Legend", values = c("red"),
                                     labels =
                                       c("Simulation Median \n (MLE)"))  +
   xlab("Days since March 1 2020")+
  ylab(expression(paste(C_Q1))) +
  geom_point(data = obs_hosp_df, aes(x = time, y = value), color = 'blue') +
  geom_line(data = obs_hosp_df, aes(x = time, y = value), color = 'blue') 
p

```
### Only top 2LL params via antibody LL
```{r}
all_combo_data_high_Q_max = aggregate(sim_data_C_Q1_high_Q ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = max)
all_combo_data_high_Q_max = dplyr::select(all_combo_data_high_Q_max,
                                          time = time,
                                          all_combo_high_Q_max = sim_data_C_Q1_high_Q)
all_combo_data_low_Q_min = aggregate(sim_data_C_Q1_low_Q ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = min)
all_combo_data_low_Q_min = dplyr::select(all_combo_data_low_Q_min,
                                          time = time,
                                          all_combo_low_Q_min = sim_data_C_Q1_low_Q)
all_combo_data_median_max = aggregate(sim_data_C_Q1_median ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = max)

all_combo_data_median_max = dplyr::select(all_combo_data_median_max,
                                          time = time,
                                          all_combo_median_max = sim_data_C_Q1_median)

all_combo_data_median_min = aggregate(sim_data_C_Q1_median ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = min)
all_combo_data_median_min = dplyr::select(all_combo_data_median_min,
                                          time = time,
                                          all_combo_median_min = sim_data_C_Q1_median)


ML_output = antibody_top_2_LL_params_and_sim_data %>%
  filter(Antibody_Mean_LL == max(Antibody_Mean_LL))
ML_output = dplyr::select(ML_output, time = time,
                          ML_median = sim_data_C_Q1_median,
                          ML_high_Q = sim_data_C_Q1_high_Q,
                          ML_low_Q = sim_data_C_Q1_low_Q)

comp_data = join(ML_output, all_combo_data_high_Q_max)
comp_data = join(comp_data, all_combo_data_low_Q_min)
comp_data = join(comp_data, all_combo_data_median_min)
comp_data = join(comp_data, all_combo_data_median_max)

comp_data_melt = melt(comp_data, id.vars = c("time",
                                             "ML_high_Q", "ML_low_Q",
                                             "all_combo_high_Q_max",
                                             "all_combo_low_Q_min",
                                             "all_combo_median_min",
                                             "all_combo_median_max"))
ML_Q_Rib_Col_lab = "95% Simulation Quantiles \n (MLE)"
All_combo_Med_Rib_Col_lab = "Simulation Median \n  (all 2 LL combinations)"
All_combo_Q_Rib_Col_lab = "95% Simulation Quantiles \n (all 2 LL combinations)"
comp_data_melt$ML_Q_Rib_Col = ML_Q_Rib_Col_lab
comp_data_melt$All_combo_Med_Rib_Col = All_combo_Med_Rib_Col_lab
comp_data_melt$All_combo_Q_Rib_Col = All_combo_Q_Rib_Col_lab

fill_vec = c("pink", "skyblue", "red")
names(fill_vec) = c(All_combo_Med_Rib_Col_lab, ML_Q_Rib_Col_lab, All_combo_Q_Rib_Col_lab)


hosp_comp_df = read.csv("../Generated_Data/hosp_comp_df.csv")

obs_hosp_df = hosp_comp_df %>%
  filter(variable == "HOSPITALIZED_COUNT") %>%
  dplyr::select(-Date, -Day_of_Week, time = times) 

obs_resp_df = hosp_comp_df %>%
  filter(variable == "Count") %>%
  dplyr::select(-Date, -Day_of_Week, time = times) 

obs_resp_likely_COVID_df = hosp_comp_df %>%
  filter(variable == "daily_est_COVID_resp") %>%
  dplyr::select(-Date, -Day_of_Week, time = times) 


p = ggplot() +
  geom_ribbon(data = comp_data_melt,
              aes(x = time, ymin = all_combo_low_Q_min,
                  ymax = all_combo_high_Q_max, fill = All_combo_Q_Rib_Col,
                  alpha = 0.5), inherit.aes = FALSE) +
  # geom_ribbon(data = comp_data_melt,
  #             aes(x = time, ymin = all_combo_median_min,
  #                 ymax = all_combo_median_max, fill = All_combo_Med_Rib_Col), inherit.aes = FALSE) +
  #   geom_ribbon(data = comp_data_melt,
  #               aes(x = time, ymin = ML_low_Q,
  #                 ymax = ML_high_Q, fill = ML_Q_Rib_Col),  inherit.aes = FALSE) +
  geom_line(data = comp_data_melt,
            aes(x = time, y = value, color = variable)) +
  geom_point(data = comp_data_melt,
             aes(x = time, y = value, color = variable)) +
  rahul_theme +
  theme(legend.text = element_text(size = 12,
                             face = "bold",
                             color = "black")) +
  theme_white_background +
    scale_fill_manual(name = "Ribbon  Legend", values = fill_vec) +
  scale_color_manual(name = "Color  Legend", values = c("red"),
                                     labels =
                                       c("Simulation Median \n (MLE)"))  +
   xlab("Days since March 1 2020")+
  ylab(expression(paste("Daily new hospitalized cases (", C[Q1], ")"))) +
  geom_point(data = obs_hosp_df, aes(x = time, y = value), color = 'blue', shape = 'square') +
  geom_line(data = obs_hosp_df, aes(x = time, y = value), color = 'blue',  linetype = "dashed") +
  geom_point(data = obs_resp_df, aes(x = time, y = value), color = 'orange',
             shape = 'triangle') +
  geom_line(data = obs_resp_df, aes(x = time, y = value), color = 'orange',
            linetype = "dotdash") +
  geom_point(data = obs_resp_likely_COVID_df, aes(x = time, y = value), color = 'magenta',
             shape = 'triangle') +
  geom_line(data = obs_resp_likely_COVID_df, aes(x = time, y = value), color = 'magenta',
            linetype = "dotdash") +
  theme(legend.position = "None") +
  theme(axis.title.x = element_text(face = "plain"),
        axis.title.y = element_text(face = "plain"))
p

```
```{r}


png(paste0("../Figures/Profiles/", model_name,
 "_Model/top_2_LL_sim_plots/top_2_LL_via_antibody_comp_plots/b_a_profile_Obs_COVID_hosp_cases_vs_Ribbon_Plot_C_Q1_over_time_simulation_from_b_a_profile__2_LL_antibody_from_antibody_b_a_profile_peak_params.png"))
print(p)
dev.off()


```
```{r}
p = ggplot() +
  geom_ribbon(data = comp_data_melt,
              aes(x = time, ymin = all_combo_low_Q_min,
                  ymax = all_combo_high_Q_max, fill = All_combo_Q_Rib_Col,
                  alpha = 0.5), inherit.aes = FALSE) +
  # geom_ribbon(data = comp_data_melt,
  #             aes(x = time, ymin = all_combo_median_min,
  #                 ymax = all_combo_median_max, fill = All_combo_Med_Rib_Col), inherit.aes = FALSE) +
  #   geom_ribbon(data = comp_data_melt,
  #               aes(x = time, ymin = ML_low_Q,
  #                 ymax = ML_high_Q, fill = ML_Q_Rib_Col),  inherit.aes = FALSE) +
  geom_line(data = comp_data_melt,
            aes(x = time, y = value, color = variable)) +
  geom_point(data = comp_data_melt,
             aes(x = time, y = value, color = variable)) +
  rahul_theme +
  theme(legend.text = element_text(size = 12,
                             face = "bold",
                             color = "black")) +
  theme_white_background +
    scale_fill_manual(name = "Ribbon  Legend", values = fill_vec) +
  scale_color_manual(name = "Color  Legend", values = c("red"),
                                     labels =
                                       c("Simulation Median \n (MLE)"))  +
   xlab("Days since March 1 2020")+
  ylab(expression(paste("Daily new hospitalized cases "))) +
  geom_point(data = obs_hosp_df, aes(x = time, y = value), color = 'blue') +
  geom_line(data = obs_hosp_df, aes(x = time, y = value), color = 'blue') +
  geom_point(data = obs_resp_df, aes(x = time, y = value), color = 'orange') +
  geom_line(data = obs_resp_df, aes(x = time, y = value), color = 'orange') +
  geom_point(data = obs_resp_likely_COVID_df, aes(x = time, y = value), color = 'magenta') +
  geom_line(data = obs_resp_likely_COVID_df, aes(x = time, y = value), color = 'magenta') +
  theme(legend.position = "None") +
  theme(axis.title.x = element_text(face = "plain"),
        axis.title.y = element_text(face = "plain"))
p
```

```{r}
png(paste0("../Figures/Profiles/", model_name,
 "_Model/Man_Figs/Figure_5.png"))
print(p)
dev.off()

pdf(paste0("../Figures/Profiles/", model_name,
 "_Model/Man_Figs/Figure_5.pdf"))
print(p)
dev.off()
```



```{r}
png(paste0("../Figures/Profiles/", model_name,
 "_Model/Sup_Figs/b_a_profile_Obs_COVID_hosp_cases_vs_Ribbon_Plot_C_Q1_over_time_simulation_from_b_a_profile__2_LL_antibody_from_antibody_b_a_profile_peak_params.png"))
print(p)
dev.off()
```



## Compare to observed data (b_a Profile)
### Only top 2LL params via case LL (b_a Profile)
```{r}
#all_combo_melt_data = melt(all_combo_data, id.vars = c("time", "combo_num"))

all_combo_data_high_Q_max = aggregate(sim_data_high_Q ~ time, params_with_data,
                               FUN = max)
all_combo_data_high_Q_max = dplyr::select(all_combo_data_high_Q_max,
                                          time = time,
                                          all_combo_high_Q_max = sim_data_high_Q)
all_combo_data_low_Q_min = aggregate(sim_data_low_Q ~ time, params_with_data,
                               FUN = min)
all_combo_data_low_Q_min = dplyr::select(all_combo_data_low_Q_min,
                                          time = time,
                                          all_combo_low_Q_min = sim_data_low_Q)
all_combo_data_median_max = aggregate(sim_data_median ~ time, params_with_data,
                               FUN = max)

all_combo_data_median_max = dplyr::select(all_combo_data_median_max,
                                          time = time,
                                          all_combo_median_max = sim_data_median)

all_combo_data_median_min = aggregate(sim_data_median ~ time, params_with_data,
                               FUN = min)
all_combo_data_median_min = dplyr::select(all_combo_data_median_min,
                                          time = time,
                                          all_combo_median_min = sim_data_median)


ML_output = antibody_top_2_LL_params_and_sim_data %>%
  filter(Antibody_Mean_LL == max(Antibody_Mean_LL))

ML_output = dplyr::select(ML_output, time = time,
                          ML_median = sim_data_median,
                          ML_high_Q = sim_data_high_Q,
                          ML_low_Q = sim_data_low_Q)

comp_data = join(ML_output, all_combo_data_high_Q_max)



## Joining by: time

comp_data = join(comp_data, all_combo_data_low_Q_min)

## Joining by: time

comp_data = join(comp_data, all_combo_data_median_min)

## Joining by: time

comp_data = join(comp_data, all_combo_data_median_max)

## Joining by: time

true_data = dplyr::select(Observed_data, time = times,
                          Observed_Data = Y)
comp_data = join(comp_data, true_data)

## Joining by: time



comp_data_melt = melt(comp_data, id.vars = c("time",
                                             "ML_high_Q", "ML_low_Q",
                                             "all_combo_high_Q_max",
                                             "all_combo_low_Q_min",
                                             "all_combo_median_min",
                                             "all_combo_median_max"))





comp_data_melt$ML_Q_Rib_Col = "95% Simulation Quantiles \n (MLE)"
comp_data_melt$All_combo_Med_Rib_Col = "Simulation Median \n  (all 2 LL combinations)"
comp_data_melt$All_combo_Q_Rib_Col = "95% Simulation Quantiles \n (all 2 LL combinations)"

fill_vec = c("Simulation Median \n  (all 2 LL combinations)" = "pink", "95% Simulation Quantiles \n (MLE)" = "skyblue", "95% Simulation Quantiles \n (all 2 LL combinations)" = "red")

p = ggplot(data = comp_data_melt) +
  geom_ribbon(aes(x = time, ymin = all_combo_low_Q_min,
                  ymax = all_combo_high_Q_max, fill = All_combo_Q_Rib_Col,
                  alpha = 0.5), inherit.aes = FALSE) +
  # geom_ribbon(aes(x = time, ymin = ML_low_Q,
  #                 ymax = ML_high_Q, fill = ML_Q_Rib_Col),  inherit.aes = FALSE) +
  # geom_ribbon(aes(x = time, ymin = all_combo_median_min,
  #                 ymax = all_combo_median_max, fill = All_combo_Med_Rib_Col), inherit.aes = FALSE) +
  geom_line(aes(x = time, y = value, color = variable)) +
  geom_point(aes(x = time, y = value, color = variable)) +
  rahul_theme +
  theme(legend.text = element_text(size = 12,
                             face = "bold",
                             color = "black")) +
  theme_white_background +

    scale_fill_manual(name = "Ribbon  Legend", values = fill_vec) +
  scale_color_manual(name = "Color  Legend", values = c("red","blue"),
                                     labels =
                                       c("Simulation Median \n (MLE)",
                                         "Observed",
                                         "Data Used For Fitting"))  +
   xlab("Days since March 1 2020")+
  ylab("Observed Monthly Cases") +
  theme(legend.position = "None") +
  theme(axis.title.x = element_text(face = "plain", size = 24),
        axis.title.y = element_text(face = "plain", size = 24)) +
  theme(axis.line = element_line(colour = 'black', size = 1))+
  theme(axis.ticks = element_line(colour = "black", size = 1.5))+
  theme(axis.text.x = element_text(size=21)) +
  theme(axis.text.y = element_text(size=21))
  # xlab("")+
  # ylab("")
p

```

```{r}
png(paste0("../Figures/Profiles/", model_name,
 "_Model/top_2_LL_sim_plots/top_2_LL_via_antibody_comp_plots/b_a_profile_Obs_daily_COVID_cases_vs_Ribbon_Plot_simulated_cases_over_time_simulation_from_b_a_profile_2_LL_via_case_LL.png"))
print(p)
dev.off()
```

```{r}
png(paste0("../Figures/Profiles/", model_name,
 "_Model/Man_Figs/b_a_profile_Obs_daily_COVID_cases_vs_Ribbon_Plot_simulated_cases_over_time_simulation_from_b_a_profile_2_LL_via_case_LL.png"))
print(p)
dev.off()

pdf(paste0("../Figures/Profiles/", model_name,
 "_Model/Man_Figs/b_a_profile_Obs_daily_COVID_cases_vs_Ribbon_Plot_simulated_cases_over_time_simulation_from_b_a_profile_2_LL_via_case_LL.pdf"))
print(p)
dev.off()


p = ggplot(data = comp_data_melt) +
  geom_ribbon(aes(x = time, ymin = all_combo_low_Q_min,
                  ymax = all_combo_high_Q_max, fill = All_combo_Q_Rib_Col,
                  alpha = 0.5), inherit.aes = FALSE) +
  # geom_ribbon(aes(x = time, ymin = ML_low_Q,
  #                 ymax = ML_high_Q, fill = ML_Q_Rib_Col),  inherit.aes = FALSE) +
  # geom_ribbon(aes(x = time, ymin = all_combo_median_min,
  #                 ymax = all_combo_median_max, fill = All_combo_Med_Rib_Col), inherit.aes = FALSE) +
  geom_line(aes(x = time, y = value, color = variable)) +
  geom_point(aes(x = time, y = value, color = variable)) +
  rahul_theme +
  theme(legend.text = element_text(size = 12,
                             face = "bold",
                             color = "black")) +
  theme_white_background +

    scale_fill_manual(name = "Ribbon  Legend", values = fill_vec) +
  scale_color_manual(name = "Color  Legend", values = c("red","blue"),
                                     labels =
                                       c("Simulation Median \n (MLE)",
                                         "Observed",
                                         "Data Used For Fitting"))  +
   xlab("Days since March 1 2020")+
  ylab("Observed Monthly Cases") +
  theme(legend.position = "None") +
  theme(axis.title.x = element_text(face = "plain"),
        axis.title.y = element_text(face = "plain")) +
  xlab("")+
  ylab("") +
  theme(axis.title.x = element_text(face = "plain", size = 24),
        axis.title.y = element_text(face = "plain", size = 24)) +
  theme(axis.line = element_line(colour = 'black', size = 1))+
  theme(axis.ticks = element_line(colour = "black", size = 1.5))+
  theme(axis.text.x = element_text(size=21)) +
  theme(axis.text.y = element_text(size=21))
p

png(paste0("../Figures/Profiles/", model_name,
 "_Model/Man_Figs/b_a_profile_Obs_daily_COVID_cases_vs_Ribbon_Plot_simulated_cases_over_time_simulation_from_b_a_profile_2_LL_via_case_LL_no_labs.png"))
print(p)
dev.off()

```


```{r}
p = ggplot(data = comp_data_melt) +
  geom_ribbon(aes(x = time, ymin = log(all_combo_low_Q_min),
                  ymax = log(all_combo_high_Q_max), fill = All_combo_Q_Rib_Col, alpha = 0.5), inherit.aes = FALSE) +
  # geom_ribbon(aes(x = time, ymin = log(ML_low_Q),
  #                 ymax = log(ML_high_Q), fill = ML_Q_Rib_Col),  inherit.aes = FALSE) +
  # geom_ribbon(aes(x = time, ymin = log(all_combo_median_min),
  #                 ymax = log(all_combo_median_max), fill = All_combo_Med_Rib_Col), inherit.aes = FALSE) +
  geom_line(aes(x = time, y = log(value), color = variable)) +
  geom_point(aes(x = time, y = log(value), color = variable)) +
  rahul_theme +
  theme(legend.text = element_text(size = 12,
                             face = "bold",
                             color = "black")) +
  theme_white_background +

    scale_fill_manual(name = "Ribbon  Legend", values = fill_vec) +
  scale_color_manual(name = "Color  Legend", values = c("red","blue"),
                                     labels =
                                       c("Simulation Median \n (MLE)",
                                         "Observed",
                                         "Data Used For Fitting"))  +
   xlab("Days since March 1 2020")+
  ylab("Observed Monthly Cases") +
  theme(legend.position = "None")
p
```

```{r}
png(paste0("../Figures/Profiles/", model_name,
 "_Model/top_2_LL_sim_plots/top_2_LL_via_antibody_comp_plots/b_a_profile_log_Obs_daily_COVID_cases_vs_Ribbon_Plot_simulated_cases_over_time_simulation_from_2_LL_via_case_data.png"))
print(p)
dev.off()
```

```{r}
png(paste0("../Figures/Profiles/", model_name,
 "_Model/Man_Figs/b_a_profile_log_Obs_daily_COVID_cases_vs_Ribbon_Plot_simulated_cases_over_time_simulation_from_2_LL_via_case_data.png"))
print(p)
dev.off()
```

### Ony top 2LL params via cases and antibody LL (b_a Profile)
```{r}
#all_combo_melt_data = melt(all_combo_data, id.vars = c("time", "combo_num"))

all_combo_data_high_Q_max = aggregate(sim_data_high_Q ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = max)
all_combo_data_high_Q_max = dplyr::select(all_combo_data_high_Q_max,
                                          time = time,
                                          all_combo_high_Q_max = sim_data_high_Q)
all_combo_data_low_Q_min = aggregate(sim_data_low_Q ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = min)
all_combo_data_low_Q_min = dplyr::select(all_combo_data_low_Q_min,
                                          time = time,
                                          all_combo_low_Q_min = sim_data_low_Q)
all_combo_data_median_max = aggregate(sim_data_median ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = max)

all_combo_data_median_max = dplyr::select(all_combo_data_median_max,
                                          time = time,
                                          all_combo_median_max = sim_data_median)

all_combo_data_median_min = aggregate(sim_data_median ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = min)
all_combo_data_median_min = dplyr::select(all_combo_data_median_min,
                                          time = time,
                                          all_combo_median_min = sim_data_median)


ML_output = antibody_top_2_LL_params_and_sim_data %>%
  filter(Antibody_Mean_LL == max(Antibody_Mean_LL))

ML_output = dplyr::select(ML_output, time = time,
                          ML_median = sim_data_median,
                          ML_high_Q = sim_data_high_Q,
                          ML_low_Q = sim_data_low_Q)

comp_data = join(ML_output, all_combo_data_high_Q_max)



## Joining by: time

comp_data = join(comp_data, all_combo_data_low_Q_min)

## Joining by: time

comp_data = join(comp_data, all_combo_data_median_min)

## Joining by: time

comp_data = join(comp_data, all_combo_data_median_max)

## Joining by: time

true_data = dplyr::select(Observed_data, time = times,
                          Observed_Data = Y)
comp_data = join(comp_data, true_data)

## Joining by: time



comp_data_melt = melt(comp_data, id.vars = c("time",
                                             "ML_high_Q", "ML_low_Q",
                                             "all_combo_high_Q_max",
                                             "all_combo_low_Q_min",
                                             "all_combo_median_min",
                                             "all_combo_median_max"))





comp_data_melt$ML_Q_Rib_Col = "95% Simulation Quantiles \n (MLE)"
comp_data_melt$All_combo_Med_Rib_Col = "Simulation Median \n  (all 2 LL combinations)"
comp_data_melt$All_combo_Q_Rib_Col = "95% Simulation Quantiles \n (all 2 LL combinations)"

fill_vec = c("Simulation Median \n  (all 2 LL combinations)" = "pink", "95% Simulation Quantiles \n (MLE)" = "skyblue", "95% Simulation Quantiles \n (all 2 LL combinations)" = "grey70")

p = ggplot(data = comp_data_melt) +
  geom_ribbon(aes(x = time, ymin = all_combo_low_Q_min,
                  ymax = all_combo_high_Q_max, fill = All_combo_Q_Rib_Col), inherit.aes = FALSE) +
  geom_ribbon(aes(x = time, ymin = ML_low_Q,
                  ymax = ML_high_Q, fill = ML_Q_Rib_Col),  inherit.aes = FALSE) +
  geom_ribbon(aes(x = time, ymin = all_combo_median_min,
                  ymax = all_combo_median_max, fill = All_combo_Med_Rib_Col), inherit.aes = FALSE) +
  geom_line(aes(x = time, y = value, color = variable)) +
  geom_point(aes(x = time, y = value, color = variable)) +
  rahul_theme +
  theme(legend.text = element_text(size = 12,
                             face = "bold",
                             color = "black")) +
  theme_white_background +

    scale_fill_manual(name = "Ribbon  Legend", values = fill_vec) +
  scale_color_manual(name = "Color  Legend", values = c("red","blue"),
                                     labels =
                                       c("Simulation Median \n (MLE)",
                                         "Observed",
                                         "Data Used For Fitting"))  +
   xlab("Days since March 1 2020")+
  ylab("Observed Monthly Cases")
p

```

```{r}
png(paste0("../Figures/Profiles/", model_name,
 "_Model/top_2_LL_sim_plots/top_2_LL_via_antibody_comp_plots/b_a_profile_Obs_daily_COVID_cases_vs_Ribbon_Plot_simulated_cases_over_time_simulation_from_b_a_profile_2_LL_antibody_from_antibody_profile_peak_params.png"))
print(p)
dev.off()
```


```{r}
p = ggplot(data = comp_data_melt) +
  geom_ribbon(aes(x = time, ymin = log(all_combo_low_Q_min),
                  ymax = log(all_combo_high_Q_max), fill = All_combo_Q_Rib_Col), inherit.aes = FALSE) +
  geom_ribbon(aes(x = time, ymin = log(ML_low_Q),
                  ymax = log(ML_high_Q), fill = ML_Q_Rib_Col),  inherit.aes = FALSE) +
  geom_ribbon(aes(x = time, ymin = log(all_combo_median_min),
                  ymax = log(all_combo_median_max), fill = All_combo_Med_Rib_Col), inherit.aes = FALSE) +
  geom_line(aes(x = time, y = log(value), color = variable)) +
  geom_point(aes(x = time, y = log(value), color = variable)) +
  rahul_theme +
  theme(legend.text = element_text(size = 12,
                             face = "bold",
                             color = "black")) +
  theme_white_background +

    scale_fill_manual(name = "Ribbon  Legend", values = fill_vec) +
  scale_color_manual(name = "Color  Legend", values = c("red","blue"),
                                     labels =
                                       c("Simulation Median \n (MLE)",
                                         "Observed",
                                         "Data Used For Fitting"))  +
   xlab("Days since March 1 2020")+
  ylab("Observed Monthly Cases")
p
```

```{r}
png(paste0("../Figures/Profiles/", model_name,
 "_Model/top_2_LL_sim_plots/top_2_LL_via_antibody_comp_plots/b_a_profile_log_Obs_daily_COVID_cases_vs_Ribbon_Plot_simulated_cases_over_time_simulation_from_2_LL_antibody_from_antibody_profile_peak.png"))
print(p)
dev.off()
```
## Profile Analysis Plots
```{r}
low_p_S_subset_top_2_LL_end_subset_with_antibody_LL =
  top_2_LL_end_subset_with_antibody_LL %>%
  filter(p_S < 0.30)

p = ggplot(data = top_2_LL_end_subset_with_antibody_LL,
           aes(x = p_S,
               y = Antibody_Mean_LL)) +
  geom_point(size = 3) +
  rahul_man_figure_theme +
  theme_white_background +
  theme(axis.title.x = element_text(face = "plain", size = 24),
        axis.title.y = element_text(face = "plain", size = 24)) +
  theme(axis.line = element_line(colour = 'black', size = 1))+
  theme(axis.ticks = element_line(colour = "black", size = 1.5)) +
  theme(axis.text.x = element_text(size=21)) +
  theme(axis.text.y = element_text(size=21)) +
  geom_hline(yintercept =
               max(top_2_LL_end_subset_with_antibody_LL$Antibody_Mean_LL)-2,
             color = 'blue', size = 1.5) +
  xlab(expression(paste(
    "Proportion of symptomatic cases (", p[S], ")",))) +
  ylab("Likelihood with respect to serology") 
  # xlab("")+
  # ylab("")
p

png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "p_S_vs_Antibody_LL_", model_name,
           "_model_antibody_LL_from_b_a_Profile_peak_LL.png"))
print(p)
dev.off()

png(paste0("../Figures/Profiles/", model_name, "_Model/Man_Figs/",
           "p_S_vs_Antibody_LL_", model_name,
           "_model_antibody_LL_from_b_a_Profile_peak_LL.png"))
print(p)
dev.off()

p = ggplot(data = low_p_S_subset_top_2_LL_end_subset_with_antibody_LL,
           aes(x = p_S,
               y = Antibody_Mean_LL)) +
  geom_point(size = 3) +
  rahul_man_figure_theme +
  theme_white_background +
  theme(axis.title.x = element_text(face = "plain", size = 24),
        axis.title.y = element_text(face = "plain", size = 24)) +
  theme(axis.line = element_line(colour = 'black', size = 1))+
  theme(axis.ticks = element_line(colour = "black", size = 1.5)) +
  theme(axis.text.x = element_text(size=21)) +
  theme(axis.text.y = element_text(size=21)) +
  geom_hline(yintercept =
               max(top_2_LL_end_subset_with_antibody_LL$Antibody_Mean_LL)-2,
             color = 'blue', size = 1.5) +
  xlab(expression(paste(
    "Proportion of symptomatic cases (", p[S], ")",))) +
  ylab("Likelihood with respect to serology") 
  # xlab("")+
  # ylab("")
p
png(paste0("../Figures/Profiles/", model_name, "_Model/Man_Figs/",
           "p_S_vs_Antibody_LL_low_p_S_subset_", model_name,
           "_model_antibody_LL_from_b_a_Profile_peak_LL.png"))
print(p)
dev.off()

p = ggplot(data = top_2_LL_end_subset_with_antibody_LL,
           aes(x = p_S,
               y = Antibody_Mean_LL)) +
  geom_point(size = 3) +
  rahul_man_figure_theme +
  theme_white_background +
  theme(axis.title.x = element_text(face = "plain"),
        axis.title.y = element_text(face = "plain")) +
  geom_hline(yintercept =
               max(top_2_LL_end_subset_with_antibody_LL$Antibody_Mean_LL)-2,
             color = 'blue',
             size = 1.5) +
  xlab(expression(paste(
    "Proportion of symptomatic cases (", p[S], ")",))) +
  ylab("Likelihood with respect to serology") + 
  xlab("")+
  ylab("") +
  theme(axis.title.x = element_text(face = "plain", size = 24),
        axis.title.y = element_text(face = "plain", size = 24)) +
  theme(axis.line = element_line(colour = 'black', size = 1))+
  theme(axis.ticks = element_line(colour = "black", size = 1.5)) +
    theme(axis.text.x = element_text(size=21)) +
  theme(axis.text.y = element_text(size=21)) 
p


png(paste0("../Figures/Profiles/", model_name, "_Model/Man_Figs/",
           "p_S_vs_Antibody_LL_", model_name,
           "_model_antibody_LL_from_b_a_Profile_peak_LL_no_labs.png"))
print(p)
dev.off()
p = ggplot(data = top_2_LL_end_subset_with_antibody_LL,
           aes(x = b_a,
               y = Antibody_Mean_LL)) +
  geom_point() +
  rahul_man_figure_theme
p


png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "b_a_vs_Antibody_LL_", model_name,
           "_model_antibody_LL_from_b_a_Profile_peak_LL.png"))
print(p)
dev.off()


p = ggplot(data = top_2_LL_end_subset_with_antibody_LL,
           aes(x = R_0,
               y = Antibody_Mean_LL)) +
  geom_point() +
  rahul_man_figure_theme
p

png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "R_0_vs_Antibody_LL_", model_name,
           "_model_antibody_LL_from_b_a_Profile_peak_LL.png"))
print(p)
dev.off()

top_2_LL_end_subset_with_antibody_LL$duration_of_symp_1 = 1/top_2_LL_end_subset_with_antibody_LL$phi_S
top_2_LL_end_subset_with_antibody_LL$duration_of_symp_2 = 1/top_2_LL_end_subset_with_antibody_LL$gamma
top_2_LL_end_subset_with_antibody_LL =  top_2_LL_end_subset_with_antibody_LL %>%
  mutate(duration_of_symp = duration_of_symp_1 + duration_of_symp_2)
top_2_LL_end_subset_with_antibody_LL$gamma_total = 1/top_2_LL_end_subset_with_antibody_LL$duration_of_symp
top_2_LL_end_subset_with_antibody_LL = top_2_LL_end_subset_with_antibody_LL %>%
  mutate(Beta = R_0*gamma_total)

top_2_LL_end_subset_with_antibody_LL = top_2_LL_end_subset_with_antibody_LL%>%
  mutate(R_0_P = (Beta*b_p)/phi_U,
         R_0_A = (Beta*b_a *(1-p_S))/phi_S,
         R_0_S_1 = (Beta*p_S)/phi_S,
         R_0_S_2 = (Beta*(1-p_H_cond_S)*p_S)/gamma)
top_2_LL_end_subset_with_antibody_LL = top_2_LL_end_subset_with_antibody_LL %>%
  mutate(R_0_NGM = R_0_P + R_0_A + R_0_S_1 + R_0_S_2)

antibody_top_2_LL_from_b_a_profile_top_2_LL = top_2_LL_end_subset_with_antibody_LL %>%
  filter(Antibody_Mean_LL > max(Antibody_Mean_LL)-2)
nrow(antibody_top_2_LL_from_b_a_profile_top_2_LL)
range(antibody_top_2_LL_from_b_a_profile_top_2_LL$R_0)
p = ggplot(data = antibody_top_2_LL_from_b_a_profile_top_2_LL,
           aes(x = b_a,
               y = R_0)) +
  geom_point() +
  rahul_man_figure_theme
p

png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "top_2_LL_via_antibody_comp_plots/",
           "b_a_vs_R_0_", model_name,
           "_model_top_2_antibody_LL_from_b_a_profile_peak_LL.png"))
print(p)
dev.off()

p = ggplot(data = antibody_top_2_LL_from_b_a_profile_top_2_LL,
           aes(x = b_a,
               y = log(R_0))) + geom_hline(yintercept = log(3), color = 'orange') +
  geom_hline(yintercept = log(4), color = 'purple') +
  geom_point() +
  rahul_man_figure_theme
p

png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "top_2_LL_via_antibody_comp_plots/",
           "b_a_vs_log_R_0_", model_name,
           "_model_top_2_antibody_LL_from_b_a_profile_peak_LL.png"))
print(p)
dev.off()


p = ggplot(data = antibody_top_2_LL_from_b_a_profile_top_2_LL,
           aes(x = b_p,
               y = R_0)) +
  geom_point() +
  rahul_man_figure_theme
p

png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "top_2_LL_via_antibody_comp_plots/",
           "b_p_vs_R_0_", model_name,
           "_model_top_2_antibody_LL_from_b_a_profile_peak_LL.png"))
print(p)
dev.off()

p = ggplot(data = antibody_top_2_LL_from_b_a_profile_top_2_LL,
           aes(x = b_q,
               y = R_0)) +
  geom_point() +
  rahul_man_figure_theme
p
png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "top_2_LL_via_antibody_comp_plots/",
           "b_q_vs_R_0_", model_name,
           "_model_top_2_antibody_LL_from_b_a_profile_peak_LL.png"))
print(p)
dev.off()

range(antibody_top_2_LL_from_b_a_profile_top_2_LL$b_q)
hist(antibody_top_2_LL_from_b_a_profile_top_2_LL$R_0)
```
## Calculate R_0 NGM for top_2_LL of b_a profile

\begin{equation}
R_{0_{NGM}} = \frac{\beta_P}{\phi_U} + \frac{\beta_A (1-p_S)}{\phi_S} + \frac{\beta p_S}{\phi_S} + \frac{\beta (1-p_{\text{H_cond_S}}) p_S}{\gamma}
\end{equation}

In terms of model parameters:
\begin{equation}
R_{0_{NGM}} = \frac{\beta*b_p}{\phi_U} + \frac{\beta*b_a (1-p_S)}{\phi_S} + \frac{\beta p_S}{\phi_S} + \frac{\beta (1-p_{\text{H_cond_S}}) p_S}{\gamma}
\end{equation}
```{r}

p = ggplot(data = top_2_LL_end_subset_with_antibody_LL,
           aes(x = R_0_NGM)) + 
  geom_density() +
  rahul_man_figure_theme
p
png(file = paste0("../Figures/Profiles/", model_name, "_Model/b_a_Profile/", model_name,
                  "_b_a_profile_density_plot_of_R_0_NGM_for_all_parameter_combinations_within_2LL_of_profile_MLE_fit_to_cases.png"))
print(p)
dev.off()

p = ggplot(data = top_2_LL_end_subset_with_antibody_LL,
           aes(x = R_0_NGM)) + 
  geom_histogram() +
  rahul_man_figure_theme
p

png(file = paste0("../Figures/Profiles/", model_name, "_Model/b_a_Profile/", model_name,
                  "_b_a_Profile_histogram_of_R_0_NGM_for_all_parameter_combinations_within_2LL_of_profile_MLE_fit_to_cases.png"))
print(p)
dev.off()

p = ggplot(data = top_2_LL_end_subset_with_antibody_LL,
           aes(x = R_0_A,
               y = R_0_S_1 + R_0_S_2)) + 
  geom_point() +
  rahul_man_figure_theme
p

png(file = paste0("../Figures/Profiles/", model_name, "_Model/b_a_Profile/", model_name,
                  "_b_a_Profile_R_0_A_vs_R_0_S_for_all_parameter_combinations_within_2LL_of_profile_MLE_fit_to_cases.png"))
print(p)
dev.off()

p = ggplot(data = top_2_LL_end_subset_with_antibody_LL,
           aes(x = R_0,
               y = R_0_NGM,
               color = b_a)) + 
  geom_point() +
  scale_color_viridis_c() +
  rahul_man_figure_theme
p
png(file = paste0("../Figures/Profiles/", model_name, "_Model/b_a_Profile/", model_name,
                  "_b_a_Profile_R_0_vs_R_0_NGM_color_b_a_for_all_parameter_combinations_within_2LL_of_profile_MLE_fit_to_cases.png"))
print(p)
dev.off()

p = ggplot(data = top_2_LL_end_subset_with_antibody_LL,
           aes(x = R_0,
               y = R_0_NGM,
               color = b_p)) + 
  geom_point() +
  scale_color_viridis_c() +
  rahul_man_figure_theme
p
png(file = paste0("../Figures/Profiles/", model_name, "_Model/b_a_Profile/", model_name,
                  "_b_a_Profile_R_0_vs_R_0_NGM_color_b_p_for_all_parameter_combinations_within_2LL_of_profile_MLE_fit_to_cases.png"))
print(p)
dev.off()

p = ggplot(data = top_2_LL_end_subset_with_antibody_LL,
           aes(x = R_0,
               y = R_0_S_1 + R_0_S_2)) + 
  geom_point() +
  rahul_man_figure_theme
p
png(file = paste0("../Figures/Profiles/", model_name, "_Model/b_a_Profile/", model_name,
                  "_b_a_Profile_R_0_vs_R_0_S_for_all_parameter_combinations_within_2LL_of_profile_MLE_fit_to_cases.png"))
print(p)
dev.off()


p = ggplot(data = top_2_LL_end_subset_with_antibody_LL,
           aes(x = R_0_NGM,
               y = Antibody_Mean_LL)) + 
  geom_point() +
  rahul_man_figure_theme
p

png(file = paste0("../Figures/Profiles/", model_name, "_Model/b_a_profile/", model_name,
                  "_b_a_profile_R_0_NGM_vs_Likelihood_with_respect_to_antibody_for_all_parameter_combinations_within_2LL_of_profile_MLE_fit_to_cases.png"))
print(p)
dev.off()

p = ggplot(data = top_2_LL_end_subset_with_antibody_LL,
           aes(x = b_a,
               y = R_0_NGM)) + 
  geom_point() +
  rahul_man_figure_theme
p

png(file = paste0("../Figures/Profiles/", model_name, "_Model/b_a_profile/", model_name,
                  "_b_a_profile_b_a_vs_R_0_NGM_for_all_parameter_combinations_within_2LL_of_profile_MLE_fit_to_cases.png"))
print(p)
dev.off()
```

```{r}
p = ggplot(data = antibody_top_2_LL_from_b_a_profile_top_2_LL,
           aes(x = R_0_NGM)) +
  geom_histogram() +
  rahul_man_figure_theme
p
png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "top_2_LL_via_antibody_comp_plots/",
           "R_0_NGM_histogram_", model_name,
           "_model_top_2_antibody_LL_from_b_a_profile_peak_LL.png"))
print(p)
dev.off()

p = ggplot(data = antibody_top_2_LL_from_b_a_profile_top_2_LL,
           aes(x = R_0,
               y = R_0_NGM,
               color = b_a)) +
  geom_point(size = 5) +
  scale_color_viridis_c() +
  rahul_man_figure_theme +
  theme_white_background +
  scale_x_continuous(breaks=c(seq(2,10,1), 15, 18)) +
  scale_y_continuous(breaks=seq(2,5,1)) +
  coord_cartesian(expand = FALSE, #turn off axis expansion (padding)
                  xlim = c(1.75, 18.25), ylim = c(1.75, 5.25)) #manually set limits
p

png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "top_2_LL_via_antibody_comp_plots/",
           "R_0_vs_R_0_NGM_color_by_b_a", model_name,
           "_model_top_2_antibody_LL_from_b_a_profile_peak_LL.png"))
print(p)
dev.off()

p = ggplot(data = antibody_top_2_LL_from_b_a_profile_top_2_LL,
           aes(x = R_0,
               y = R_0_NGM,
               color = b_p)) +
  geom_point(size = 5) +
  scale_color_viridis_c() +
  rahul_man_figure_theme +
  theme_white_background +
  scale_x_continuous(breaks=c(seq(2,10,1), 15, 18)) +
  scale_y_continuous(breaks=seq(2,5,1)) +
  coord_cartesian(expand = FALSE, #turn off axis expansion (padding)
                  xlim = c(1.75, 18.25), ylim = c(1.75, 5.25)) #manually set limits
p

png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "top_2_LL_via_antibody_comp_plots/",
           "R_0_vs_R_0_NGM_color_by_b_p", model_name,
           "_model_top_2_antibody_LL_from_b_a_profile_peak_LL.png"))
print(p)
dev.off()

p = ggplot(data = antibody_top_2_LL_from_b_a_profile_top_2_LL,
           aes(x = R_0,
               y = R_0_NGM,
               color = b_p)) +
  geom_point(size = 5) +
  scale_color_viridis_c() +
  rahul_man_figure_theme +
  theme_white_background +
  scale_x_continuous(breaks=c(seq(2,10,1), 15, 18)) +
  scale_y_continuous(breaks=seq(2,5,1)) +
  coord_cartesian(expand = FALSE, #turn off axis expansion (padding)
                  xlim = c(1.75, 9), ylim = c(1.75, 5.25)) #manually set limits
p

png(paste0("../Figures/Profiles/", model_name, "_Model/Sup_Figs/",
           "R_0_vs_R_0_NGM_color_by_b_p", model_name,
           "_model_top_2_antibody_LL_from_b_a_profile_peak_LL_no_outlier.png"))
print(p)
dev.off()


```


### Surface plots
```{r}

antibody_top_2_LL_from_b_a_profile_top_2_LL_no_outlier = 
  antibody_top_2_LL_from_b_a_profile_top_2_LL %>%
  filter(R_0 <15)
save(antibody_top_2_LL_from_b_a_profile_top_2_LL_no_outlier,
     file = paste0("../Generated_Data/Profiles/", model_name, "_Model/top_2_LL_data/b_a_profile_antibody_surface_plot_data.RData"))

save(antibody_top_2_LL_from_b_a_profile_top_2_LL,
     file = paste0("../Generated_Data/Profiles/", model_name, "_Model/top_2_LL_data/b_a_profile_antibody_surface_plot_data_with_outlier.RData"))
  
library(plotly)
# if (!require("processx")) install.packages("processx")
fig <- plot_ly(antibody_top_2_LL_from_b_a_profile_top_2_LL_no_outlier,
               x = ~b_a, y = ~b_p, z = ~R_0, color = ~b_a)
fig <- fig %>% add_markers()
fig <- fig %>% layout(scene = list(xaxis = list(title = ' b_a'),
                     yaxis = list(title = ' b_p'),
                     zaxis = list(title = 'R_0 ')))

fig
# orca(fig, "surface-plot.svg")

```


```{r}
source("Sim_G_w_y_scaling_profile_peak_Model_N_12.R")
```

## R over N for top parameter combinations within 2LL when fit to antibody and case data (G_w_y_scaling Profile)
```{r}

params_with_data = join(all_combo_R_data,
                        top_2_LL_end_subset_with_antibody_LL)
params_with_data = join(params_with_data,
                        all_combo_S_data)
params_with_data = join(params_with_data,
                        all_combo_C_Q1_data)
params_with_data = join(params_with_data,
                        all_combo_data)
antibody_top_2_LL_params_and_sim_data = params_with_data %>%
  filter(Antibody_Mean_LL > max(Antibody_Mean_LL)-2)


#head(params_with_data)
all_combo_data_high_Q_max = aggregate(sim_data_R_over_N_high_Q ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = max)
all_combo_data_high_Q_max = dplyr::select(all_combo_data_high_Q_max,
                                          time = time,
                                          all_combo_high_Q_max = sim_data_R_over_N_high_Q)
all_combo_data_low_Q_min = aggregate(sim_data_R_over_N_low_Q ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = min)
all_combo_data_low_Q_min = dplyr::select(all_combo_data_low_Q_min,
                                          time = time,
                                          all_combo_low_Q_min = sim_data_R_over_N_low_Q)
all_combo_data_median_max = aggregate(sim_data_R_over_N_median ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = max)

all_combo_data_median_max = dplyr::select(all_combo_data_median_max,
                                          time = time,
                                          all_combo_median_max = sim_data_R_over_N_median)

all_combo_data_median_min = aggregate(sim_data_R_over_N_median ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = min)
all_combo_data_median_min = dplyr::select(all_combo_data_median_min,
                                          time = time,
                                          all_combo_median_min = sim_data_R_over_N_median)
ML_output = antibody_top_2_LL_params_and_sim_data %>%
  filter(Antibody_Mean_LL == max(Antibody_Mean_LL))

ML_output = dplyr::select(ML_output, time = time,
                          ML_median = sim_data_R_over_N_median,
                          ML_high_Q = sim_data_R_over_N_high_Q,
                          ML_low_Q = sim_data_R_over_N_low_Q)

comp_data = join(ML_output, all_combo_data_high_Q_max)
comp_data = join(comp_data, all_combo_data_low_Q_min)
comp_data = join(comp_data, all_combo_data_median_min)
comp_data = join(comp_data, all_combo_data_median_max)

comp_data_melt = melt(comp_data, id.vars = c("time",
                                             "ML_high_Q", "ML_low_Q",
                                             "all_combo_high_Q_max",
                                             "all_combo_low_Q_min",
                                             "all_combo_median_min",
                                             "all_combo_median_max"))
ML_Q_Rib_Col_lab = "95% Simulation Quantiles \n (MLE for antibody data)"
All_combo_Med_Rib_Col_lab = "Simulation Median \n  (all 2 LL combinations (for antibody data))"
All_combo_Q_Rib_Col_lab = "95% Simulation Quantiles \n (all 2 LL combinations (for antibody data))"
comp_data_melt$ML_Q_Rib_Col = ML_Q_Rib_Col_lab
comp_data_melt$All_combo_Med_Rib_Col = All_combo_Med_Rib_Col_lab
comp_data_melt$All_combo_Q_Rib_Col = All_combo_Q_Rib_Col_lab

fill_vec = c("pink", "skyblue", "grey70")
names(fill_vec) = c(All_combo_Med_Rib_Col_lab, ML_Q_Rib_Col_lab, All_combo_Q_Rib_Col_lab)

p = ggplot() +
  geom_ribbon(data = comp_data_melt,
              aes(x = time, ymin = all_combo_low_Q_min,
                  ymax = all_combo_high_Q_max, fill = All_combo_Q_Rib_Col), inherit.aes = FALSE) +
  geom_ribbon(data = comp_data_melt,
              aes(x = time, ymin = all_combo_median_min,
                  ymax = all_combo_median_max, fill = All_combo_Med_Rib_Col), inherit.aes = FALSE) +
    geom_ribbon(data = comp_data_melt,
                aes(x = time, ymin = ML_low_Q,
                  ymax = ML_high_Q, fill = ML_Q_Rib_Col),  inherit.aes = FALSE) +
  geom_line(data = comp_data_melt,
            aes(x = time, y = value, color = variable)) +
  geom_point(data = comp_data_melt,
             aes(x = time, y = value, color = variable)) +
  rahul_theme +
  theme(legend.text = element_text(size = 12,
                             face = "bold",
                             color = "black")) +
  theme_white_background +

    scale_fill_manual(name = "Ribbon  Legend", values = fill_vec) +
  scale_color_manual(name = "Color  Legend", values = c("red"),
                                     labels =
                                       c("Simulation Median \n (MLE)"))  +
   xlab("Days since March 1 2020")+
  ylab(expression(paste(frac(R,N)))) +
  geom_ribbon(data = nyc_antibody_df,aes(x = times, ymin = lower_CI,
                                ymax = upper_CI),
                                fill = 'blue',
                                alpha = 0.5) +
  geom_point(data = nyc_antibody_df,
           aes(x = times, y = Prop_Positive), color = 'blue') +
  geom_line(data = nyc_antibody_df,
           aes(x = times, y = Prop_Positive), color = 'blue')
  
p

```

```{r}
png(paste0("../Figures/Profiles/", model_name,
 "_Model/top_2_LL_sim_plots/top_2_LL_via_antibody_comp_plots/G_w_y_scaling_profile_Observed_Antibody_data_vs_Ribbon_Plot_R_over_N_over_time_simulation_from_G_w_y_scaling_profile__2_LL_antibody_from_antibody_G_w_y_scaling_profile_peak_params.png"))
print(p)
dev.off()
```


## C_Q1 (G_w_y_scaling Profile)
```{r}
all_combo_data_high_Q_max = aggregate(sim_data_C_Q1_high_Q ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = max)
all_combo_data_high_Q_max = dplyr::select(all_combo_data_high_Q_max,
                                          time = time,
                                          all_combo_high_Q_max = sim_data_C_Q1_high_Q)
all_combo_data_low_Q_min = aggregate(sim_data_C_Q1_low_Q ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = min)
all_combo_data_low_Q_min = dplyr::select(all_combo_data_low_Q_min,
                                          time = time,
                                          all_combo_low_Q_min = sim_data_C_Q1_low_Q)
all_combo_data_median_max = aggregate(sim_data_C_Q1_median ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = max)

all_combo_data_median_max = dplyr::select(all_combo_data_median_max,
                                          time = time,
                                          all_combo_median_max = sim_data_C_Q1_median)

all_combo_data_median_min = aggregate(sim_data_C_Q1_median ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = min)
all_combo_data_median_min = dplyr::select(all_combo_data_median_min,
                                          time = time,
                                          all_combo_median_min = sim_data_C_Q1_median)


ML_output = antibody_top_2_LL_params_and_sim_data %>%
  filter(Antibody_Mean_LL == max(Antibody_Mean_LL))
ML_output = dplyr::select(ML_output, time = time,
                          ML_median = sim_data_C_Q1_median,
                          ML_high_Q = sim_data_C_Q1_high_Q,
                          ML_low_Q = sim_data_C_Q1_low_Q)

comp_data = join(ML_output, all_combo_data_high_Q_max)
comp_data = join(comp_data, all_combo_data_low_Q_min)
comp_data = join(comp_data, all_combo_data_median_min)
comp_data = join(comp_data, all_combo_data_median_max)

comp_data_melt = melt(comp_data, id.vars = c("time",
                                             "ML_high_Q", "ML_low_Q",
                                             "all_combo_high_Q_max",
                                             "all_combo_low_Q_min",
                                             "all_combo_median_min",
                                             "all_combo_median_max"))
ML_Q_Rib_Col_lab = "95% Simulation Quantiles \n (MLE)"
All_combo_Med_Rib_Col_lab = "Simulation Median \n  (all 2 LL combinations)"
All_combo_Q_Rib_Col_lab = "95% Simulation Quantiles \n (all 2 LL combinations)"
comp_data_melt$ML_Q_Rib_Col = ML_Q_Rib_Col_lab
comp_data_melt$All_combo_Med_Rib_Col = All_combo_Med_Rib_Col_lab
comp_data_melt$All_combo_Q_Rib_Col = All_combo_Q_Rib_Col_lab

fill_vec = c("pink", "skyblue", "grey70")
names(fill_vec) = c(All_combo_Med_Rib_Col_lab, ML_Q_Rib_Col_lab, All_combo_Q_Rib_Col_lab)


hosp_comp_df = read.csv("../Generated_Data/hosp_comp_df.csv")

obs_hosp_df = hosp_comp_df %>%
  filter(variable == "HOSPITALIZED_COUNT") %>%
  dplyr::select(-Date, -Day_of_Week, time = times) 


p = ggplot() +
  geom_ribbon(data = comp_data_melt,
              aes(x = time, ymin = all_combo_low_Q_min,
                  ymax = all_combo_high_Q_max, fill = All_combo_Q_Rib_Col), inherit.aes = FALSE) +
  geom_ribbon(data = comp_data_melt,
              aes(x = time, ymin = all_combo_median_min,
                  ymax = all_combo_median_max, fill = All_combo_Med_Rib_Col), inherit.aes = FALSE) +
    geom_ribbon(data = comp_data_melt,
                aes(x = time, ymin = ML_low_Q,
                  ymax = ML_high_Q, fill = ML_Q_Rib_Col),  inherit.aes = FALSE) +
  geom_line(data = comp_data_melt,
            aes(x = time, y = value, color = variable)) +
  geom_point(data = comp_data_melt,
             aes(x = time, y = value, color = variable)) +
  rahul_theme +
  theme(legend.text = element_text(size = 12,
                             face = "bold",
                             color = "black")) +
  theme_white_background +
    scale_fill_manual(name = "Ribbon  Legend", values = fill_vec) +
  scale_color_manual(name = "Color  Legend", values = c("red"),
                                     labels =
                                       c("Simulation Median \n (MLE)"))  +
   xlab("Days since March 1 2020")+
  ylab(expression(paste(C_Q1))) +
  geom_point(data = obs_hosp_df, aes(x = time, y = value), color = 'blue') +
  geom_line(data = obs_hosp_df, aes(x = time, y = value), color = 'blue') 
p

```

```{r}
png(paste0("../Figures/Profiles/", model_name,
 "_Model/top_2_LL_sim_plots/top_2_LL_via_antibody_comp_plots/G_w_y_scaling_profile_Obs_COVID_hosp_cases_vs_Ribbon_Plot_C_Q1_over_time_simulation_from_G_w_y_scaling_profile__2_LL_antibody_from_antibody_G_w_y_scaling_profile_peak_params.png"))
print(p)
dev.off()
```


## Compare to observed data (G_w_y_scaling Profile)
```{r}
#all_combo_melt_data = melt(all_combo_data, id.vars = c("time", "combo_num"))

all_combo_data_high_Q_max = aggregate(sim_data_high_Q ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = max)
all_combo_data_high_Q_max = dplyr::select(all_combo_data_high_Q_max,
                                          time = time,
                                          all_combo_high_Q_max = sim_data_high_Q)
all_combo_data_low_Q_min = aggregate(sim_data_low_Q ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = min)
all_combo_data_low_Q_min = dplyr::select(all_combo_data_low_Q_min,
                                          time = time,
                                          all_combo_low_Q_min = sim_data_low_Q)
all_combo_data_median_max = aggregate(sim_data_median ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = max)

all_combo_data_median_max = dplyr::select(all_combo_data_median_max,
                                          time = time,
                                          all_combo_median_max = sim_data_median)

all_combo_data_median_min = aggregate(sim_data_median ~ time, antibody_top_2_LL_params_and_sim_data,
                               FUN = min)
all_combo_data_median_min = dplyr::select(all_combo_data_median_min,
                                          time = time,
                                          all_combo_median_min = sim_data_median)


ML_output = antibody_top_2_LL_params_and_sim_data %>%
  filter(Antibody_Mean_LL == max(Antibody_Mean_LL))

ML_output = dplyr::select(ML_output, time = time,
                          ML_median = sim_data_median,
                          ML_high_Q = sim_data_high_Q,
                          ML_low_Q = sim_data_low_Q)

comp_data = join(ML_output, all_combo_data_high_Q_max)



## Joining by: time

comp_data = join(comp_data, all_combo_data_low_Q_min)

## Joining by: time

comp_data = join(comp_data, all_combo_data_median_min)

## Joining by: time

comp_data = join(comp_data, all_combo_data_median_max)

## Joining by: time

true_data = dplyr::select(Observed_data, time = times,
                          Observed_Data = Y)
comp_data = join(comp_data, true_data)

## Joining by: time



comp_data_melt = melt(comp_data, id.vars = c("time",
                                             "ML_high_Q", "ML_low_Q",
                                             "all_combo_high_Q_max",
                                             "all_combo_low_Q_min",
                                             "all_combo_median_min",
                                             "all_combo_median_max"))





comp_data_melt$ML_Q_Rib_Col = "95% Simulation Quantiles \n (MLE)"
comp_data_melt$All_combo_Med_Rib_Col = "Simulation Median \n  (all 2 LL combinations)"
comp_data_melt$All_combo_Q_Rib_Col = "95% Simulation Quantiles \n (all 2 LL combinations)"

fill_vec = c("Simulation Median \n  (all 2 LL combinations)" = "pink", "95% Simulation Quantiles \n (MLE)" = "skyblue", "95% Simulation Quantiles \n (all 2 LL combinations)" = "grey70")

p = ggplot(data = comp_data_melt) +
  geom_ribbon(aes(x = time, ymin = all_combo_low_Q_min,
                  ymax = all_combo_high_Q_max, fill = All_combo_Q_Rib_Col), inherit.aes = FALSE) +
  geom_ribbon(aes(x = time, ymin = ML_low_Q,
                  ymax = ML_high_Q, fill = ML_Q_Rib_Col),  inherit.aes = FALSE) +
  geom_ribbon(aes(x = time, ymin = all_combo_median_min,
                  ymax = all_combo_median_max, fill = All_combo_Med_Rib_Col), inherit.aes = FALSE) +
  geom_line(aes(x = time, y = value, color = variable)) +
  geom_point(aes(x = time, y = value, color = variable)) +
  rahul_theme +
  theme(legend.text = element_text(size = 12,
                             face = "bold",
                             color = "black")) +
  theme_white_background +

    scale_fill_manual(name = "Ribbon  Legend", values = fill_vec) +
  scale_color_manual(name = "Color  Legend", values = c("red","blue"),
                                     labels =
                                       c("Simulation Median \n (MLE)",
                                         "Observed",
                                         "Data Used For Fitting"))  +
   xlab("Days since March 1 2020")+
  ylab("Observed Monthly Cases")
p

```

```{r}
png(paste0("../Figures/Profiles/", model_name,
 "_Model/top_2_LL_sim_plots/top_2_LL_via_antibody_comp_plots/G_w_y_scaling_profile_Obs_daily_COVID_cases_vs_Ribbon_Plot_simulated_cases_over_time_simulation_from_G_w_y_scaling_profile_2_LL_antibody_from_antibody_profile_peak_params.png"))
print(p)
dev.off()
```


```{r}
p = ggplot(data = comp_data_melt) +
  geom_ribbon(aes(x = time, ymin = log(all_combo_low_Q_min),
                  ymax = log(all_combo_high_Q_max), fill = All_combo_Q_Rib_Col), inherit.aes = FALSE) +
  geom_ribbon(aes(x = time, ymin = log(ML_low_Q),
                  ymax = log(ML_high_Q), fill = ML_Q_Rib_Col),  inherit.aes = FALSE) +
  geom_ribbon(aes(x = time, ymin = log(all_combo_median_min),
                  ymax = log(all_combo_median_max), fill = All_combo_Med_Rib_Col), inherit.aes = FALSE) +
  geom_line(aes(x = time, y = log(value), color = variable)) +
  geom_point(aes(x = time, y = log(value), color = variable)) +
  rahul_theme +
  theme(legend.text = element_text(size = 12,
                             face = "bold",
                             color = "black")) +
  theme_white_background +

    scale_fill_manual(name = "Ribbon  Legend", values = fill_vec) +
  scale_color_manual(name = "Color  Legend", values = c("red","blue"),
                                     labels =
                                       c("Simulation Median \n (MLE)",
                                         "Observed",
                                         "Data Used For Fitting"))  +
   xlab("Days since March 1 2020")+
  ylab("Observed Monthly Cases")
p
```

```{r}
png(paste0("../Figures/Profiles/", model_name,
 "_Model/top_2_LL_sim_plots/top_2_LL_via_antibody_comp_plots/G_w_y_scaling_profile_log_Obs_daily_COVID_cases_vs_Ribbon_Plot_simulated_cases_over_time_simulation_from_2_LL_antibody_from_antibody_profile_peak.png"))
print(p)
dev.off()
```

## Profile analysis plots
```{r}
p = ggplot(data = top_2_LL_end_subset_with_antibody_LL,
           aes(x = p_S,
               y = Antibody_Mean_LL)) +
  geom_point() +
  rahul_man_figure_theme
p

png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "p_S_vs_Antibody_LL_", model_name,
           "_model_antibody_LL_from_G_w_y_scaling_Profile_peak_LL.png"))
print(p)
dev.off()

p = ggplot(data = top_2_LL_end_subset_with_antibody_LL,
           aes(x = b_a,
               y = Antibody_Mean_LL)) +
  geom_point() +
  rahul_man_figure_theme
p


png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "b_a_vs_Antibody_LL_", model_name,
           "_model_antibody_LL_from_G_w_y_scaling_Profile_peak_LL.png"))
print(p)
dev.off()


p = ggplot(data = top_2_LL_end_subset_with_antibody_LL,
           aes(x = R_0,
               y = Antibody_Mean_LL)) +
  geom_point() +
  rahul_man_figure_theme
p

png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "R_0_vs_Antibody_LL_", model_name,
           "_model_antibody_LL_from_G_w_y_scaling_Profile_peak_LL.png"))
print(p)
dev.off()

head(top_2_LL_end_subset_with_antibody_LL)
top_2_LL_end_subset_with_antibody_LL$duration_of_symp_1 = 1/top_2_LL_end_subset_with_antibody_LL$phi_S
top_2_LL_end_subset_with_antibody_LL$duration_of_symp_2 = 1/top_2_LL_end_subset_with_antibody_LL$gamma
top_2_LL_end_subset_with_antibody_LL =  top_2_LL_end_subset_with_antibody_LL %>%
  mutate(duration_of_symp = duration_of_symp_1 + duration_of_symp_2)
top_2_LL_end_subset_with_antibody_LL$gamma_total = 1/top_2_LL_end_subset_with_antibody_LL$duration_of_symp
top_2_LL_end_subset_with_antibody_LL = top_2_LL_end_subset_with_antibody_LL %>%
  mutate(Beta = R_0*gamma_total)

top_2_LL_end_subset_with_antibody_LL = top_2_LL_end_subset_with_antibody_LL%>%
  mutate(R_0_P = (Beta*b_p)/phi_U,
         R_0_A = (Beta*b_a *(1-p_S))/phi_S,
         R_0_S_1 = (Beta*p_S)/phi_S,
         R_0_S_2 = (Beta*(1-p_H_cond_S)*p_S)/gamma)
top_2_LL_end_subset_with_antibody_LL = top_2_LL_end_subset_with_antibody_LL %>%
  mutate(R_0_NGM = R_0_P + R_0_A + R_0_S_1 + R_0_S_2)

p = ggplot(data = top_2_LL_end_subset_with_antibody_LL,
           aes(x = R_0_NGM)) +
  geom_histogram() + rahul_man_figure_theme
p
png(file = paste0("../Figures/Profiles/", model_name, "_Model/G_w_y_scaling_profile/", model_name,
                  "_G_w_y_scaling_profile_R_0_NGM_histogram_for_all_parameter_combinations_within_2LL_of_profile_MLE_fit_to_cases.png"))
print(p)
dev.off()

p = ggplot(data = top_2_LL_end_subset_with_antibody_LL,
           aes(x = R_0,
               y = R_0_NGM,
               color = b_a)) +
  geom_point() +
  scale_color_viridis_c() +
  rahul_man_figure_theme
p
png(file = paste0("../Figures/Profiles/", model_name, "_Model/G_w_y_scaling_profile/", model_name,
                  "_G_w_y_scaling_profile_R_0_vs_R_0_NGM_color_b_a_for_all_parameter_combinations_within_2LL_of_profile_MLE_fit_to_cases.png"))
print(p)
dev.off()

p = ggplot(data = top_2_LL_end_subset_with_antibody_LL,
           aes(x = R_0,
               y = R_0_NGM,
               color = b_p)) +
  geom_point() +
  scale_color_viridis_c() +
  rahul_man_figure_theme
p
png(file = paste0("../Figures/Profiles/", model_name, "_Model/G_w_y_scaling_profile/", model_name,
                  "_G_w_y_scaling_profile_R_0_vs_R_0_NGM_color_b_p_for_all_parameter_combinations_within_2LL_of_profile_MLE_fit_to_cases.png"))
print(p)
dev.off()

p = ggplot(data = top_2_LL_end_subset_with_antibody_LL,
           aes(x = R_0,
               y = R_0_NGM,
               color = G_w_y_scaling)) +
  geom_point() +
  scale_color_viridis_c() +
  rahul_man_figure_theme
p
png(file = paste0("../Figures/Profiles/", model_name, "_Model/G_w_y_scaling_profile/", model_name,
                  "_G_w_y_scaling_profile_R_0_vs_R_0_NGM_color_G_w_y_scaling_for_all_parameter_combinations_within_2LL_of_profile_MLE_fit_to_cases.png"))
print(p)
dev.off()


p = ggplot(data = top_2_LL_end_subset_with_antibody_LL,
           aes(x = G_w_y_scaling,
               y = R_0_NGM)) +
  geom_point() + rahul_man_figure_theme
p
png(file = paste0("../Figures/Profiles/", model_name, "_Model/G_w_y_scaling_profile/", model_name,
                  "_G_w_y_scaling_profile_G_w_y_scaling_vs_R_0_NGM_histogram_for_all_parameter_combinations_within_2LL_of_profile_MLE_fit_to_cases.png"))
print(p)
dev.off()



antibody_top_2_LL_from_G_w_y_scaling_profile_top_2_LL =
  top_2_LL_end_subset_with_antibody_LL %>%
  filter(Antibody_Mean_LL > max(Antibody_Mean_LL)-2)

nrow(antibody_top_2_LL_from_G_w_y_scaling_profile_top_2_LL)
range(antibody_top_2_LL_from_G_w_y_scaling_profile_top_2_LL$R_0)
antibody_top_2_LL_from_G_w_y_scaling_profile_top_2_LL

p = ggplot(data = antibody_top_2_LL_from_G_w_y_scaling_profile_top_2_LL,
           aes(x = b_a,
               y = R_0)) +
  geom_point() +
  rahul_man_figure_theme
p

png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "top_2_LL_via_antibody_comp_plots/",
           "b_a_vs_R_0_", model_name,
           "_model_top_2_antibody_LL_from_G_w_y_scaling_profile_peak_LL.png"))
print(p)
dev.off()

p = ggplot(data = antibody_top_2_LL_from_G_w_y_scaling_profile_top_2_LL,
           aes(x = b_a,
               y = log(R_0))) + geom_hline(yintercept = log(3), color = 'orange') +
  geom_hline(yintercept = log(4), color = 'purple') +
  geom_point() +
  rahul_man_figure_theme
p

png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "top_2_LL_via_antibody_comp_plots/",
           "b_a_vs_log_R_0_", model_name,
           "_model_top_2_antibody_LL_from_G_w_y_scaling_profile_peak_LL.png"))
print(p)
dev.off()


p = ggplot(data = antibody_top_2_LL_from_G_w_y_scaling_profile_top_2_LL,
           aes(x = b_p,
               y = R_0)) +
  geom_point() +
  rahul_man_figure_theme
p

png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "top_2_LL_via_antibody_comp_plots/",
           "b_p_vs_R_0_", model_name,
           "_model_top_2_antibody_LL_from_G_w_y_scaling_profile_peak_LL.png"))
print(p)
dev.off()

p = ggplot(data = antibody_top_2_LL_from_G_w_y_scaling_profile_top_2_LL,
           aes(x = b_q,
               y = R_0)) +
  geom_point() +
  rahul_man_figure_theme
p
png(paste0("../Figures/Profiles/", model_name, "_Model/top_2_LL_sim_plots/",
           "top_2_LL_via_antibody_comp_plots/",
           "b_q_vs_R_0_", model_name,
           "_model_top_2_antibody_LL_from_G_w_y_scaling_profile_peak_LL.png"))
print(p)
dev.off()

antibody_top_2_LL_from_G_w_y_scaling_profile_top_2_LL$R_0_NGM
```
